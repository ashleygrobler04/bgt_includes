const double HALFSTEP=1.059463;//for on-the-fly transposition
const int8 DE_NOTE_ON=0, DE_NOTE_OFF=1, DE_VOL_ALL=2;

class dac_event {
	int8 type=0;
	int8 note=0;
	int8 volume=0;
	int8 transpose=0;
	double time=0.0;
	dac_event() {}
	dac_event(double t, int n, int v, int ty, int tr) {
		note=n; type=ty; transpose=tr; volume=v; time=t;
}
	int opCmp (dac_event@ de) {
		return de.time-this.time;
	}
}

const string NOTE_INDEX="CdDeEFgGaAbB";

class dactrack {
	sound@[] sounds;
	int base_octave=1; // Sounds cannot go below this octave.
	sound@ song=null; // Could be anything, but the intention is that it will be generated by the soundtrack object.
	dac_event@[] events;
	int tick=0; // Sort events temporally!
	double loop_start=0, loop_end=0;
	int loop_count=1;
	
	dactrack() {}
	
	void set_song(sound@ snd) {@song=snd;}
		double tempo=120.0;
		double volume=0.0;
		int transposition=0;
		int octave=base_octave;
//		int cursor=0;
		int default_length=4;
		double time=0.0; // Beware rounding errors.
	int quantization=9; // Do nothing to disable the sound.
int channel_count=0;
	void add_channel(string commands) {
channel_count++;
tempo=120.0;
volume=100.0;
transposition=0;
octave=base_octave;
int cursor=0;
default_length=4;
time=0.0; // Beware rounding errors.
quantization=9; // Do nothing to disable the sound.
process_commands(commands, cursor);
}

uint process_commands(string commands, int cursor=0) {
string channel_input=commands;
		while(cursor < commands.length()) {
			string command = commands[cursor];
if(command == "o") {
				cursor++;
				octave=string_to_number(commands[cursor]);
				cursor++;
				if(octave<base_octave or (octave-base_octave)*12>=this.sounds.length()) {alert("DAC error", "Invalid octave: " + octave + "; legal range is " + base_octave + " to " + ((this.sounds.length()/12)+base_octave) + ". "); exit();}
}
else if(command == "<") {
				cursor++;
				octave--;
				if(octave<base_octave or (octave-base_octave)*12>=this.sounds.length()) {alert("DAC error", "Invalid octave: " + octave + "; legal range is " + base_octave + " to " + ((this.sounds.length()/12)+base_octave) + ". "); exit();}
}
else if(command == ">") {
				cursor++;
				octave++;
				if(octave<base_octave or (octave-base_octave)*12>=this.sounds.length()) {alert("DAC error", "Invalid octave: " + octave + "; legal range is " + base_octave + " to " + ((this.sounds.length()/12)+base_octave) + ". "); exit();}
}
else if(command == "l") {
				cursor++;
				cursor=get_number(commands, cursor, default_length);
}
else if(command == "p") {
cursor++; // Skip the p
int pause_length;
uint number_position = cursor;
cursor = get_number(channel_input, cursor, pause_length);
if(pause_length < 1 || pause_length > 64) {
signal_error("Length " + pause_length + " is invalid. Valid lengths are 1-64", number_position);
}
double beats = 4.0 / pause_length;
double ms = (60000.0 / tempo) * beats;
time+=ms; // Beware rounding errors. beware them hard.
}
else if(command>="A" && command<="G") {
string note_letter = channel_input[cursor++];
string to_generate = note_letter;
int index=(octave-base_octave)*12;
index+=string_contains(NOTE_INDEX, note_letter, 1);
if(cursor < channel_input.length() && channel_input[cursor] == "+") {
to_generate += "#";
index++;
cursor++;
}
else if(cursor < channel_input.length() && channel_input[cursor] == "-") {
to_generate += "b";
index--;
cursor++;
}

int length = default_length;

if(check_number(channel_input, cursor)) {
uint number_position = cursor;
cursor = get_number(channel_input, cursor, length);
if(length < 1 || length > 64) {
signal_error("Length " + length + " is invalid. Valid lengths are 1-64", number_position);
}
}

double beats = 4.0 / length;
if(cursor < channel_input.length() && channel_input[cursor] == ".") {
cursor++;
beats *= 1.5;
}
double ms = (60000.0 / tempo) * beats;

add_event(time, index, DE_NOTE_ON, volume, transposition);
if(quantization<9) {
add_event(time+(ms*quantization/8.0), index, DE_NOTE_OFF, volume, transposition);
}
if(cursor >= channel_input.length() || channel_input[cursor] != "&") {
// Pick which of these has the fewest sync problems:
time+=ms;
// time=round(time+ms, 3);
}
else {
cursor++;
}

}
else if(command == "@") {
cursor+=2;
}
else if(command == "t") {
cursor++; // Skip the t
uint number_position = cursor;
cursor = get_number(channel_input, cursor, tempo);
if(tempo < 60 || tempo > 240) {
signal_error("Tempo " + tempo + " is invalid. Valid tempi are 60-240", number_position);
}

}
else if(command == "q") {
cursor++; // Skip the q
uint number_position = cursor;
cursor = get_number(channel_input, cursor, quantization);
if(quantization < 1 || quantization > 100) {
signal_error("Invalid quantization " + quantization + ". Valid quantizations are 1-100", number_position);
}

}
else if(command == "[") {
cursor++; // Skip the [
uint cursor2 = process_commands(channel_input, cursor);
if(cursor2 >= channel_input.length() || channel_input[cursor2] != "]") {
signal_error("] expected", cursor2);
}
cursor2++;
int repetitions;
uint number_position = cursor2;
cursor2 = get_number(channel_input, cursor2, repetitions);
if(repetitions < 2 || repetitions > 100) {
signal_error("Invalid repetition count " + repetitions + ". Valid repetition counts are 2-100", number_position);
}
repetitions--; // We already did one
for(int i=0; i<repetitions; i++) {
process_commands(channel_input, cursor);
}
return cursor2;

}
else if(command == "v") {
cursor++; // Skip the v
uint number_position = cursor;
cursor = get_number(channel_input, cursor, volume);
if(volume>100) {
signal_error("Invalid volume " + volume + ". Valid volumes are 0-100", number_position);
}
}
//else if(command == "a") {
//cursor = cmd_a(commands, cursor);
//}
//else if(command == "r") {
//cursor = cmd_r(commands, cursor);
//}
else if(command == "n") {
cursor++;
transposition=0;
}
else if(command == "u") {
cursor++; // Skip the u
uint number_position = cursor;
cursor = get_number(channel_input, cursor, transposition);
if(transposition < 1 || transposition > 11) {
signal_error("Invalid transpose value " + transposition + ". Valid transpose values are 1-11", number_position);
}

}
else if(command == "d") {
int transpose=transposition;
cursor++; // Skip the d
uint number_position = cursor;
cursor = get_number(channel_input, cursor, transpose);
if(transpose < 1 || transpose > 11) {
signal_error("Invalid transpose value " + transpose + ". Valid transpose values are 1-11", number_position);
}
transposition = -transpose;
}
//else if(command=="s") {
//
//}
else {
break;
}
}
return cursor;
	}// Parse. Ouch.
	
	dac_event@ add_event(double time, int note, int type, int vol, int tr) {
		dac_event event(time, note, vol, type, tr);
		if(this.events.length()==0) this.events.insert_last(event);
		else if(event.time>=this.events[this.events.length()-1].time) this.events.insert_last(event);
		//else if(event.time<=this.events[0].time) this.events.insert_ast(0, event);
		else {
			for(uint i=0; i<this.events.length(); i++) {
				if(this.events[i].time<=event.time) {this.events.insert_at(i, event); i=this.events.length();}
			}// insertion loop.
		}
		return event;
	}
bool check_number(string channel_input, uint cursor) {
if(cursor >= channel_input.length() || channel_input[cursor] < "0" || channel_input[cursor] > "9") {
return false;
}
return true;
}

uint get_number(string channel_input, uint cursor, int &out number) {
if(!check_number(channel_input, cursor)) {
signal_error("Number expected", cursor);
}
uint saved_cursor = cursor;
string digits = "";
do {
digits += channel_input[cursor++];
} while(check_number(channel_input, cursor));
if(digits.length() > 3) {
signal_error("Number too long; please restrict to three decimal digits", saved_cursor);
}
number = string_to_number(digits);
return cursor;
}

void signal_error(string message, uint cursor) {
alert("Dactrack error", "Channel " + channel_count + ", column " + (cursor+1) + ": " + message);
exit();
}

	void set_note(string note, sound@ snd) {
		string note_letter=note[0];
		int o=base_octave;;
		int index=0;
		int8 accident=0;
		if(note.length()>1) {
			int trim=1;
			if(note[1]=="#" or note[1]=="+") {
				accident=1;
				trim=2;
			}
			else if(note[1]=="-" or note[1]=="b") {
				accident=-1;
				trim=2;
			}
			o=string_to_number(string_right(note, note.length()-trim));
		}
		index=string_contains(NOTE_INDEX, note_letter, 1)+accident;
		index+=(o-base_octave)*12;
		if(index<0 or index>95) {alert("Dactrack error", "Invalid note: " + note + " at " + index + "; valid range is 0-95, C" + base_octave + " - B" + (base_octave+8) + "."); return;}
		if(index>sounds.length()) sounds.resize(index+1);
		@(sounds[index])=snd;
	}
	
	void stop() {
		if(@song!=null) song.stop();
		for(uint i=0; i<sounds.length(); i++) {
			if(@(sounds[i])!=null) sounds[i].stop();
		}
	}
	void reset() {
		stop();
		tick=0;
		time=0;
		if(@song!=null) song.seek(0);
	}
	
	bool play() {
		if(@song!=null) song.play();
		update();
		return true;
	}// Play.
	
	void update() {
		int l=events.length();
		while(tick<l and events[tick].time<=song.position) {
			int t=events[tick].type;
			if(t==DE_NOTE_ON) {
				if(events[tick].note<0 or events[tick].note>=sounds.length() or @(sounds[events[tick].note])==null) {
					tick++;
				}
				else {
					sounds[events[tick].note].volume=(events[tick].volume/2.0)-50;
					sounds[events[tick].note].pitch=100.0*power(HALFSTEP, events[tick].transpose);
					sounds[events[tick].note].stop();
					sounds[events[tick].note].seek(0);
					sounds[events[tick].note].play();
					tick++;
				}
			}// note on.
			else if(t==DE_NOTE_OFF) {
				if(events[tick].note<0 or events[tick].note>=sounds.length() or @(sounds[events[tick].note])==null) {
					tick++;
				}
				else {
					sounds[events[tick].note].stop();
					tick++;
				}
			}// note off
			else if(t==DE_VOL_ALL) {
				double v=(events[tick].volume/2.0)-50;
				song.volume=v;
				for(uint i=0; i<sounds.length(); i++) {
					if(@(sounds[i])!=null) sounds[i].volume=v;
				}
				tick++;
			}// Volume, all.
			else tick++;
		}// event loop.
		
		if(loop_count!=0 and loop_end>loop_start and song.position>=loop_end) {
			song.seek(loop_start); // Possibly adjust for any overflow? I.e, song.seek(song.position-(loop_end-loop_start));
			tick=0;
			while(tick<events.length() and events[tick].time<song.position) {tick++;}
			loop_count--;
			update(); // so there aren't any glitches at loops.
		}// looping.
	}// Update.
}// dactrack

