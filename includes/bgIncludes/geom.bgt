#include "math.bgt"


vector newPoint(double x, double y, double z=0) {vector ret(x, y, z); return ret;}
 vector newPoint2D(double x, double y) {return newPoint(x, y);}
 vector newPoint3D(double x, double y, double z) {return newPoint(x, y, z);}

interface Shape {

 Rectangle@ getBounds();
// void setBounds(Rectangle@ r);
// void setBounds(double x, double y, double w, double h);
 bool contains(double x, double y);
 bool contains(vector p);
 bool intersects(double x, double y, double w, double h);
 bool intersects(Rectangle@ r);
 bool contains(double x, double y, double w, double h);
 bool contains(Rectangle@ r);
 PathIterator@ getPathIterator(AffineTransform@ at);
 PathIterator@ getPathIterator(AffineTransform@ at, double flatness);
 Shape@ translate(double dx, double dy);
 Shape@ rotate(double theta);
 Shape@ rotate(vector p, double theta);
 Shape@ rotate(double rx, double ry, double theta);
 Shape@ mirrorX();
 Shape@ mirrorY();
 }// Shape.

 // If given the endpoints for two line segments, this function returns the point at which they intersect.
 // If the segments do not intersect, the return value will be null.
 vector lineIntersects(vector p1, vector p2, vector p3, vector p4) {
 // Let's be sure that our points are in left-right order.
 double x1=p1.x; double x2=p2.x; double x3=p3.x; double x4=p4.x;
 double y1=p1.y; double y2=p2.y; double y3=p3.y; double y4=p4.y;
 if(x3>x4) {x3=p4.x; x4=p3.x; y3=p4.y; y4=p3.y;}
 if(x1>x2) {x1=p2.x; x2=p1.x; y1=p2.y; y2=p1.y;}

 // Now, find the slopes.
 // Ur, be aware that vertical lines might happen...
 double m1;
 if(x1==x2) m1=1999999999;
 else m1=(y2-y1)/(x2-x1); 
 double m2;
 if(x3==x4) m2=1999999999;
 else m2=(y4-y3)/(x4-x3);

 double b1=y1-(m1*x1);
 double b2=y3-(m2*x3);
 if(m1==m2) {
 if(b1==b2) {
 // One point must be between the other two.
 if((x3>=x1)&&(x3<=x2)) return newPoint(x3, y3);
 else if((x4>=x1)&&(x4<=x2)) return newPoint(x4, y4);
 else if((x1>=x3)&&(x1<=x4)) return newPoint(x1, y1);
 else if((x2>=x3)&&(x2<=x4)) return newPoint(x2, y2);
 else return nullpoint;
 }
 else return nullpoint;
 }// They don't collide unless b1 and b2 are the same.
 else {
double rx=(b2-b1)/(m1-m2);
 if((rx>=x1)&&(rx<=x2)&&(rx>=x3)&&(rx<=x4)) {
 double ry = (m1*rx)+b1;

 return newPoint(rx, ry);
} else return nullpoint;
}
// return null;
 }
 vector newVector(double x, double y, double z=0) {vector ret(x, y, z); return ret;}

class Rectangle : Shape {
 float x; float y;
 float width; float height;
 Rectangle() {x=0; y=0; width=0; height=0;}
 Rectangle(float xx, float yy, float w, float h) {x=xx; y=yy; width=w; height=h;}
 void moveTo(float tx, float ty) {x=tx; y=ty;}
 void moveBy(float dx, float dy) {x+=dx; y+=dy;}
 bool collide_line(vector p, float angle) {return collide_line(p.x, p.y, angle);}
 bool collide_line(float lx, float ly, float angle) {
// Convert to cartesian, please.
 // I think the slope is just the tangent of the angle, so:
 float m=tangent(angle);
 vector p1(lx, ly);
 vector p2(lx+100, ly+(100.0*m));
 vector[] points=getPoints();
 for(uint i=0; i<points.length(); i++) {
 vector p3=points[i];
 vector p4=points[i%points.length()];
 vector res=lineIntersects(p1, p2, p3, p4);
 if(!isNull(res)) return true;
 }// Collisions. Does it really work this way?
 return false;
 }// Collide_line. Or ray, to be more precise.
 bool intersectsLine(vector p1, vector p2) {return intersectsLine(p1.x, p1.y, p2.x, p2.y);}
 bool intersectsLine(double lx, double ly, double lx2, double ly2) {
 vector p1(lx, ly); vector p2(lx2, ly2);
 vector[] points=getPoints();
 for(uint i=0; i<points.length(); i++) {
 vector p3=points[i];
 vector p4=points[i%points.length()];
 vector res=lineIntersects(p1, p2, p3, p4);
 if(!isNull(res)) return true;
 }// Collisions. Does it really work this way?
 return false;
 }// Collide_line. Or ray, to be more precise.

 bool intersects(Rectangle@ r) {return collide(r);}
 bool collide(Rectangle@ r) {
 if(@r==null) return false;
return collide(r.x, r.y, r.width, r.height);}
 bool intersects(double xx, double yy, double w, double h) {return collide(xx, yy, w, h);}
 bool collide(float rx, float ry, float rw, float rh) {
 float x1=x; float x2=x+width;
 float x3=rx; float x4=rx+rw;
 float y1=y; float y2=y+height;
 float y3=ry; float y4=ry+rh;
 return (
 (((x3>=x1)&&(x3<=x2))||((x4>=x1)&&(x4<=x2))||
((x1>=x3)&&(x1<=x4))||((x2>=x3)&&(x2<=x4))
)&&
(
((y3>=y1)&&(y3<=y2))||((y4>=y1)&&(y4<=y2))||
((y1>=y3)&&(y1<=y4))||((y2>=y3)&&(y2<=y4))
)
);
}// Collide.

// Returns points starting from (x, y) and continuing counterclockwise along the edge of the rectangle.
 vector[] getPoints() {
 vector[] ret={
 newVector(x, y),
 newVector(x, y+height),
 newVector(x+width, y+height),
 newVector(x+width, y)
};
 return ret;
 }
 Rectangle@ clone() {
 return newRectangle(x, y, width, height);
 }
 Rectangle@ rotate() {
 return newRectangle(x, y, height, width);
}
 string save() {return "" + x + ", " + y + ", " + width + ", " + height;}

 // interface methods
 void setBounds(Rectangle@ r) {setBounds(r.x, r.y, r.width, r.height);}
 void setBounds(double xx, double yy, double w, double h) {x=xx; y=yy; width=w; height=h;}
 bool contains(vector p) {return contains(p.x, p.y);}
 bool contains(double xx, double yy) {
 return (
 (xx>=x)&&(xx<=x+width)&&
 (yy>=y)&&(yy<=y+height)
);
}// Contains.
 bool contains(Rectangle@ r) {
 if(@r==null) return false;
return contains(r.x, r.y, r.width, r.height);
}
 bool contains(double xx, double yy, double w, double h) {
 return (
 (xx>=x)&&(xx<=x+width)&&(xx+w>=x)&&(xx+w<=x+width)&&
 (yy>=y)&&(yy<=y+height)&&(yy+h>=y)&&(yy+h<=y+height)
);
}// Contains.
 Rectangle@ getBounds() {return clone();}
 PathIterator@ getPathIterator(AffineTransform@ at) { RectIterator ret(this, at); return ret;}
 PathIterator@ getPathIterator(AffineTransform@ at, double flatness) {
 RectIterator ri(this, at);
 FlatteningPathIterator ret(ri, flatness);
 return ret;
 }// Path iterator.

 // New interface methods to ease my issues with AffineTransforms.
 Shape@ translate(double dx, double dy) {Rectangle@ ret=clone(); ret.moveBy(dx, dy); return ret;}
 Shape@ rotate(double theta) {
 double cx=x+(width/2);
 double cy=y+(height/2);
 return rotate(cx, cy, theta);
}
 Shape@ rotate(double cx, double cy, double theta) {return rotate(newVector(cx, cy), theta);}
 Shape@ rotate(vector p, double theta) {
 vector[] points=getPoints();
 Polygon ret;
 for(uint i=0; i<points.length(); i++) {
 points[i]= (::rotate(points[i], p, theta));
 ret.addPoint(points[i].x, points[i].y);
}
 ret.addPoint(points[0].x, points[0].y);
 return ret;
}// Meh.
 Shape@ mirrorX() {
 Rectangle@ ret=clone();
 ret.x=-ret.x-ret.width; // Really? Does that really work in all cases?
 return ret;
}
 Shape@ mirrorY() {
 Rectangle ret(x, -y-height, width, height); return ret;
}

}// Rectangle.
 Rectangle@ newRectangle(float x, float y, float width, float height) {Rectangle ret(x, y, width, height); return ret;}
 Rectangle@ loadRectangle(string txt) {
 string[] parts=string_split(txt, ", ", true);
 Rectangle@ ret=newRectangle(0, 0, 1, 1);
 if(parts.length()>0) ret.x=string_to_number(parts[0]);
 if(parts.length()>1) ret.y=string_to_number(parts[1]);
 if(parts.length()>2) ret.width=string_to_number(parts[2]);
 if(parts.length()>3) ret.height=string_to_number(parts[3]);
 return ret;
}// Load rectangle.

vector nullpoint(-12345.67, 76543.21);


// affine transform constants:
 const int TYPE_UNKNOWN = -1;
 // java.awt.geom.AffineTransform includes 16 lines of documentation right here. 16 lines. For a constant.
 const int TYPE_IDENTITY = 0;
 const int TYPE_TRANSLATION = 1;
 const int TYPE_UNIFORM_SCALE = 2;
 const int TYPE_GENERAL_SCALE = 4;
 const int TYPE_MASK_SCALE = (TYPE_UNIFORM_SCALE | TYPE_GENERAL_SCALE);
 const int TYPE_FLIP = 64;
 const int TYPE_QUADRANT_ROTATION = 8;
 const int TYPE_GENERAL_ROTATION = 16;
 const int TYPE_MASK_ROTATION = (TYPE_QUADRANT_ROTATION | TYPE_GENERAL_ROTATION);
 const int TYPE_GENERAL_TRANSFORM = 32;
 const int APPLY_IDENTITY = 0;
 const int APPLY_TRANSLATE = 1;
 const int APPLY_SCALE = 2;
 const int APPLY_SHEAR = 4;

    /*
     * For methods which combine together the state of two separate
     * transforms and dispatch based upon the combination, these constants
     * specify how far to shift one of the states so that the two states 
     * are mutually non-interfering and provide constants for testing the
     * bits of the shifted (HI) state.  The methods in this class use
     * the convention that the state of "this" transform is unshifted and
     * the state of the "other" or "argument" transform is shifted (HI).
     */
 const int HI_SHIFT = 3;
 const int HI_IDENTITY = APPLY_IDENTITY << HI_SHIFT;
 const int HI_TRANSLATE = APPLY_TRANSLATE << HI_SHIFT;
 const int HI_SCALE = APPLY_SCALE << HI_SHIFT;
 const int HI_SHEAR = APPLY_SHEAR << HI_SHIFT;

 class AffineTransform {

    /**
     * The X coordinate scaling element of the 3x3
     * affine transformation matrix.
     */
    double m00;
    /**
     * The Y coordinate shearing element of the 3x3
     * affine transformation matrix.
     */ 
     double m10;
    /**
     * The X coordinate shearing element of the 3x3
     * affine transformation matrix.
     */
     double m01; 
    /**
     * The Y coordinate scaling element of the 3x3
     * affine transformation matrix.
     */
     double m11; 
    /**
     * The X coordinate of the translation element of the
     * 3x3 affine transformation matrix.
     */
     double m02;
    /**
     * The Y coordinate of the translation element of the
     * 3x3 affine transformation matrix.
     */
     double m12;
    /**
     * This field keeps track of which components of the matrix need to
     * be applied when performing a transformation.
     */
 int state;
    /**
     * This field caches the current transformation type of the matrix.
     */
 int type;
 AffineTransform(double m00, double m10,
 double m01, double m11,
 double m02, double m12,
 int state) {
 this.m00 = m00;
 this.m10 = m10;
 this.m01 = m01;
 this.m11 = m11;
 this.m02 = m02;
 this.m12 = m12;
 this.state = state;
 this.type = TYPE_UNKNOWN;
    }
    /**
     * Constructs a new <code>AffineTransform</code> representing the
     * Identity transformation.
     * @since 1.2
     */
 AffineTransform() {
 m00 = m11 = 1.0;
 m01 = m10 = m02 = m12 = 0.0;  /* Not needed. */
 state = APPLY_IDENTITY;  /* Not needed. */
 type = TYPE_IDENTITY;  /* Not needed. */
    }
    /**
     * Constructs a new <code>AffineTransform</code> that is a copy of
     * the specified <code>AffineTransform</code> object.
     * @param Tx the <code>AffineTransform</code> object to copy 
     * @since 1.2
     */
 AffineTransform(AffineTransform@ Tx) {
 this.m00 = Tx.m00;
 this.m10 = Tx.m10;
 this.m01 = Tx.m01;
 this.m11 = Tx.m11;
 this.m02 = Tx.m02;
 this.m12 = Tx.m12;
 this.state = Tx.state;
 this.type = Tx.type;
    }
    /**
     * Constructs a new <code>AffineTransform</code> from 6 floating point
     * values representing the 6 specifiable entries of the 3x3
     * transformation matrix.
     *
     * @param m00 the X coordinate scaling element of the 3x3 matrix
     * @param m10 the Y coordinate shearing element of the 3x3 matrix
     * @param m01 the X coordinate shearing element of the 3x3 matrix
     * @param m11 the Y coordinate scaling element of the 3x3 matrix
     * @param m02 the X coordinate translation element of the 3x3 matrix
     * @param m12 the Y coordinate translation element of the 3x3 matrix
     * @since 1.2
     */
 AffineTransform(float m00, float m10,
      float m01, float m11,
      float m02, float m12) {
 this.m00 = m00;
 this.m10 = m10;
 this.m01 = m01;
 this.m11 = m11;
 this.m02 = m02;
 this.m12 = m12;
 updateState();
    }
    /**
     * Constructs a new <code>AffineTransform</code> from an array of
     * floating point values representing either the 4 non-translation 
     * enries or the 6 specifiable entries of the 3x3 transformation
     * matrix.  The values are retrieved from the array as 
     * {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;[m02&nbsp;m12]}.
     * @param flatmatrix the float array containing the values to be set
     * in the new <code>AffineTransform</code> object. The length of the
     * array is assumed to be at least 4. If the length of the array is 
     * less than 6, only the first 4 values are taken. If the length of
     * the array is greater than 6, the first 6 values are taken.
     * @since 1.2
     */
 AffineTransform(float[] flatmatrix) {
 m00 = flatmatrix[0];
 m10 = flatmatrix[1];
 m01 = flatmatrix[2];
 m11 = flatmatrix[3];
 if (flatmatrix.length > 5) {
     m02 = flatmatrix[4];
     m12 = flatmatrix[5];
 }
 updateState();
    }
    /**
     * Constructs a new <code>AffineTransform</code> from 6 double
     * precision values representing the 6 specifiable entries of the 3x3
     * transformation matrix.
     *
     * @param m00 the X coordinate scaling element of the 3x3 matrix
     * @param m10 the Y coordinate shearing element of the 3x3 matrix
     * @param m01 the X coordinate shearing element of the 3x3 matrix
     * @param m11 the Y coordinate scaling element of the 3x3 matrix
     * @param m02 the X coordinate translation element of the 3x3 matrix
     * @param m12 the Y coordinate translation element of the 3x3 matrix
     * @since 1.2
     */
 AffineTransform(double m00, double m10,
      double m01, double m11,
      double m02, double m12) {
 this.m00 = m00;
 this.m10 = m10;
 this.m01 = m01;
 this.m11 = m11;
 this.m02 = m02;
 this.m12 = m12;
 updateState();
    }
    /**
     * Constructs a new <code>AffineTransform</code> from an array of
     * double precision values representing either the 4 non-translation
     * entries or the 6 specifiable entries of the 3x3 transformation
     * matrix. The values are retrieved from the array as 
     * {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;[m02&nbsp;m12]}.     
     * @param flatmatrix the double array containing the values to be set
     * in the new <code>AffineTransform</code> object. The length of the
     * array is assumed to be at least 4. If the length of the array is 
     * less than 6, only the first 4 values are taken. If the length of
     * the array is greater than 6, the first 6 values are taken.
     * @since 1.2
     */
 AffineTransform(double[] flatmatrix) {
 m00 = flatmatrix[0];
 m10 = flatmatrix[1];
 m01 = flatmatrix[2];
 m11 = flatmatrix[3];
 if (flatmatrix.length > 5) {
     m02 = flatmatrix[4];
     m12 = flatmatrix[5];
 }
 updateState();
    }
 int getType() {
 if (type == TYPE_UNKNOWN) {
     calculateType();
 }
 return type;
    }
    /**
     * This is the utility function to calculate the flag bits when
     * they have not been cached.
     * @see #getType
     */
 void calculateType() {
 int ret = TYPE_IDENTITY;
 bool sgn0, sgn1;
 double M0, M1, M2, M3;
 updateState();
 switch (state) {
// default:
//     stateError();
     /* NOTREACHED */
 case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
     ret = TYPE_TRANSLATION;
     /* NOBREAK */
 case (APPLY_SHEAR | APPLY_SCALE):
     if ((M0 = m00) * (M2 = m01) + (M3 = m10) * (M1 = m11) != 0) {
  // Transformed unit vectors are not perpendicular...
  this.type = TYPE_GENERAL_TRANSFORM;
  return;
     }
     sgn0 = (M0 >= 0.0);
     sgn1 = (M1 >= 0.0);
     if (sgn0 == sgn1) {
  // sgn(M0) == sgn(M1) therefore sgn(M2) == -sgn(M3)
  // This is the "unflipped" (right-handed) state
  if (M0 != M1 || M2 != -M3) {
      ret |= (TYPE_GENERAL_ROTATION | TYPE_GENERAL_SCALE);
  } else if (M0 * M1 - M2 * M3 != 1.0) {
      ret |= (TYPE_GENERAL_ROTATION | TYPE_UNIFORM_SCALE);
  } else {
      ret |= TYPE_GENERAL_ROTATION;
  }
     } else {
  // sgn(M0) == -sgn(M1) therefore sgn(M2) == sgn(M3)
  // This is the "flipped" (left-handed) state
  if (M0 != -M1 || M2 != M3) {
      ret |= (TYPE_GENERAL_ROTATION |
       TYPE_FLIP |
       TYPE_GENERAL_SCALE);
  } else if (M0 * M1 - M2 * M3 != 1.0) {
      ret |= (TYPE_GENERAL_ROTATION |
       TYPE_FLIP |
       TYPE_UNIFORM_SCALE);
  } else {
      ret |= (TYPE_GENERAL_ROTATION | TYPE_FLIP);
  }
     }
     break;
 case (APPLY_SHEAR | APPLY_TRANSLATE):
     ret = TYPE_TRANSLATION;
     /* NOBREAK */
 case (APPLY_SHEAR):
     sgn0 = ((M0 = m01) >= 0.0);
     sgn1 = ((M1 = m10) >= 0.0);
     if (sgn0 != sgn1) {
  // Different signs - simple 90 degree rotation
  if (M0 != -M1) {
      ret |= (TYPE_QUADRANT_ROTATION | TYPE_GENERAL_SCALE);
  } else if (M0 != 1.0 && M0 != -1.0) {
      ret |= (TYPE_QUADRANT_ROTATION | TYPE_UNIFORM_SCALE);
  } else {
      ret |= TYPE_QUADRANT_ROTATION;
  }
     } else {
  // Same signs - 90 degree rotation plus an axis flip too
  if (M0 == M1) {
      ret |= (TYPE_QUADRANT_ROTATION |
       TYPE_FLIP |
       TYPE_UNIFORM_SCALE);
  } else {
      ret |= (TYPE_QUADRANT_ROTATION |
       TYPE_FLIP |
       TYPE_GENERAL_SCALE);
  }
     }
     break;
 case (APPLY_SCALE | APPLY_TRANSLATE):
     ret = TYPE_TRANSLATION;
     /* NOBREAK */
 case (APPLY_SCALE):
     sgn0 = ((M0 = m00) >= 0.0);
     sgn1 = ((M1 = m11) >= 0.0);
     if (sgn0 == sgn1) {
  if (sgn0) {
      // Both scaling factors non-negative - simple scale
      // Note: APPLY_SCALE implies M0, M1 are not both 1
      if (M0 == M1) {
   ret |= TYPE_UNIFORM_SCALE;
      } else {
   ret |= TYPE_GENERAL_SCALE;
      }
  } else {
      // Both scaling factors negative - 180 degree rotation
      if (M0 != M1) {
   ret |= (TYPE_QUADRANT_ROTATION | TYPE_GENERAL_SCALE);
      } else if (M0 != -1.0) {
   ret |= (TYPE_QUADRANT_ROTATION | TYPE_UNIFORM_SCALE);
      } else {
   ret |= TYPE_QUADRANT_ROTATION;
      }
  }
     } else {
  // Scaling factor signs different - flip about some axis
  if (M0 == -M1) {
      if (M0 == 1.0 || M0 == -1.0) {
   ret |= TYPE_FLIP;
      } else {
   ret |= (TYPE_FLIP | TYPE_UNIFORM_SCALE);
      }
  } else {
      ret |= (TYPE_FLIP | TYPE_GENERAL_SCALE);
  }
     }
     break;
 case (APPLY_TRANSLATE):
     ret = TYPE_TRANSLATION;
     break;
 case (APPLY_IDENTITY):
     break;
 }
 this.type = ret;
    }
    /**
     * Returns the determinant of the matrix representation of the transform.
     * The determinant is useful both to determine if the transform can
     * be inverted and to get a single value representing the
     * combined X and Y scaling of the transform.
     * <p>
     * If the determinant is non-zero, then this transform is
     * invertible and the various methods that depend on the inverse
     * transform do not need to throw a
     * {@link NoninvertibleTransformException}.
     * If the determinant is zero then this transform can not be
     * inverted since the transform maps all input coordinates onto
     * a line or a point.
     * If the determinant is near enough to zero then inverse transform
     * operations might not carry enough precision to produce meaningful
     * results.
     * <p>
     * If this transform represents a uniform scale, as indicated by
     * the <code>getType</code> method then the determinant also
     * represents the square of the uniform scale factor by which all of
     * the points are expanded from or contracted towards the origin.
     * If this transform represents a non-uniform scale or more general
     * transform then the determinant is not likely to represent a
     * value useful for any purpose other than determining if inverse
     * transforms are possible.
     * <p>
     * Mathematically, the determinant is calculated using the formula:
     * <pre>
     *  |  m00  m01  m02  |
     *  |  m10  m11  m12  |  =  m00 * m11 - m01 * m10
     *  |   0    0    1   |
     * </pre>
     *
     * @return the determinant of the matrix used to transform the
     * coordinates.
     * @see #getType
     * @see #createInverse
     * @see #inverseTransform
     * @see #TYPE_UNIFORM_SCALE
     * @since 1.2
     */
 double getDeterminant() {
 switch (state) {
 case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
 case (APPLY_SHEAR | APPLY_SCALE):
     return m00 * m11 - m01 * m10;
 case (APPLY_SHEAR | APPLY_TRANSLATE):
 case (APPLY_SHEAR):
     return -(m01 * m10);
 case (APPLY_SCALE | APPLY_TRANSLATE):
 case (APPLY_SCALE):
     return m00 * m11;
 case (APPLY_TRANSLATE):
 case (APPLY_IDENTITY):
     return 1.0;
 }
 return -1;
    }
    /**
     * Manually recalculates the state of the transform when the matrix
     * changes too much to predict the effects on the state.
     * The following table specifies what the various settings of the
     * state field say about the values of the corresponding matrix
     * element fields.
     * Note that the rules governing the SCALE fields are slightly
     * different depending on whether the SHEAR flag is also set.
     * <pre>
     *                     SCALE            SHEAR          TRANSLATE
     *                    m00/m11          m01/m10          m02/m12
     *
     * IDENTITY             1.0              0.0              0.0
     * TRANSLATE (TR)       1.0              0.0          not both 0.0
     * SCALE (SC)       not both 1.0         0.0              0.0
     * TR | SC          not both 1.0         0.0          not both 0.0
     * SHEAR (SH)           0.0          not both 0.0         0.0
     * TR | SH              0.0          not both 0.0     not both 0.0
     * SC | SH          not both 0.0     not both 0.0         0.0
     * TR | SC | SH     not both 0.0     not both 0.0     not both 0.0
     * </pre>
     */
    void updateState() {
 if (m01 == 0.0 && m10 == 0.0) {
     if (m00 == 1.0 && m11 == 1.0) {
  if (m02 == 0.0 && m12 == 0.0) {
      state = APPLY_IDENTITY;
      type = TYPE_IDENTITY;
  } else {
      state = APPLY_TRANSLATE;
      type = TYPE_TRANSLATION;
  }
     } else {
  if (m02 == 0.0 && m12 == 0.0) {
      state = APPLY_SCALE;
      type = TYPE_UNKNOWN;
  } else {
      state = (APPLY_SCALE | APPLY_TRANSLATE);
      type = TYPE_UNKNOWN;
  }
     }
 } else {
     if (m00 == 0.0 && m11 == 0.0) {
  if (m02 == 0.0 && m12 == 0.0) {
      state = APPLY_SHEAR;
      type = TYPE_UNKNOWN;
  } else {
      state = (APPLY_SHEAR | APPLY_TRANSLATE);
      type = TYPE_UNKNOWN;
  }
     } else {
  if (m02 == 0.0 && m12 == 0.0) {
      state = (APPLY_SHEAR | APPLY_SCALE);
      type = TYPE_UNKNOWN;
  } else {
      state = (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE);
      type = TYPE_UNKNOWN;
  }
     }
 }
    }
    /*
     * Convenience method used internally to throw exceptions when
     * a case was forgotten in a switch statement.
     */
 void stateError() {
 alert("Internal Error", "missing case in transform state switch");
    }
    
    /**
     * Retrieves the 6 specifiable values in the 3x3 affine transformation
     * matrix and places them into an array of double precisions values.
     * The values are stored in the array as 
     * {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;m02&nbsp;m12&nbsp;}.
     * An array of 4 doubles can also be specified, in which case only the
     * first four elements representing the non-transform
     * parts of the array are retrieved and the values are stored into 
     * the array as {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;}
     * @param flatmatrix the double array used to store the returned
     * values.
     * @see #getScaleX
     * @see #getScaleY
     * @see #getShearX
     * @see #getShearY
     * @see #getTranslateX
     * @see #getTranslateY
     * @since 1.2
     */
 double[] getMatrix(double[] flatmatrix) {
 flatmatrix[0] = m00;
 flatmatrix[1] = m10;
 flatmatrix[2] = m01;
 flatmatrix[3] = m11;
 if (flatmatrix.length > 5) {
     flatmatrix[4] = m02;
     flatmatrix[5] = m12;
 }
 return flatmatrix;
    }
    /**
     * Returns the X coordinate scaling element (m00) of the 3x3
     * affine transformation matrix.
     * @return a double value that is the X coordinate of the scaling
     *  element of the affine transformation matrix.
     * @see #getMatrix
     * @since 1.2
     */
 double getScaleX() {
 return m00;
    }
    /**
     * Returns the Y coordinate scaling element (m11) of the 3x3
     * affine transformation matrix.
     * @return a double value that is the Y coordinate of the scaling
     *  element of the affine transformation matrix.
     * @see #getMatrix
     * @since 1.2
     */
 double getScaleY() {
 return m11;
    }
    /**
     * Returns the X coordinate shearing element (m01) of the 3x3
     * affine transformation matrix.
     * @return a double value that is the X coordinate of the shearing
     *  element of the affine transformation matrix.
     * @see #getMatrix
     * @since 1.2
     */
 double getShearX() {
 return m01;
    }
    /**
     * Returns the Y coordinate shearing element (m10) of the 3x3
     * affine transformation matrix.
     * @return a double value that is the Y coordinate of the shearing
     *  element of the affine transformation matrix.
     * @see #getMatrix
     * @since 1.2
     */
 double getShearY() {
 return m10;
    }
    /**
     * Returns the X coordinate of the translation element (m02) of the
     * 3x3 affine transformation matrix.
     * @return a double value that is the X coordinate of the translation
     *  element of the affine transformation matrix.
     * @see #getMatrix
     * @since 1.2
     */
 double getTranslateX() {
 return m02;
    }
    /**
     * Returns the Y coordinate of the translation element (m12) of the
     * 3x3 affine transformation matrix.
     * @return a double value that is the Y coordinate of the translation
     *  element of the affine transformation matrix. 
     * @see #getMatrix
     * @since 1.2
     */
 double getTranslateY() {
 return m12;
    }
    /**
     * Concatenates this transform with a translation transformation.
     * This is equivalent to calling concatenate(T), where T is an
     * <code>AffineTransform</code> represented by the following matrix:
     * <pre>
     *  [   1    0    tx  ]
     *  [   0    1    ty  ]
     *  [   0    0    1   ]
     * </pre>
     * @param tx the distance by which coordinates are translated in the
     * X axis direction
     * @param ty the distance by which coordinates are translated in the
     * Y axis direction
     * @since 1.2
     */
 void translate(double tx, double ty) {
 switch (state) {
// default:
//     stateError();
//     /* NOTREACHED */
 case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
     m02 = tx * m00 + ty * m01 + m02;
     m12 = tx * m10 + ty * m11 + m12;
     if (m02 == 0.0 && m12 == 0.0) {
  state = APPLY_SHEAR | APPLY_SCALE;
  if (type != TYPE_UNKNOWN) {
      type -= TYPE_TRANSLATION;
  }
     }
     return;
 case (APPLY_SHEAR | APPLY_SCALE):
     m02 = tx * m00 + ty * m01;
     m12 = tx * m10 + ty * m11;
     if (m02 != 0.0 || m12 != 0.0) {
  state = APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE;
  type |= TYPE_TRANSLATION;
     }
     return;
 case (APPLY_SHEAR | APPLY_TRANSLATE):
     m02 = ty * m01 + m02;
     m12 = tx * m10 + m12;
     if (m02 == 0.0 && m12 == 0.0) {
  state = APPLY_SHEAR;
  if (type != TYPE_UNKNOWN) {
      type -= TYPE_TRANSLATION;
  }
     }
     return;
 case (APPLY_SHEAR):
     m02 = ty * m01;
     m12 = tx * m10;
     if (m02 != 0.0 || m12 != 0.0) {
  state = APPLY_SHEAR | APPLY_TRANSLATE;
  type |= TYPE_TRANSLATION;
     }
     return;
 case (APPLY_SCALE | APPLY_TRANSLATE):
     m02 = tx * m00 + m02;
     m12 = ty * m11 + m12;
     if (m02 == 0.0 && m12 == 0.0) {
  state = APPLY_SCALE;
  if (type != TYPE_UNKNOWN) {
      type -= TYPE_TRANSLATION;
  }
     }
     return;
 case (APPLY_SCALE):
     m02 = tx * m00;
     m12 = ty * m11;
     if (m02 != 0.0 || m12 != 0.0) {
  state = APPLY_SCALE | APPLY_TRANSLATE;
  type |= TYPE_TRANSLATION;
     }
     return;
 case (APPLY_TRANSLATE):
     m02 = tx + m02;
     m12 = ty + m12;
     if (m02 == 0.0 && m12 == 0.0) {
  state = APPLY_IDENTITY;
  type = TYPE_IDENTITY;
     }
     return;
 case (APPLY_IDENTITY):
     m02 = tx;
     m12 = ty;
     if (tx != 0.0 || ty != 0.0) {
  state = APPLY_TRANSLATE;
  type = TYPE_TRANSLATION;
     }
     return;
 }
    }
    // Utility methods to optimize rotate methods.
    // These tables translate the flags during predictable quadrant
    // rotations where the shear and scale values are swapped and negated.
 void rotate90() {
 double M0 = m00;
 m00 = m01;
 m01 = -M0;
 M0 = m10;
 m10 = m11;
 m11 = -M0;
 int state = rot90conversion[this.state];
 if ((state & (APPLY_SHEAR | APPLY_SCALE)) == APPLY_SCALE &&
     m00 == 1.0 && m11 == 1.0)
 {
     state -= APPLY_SCALE;
 }
 this.state = state;
 type = TYPE_UNKNOWN;
    }
  void rotate180() {
 m00 = -m00;
 m11 = -m11;
 int state = this.state;
 if ((state & (APPLY_SHEAR)) != 0) {
     // If there was a shear, then this rotation has no
     // effect on the state.
     m01 = -m01;
     m10 = -m10;
 } else {
     // No shear means the SCALE state may toggle when
     // m00 and m11 are negated.
     if (m00 == 1.0 && m11 == 1.0) {
  this.state = state & ~APPLY_SCALE;
     } else {
  this.state = state | APPLY_SCALE;
     }
 }
 type = TYPE_UNKNOWN;
    }
 void rotate270() {
 double M0 = m00;
 m00 = -m01;
 m01 = M0;
 M0 = m10;
 m10 = -m11;
 m11 = M0;
 int state = rot90conversion[this.state];
 if ((state & (APPLY_SHEAR | APPLY_SCALE)) == APPLY_SCALE &&
     m00 == 1.0 && m11 == 1.0)
 {
     state -= APPLY_SCALE;
 }
 this.state = state;
 type = TYPE_UNKNOWN;
    }
    /**
     * Concatenates this transform with a rotation transformation.
     * This is equivalent to calling concatenate(R), where R is an
     * <code>AffineTransform</code> represented by the following matrix:
     * <pre>
     *  [   cos(theta)    -sin(theta)    0   ]
     *  [   sin(theta)     cos(theta)    0   ]
     *  [       0              0         1   ]
     * </pre>
     * Rotating by a positive angle theta rotates points on the positive
     * X axis toward the positive Y axis.
     * Note also the discussion of
     * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
     * above.
     * @param theta the angle of rotation measured in radians
     * @since 1.2
     */
 void rotate(double theta) {
 double sinn = sin(theta);
 if (sinn == 1.0) {
     rotate90();
 } else if (sinn == -1.0) {
     rotate270();
 } else {
     double cose = cos(theta);
     if (cose == -1.0) {
  rotate180();
     } else if (cose != 1.0) {
  double M0, M1;
  M0 = m00;
  M1 = m01;
  m00 =  cose * M0 + sinn * M1;
  m01 = -sinn * M0 + cose * M1;
  M0 = m10;
  M1 = m11;
  m10 =  cose * M0 + sinn * M1;
  m11 = -sinn * M0 + cose * M1;
  updateState();
     }
 }
    }
    /**
     * Concatenates this transform with a transform that rotates
     * coordinates around an anchor point.
     * This operation is equivalent to translating the coordinates so
     * that the anchor point is at the origin (S1), then rotating them
     * about the new origin (S2), and finally translating so that the
     * intermediate origin is restored to the coordinates of the original
     * anchor point (S3).
     * <p>
     * This operation is equivalent to the following sequence of calls:
     * <pre>
     *     translate(anchorx, anchory);      // S3: final translation
     *     rotate(theta);                    // S2: rotate around anchor
     *     translate(-anchorx, -anchory);    // S1: translate anchor to origin
     * </pre>
     * Rotating by a positive angle theta rotates points on the positive
     * X axis toward the positive Y axis.
     * Note also the discussion of
     * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
     * above.
     *
     * @param theta the angle of rotation measured in radians
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
     * @since 1.2
     */
      void rotate(double theta, double anchorx, double anchory) {
 // REMIND: Simple for now - optimize later
 translate(anchorx, anchory);
 rotate(theta);
 translate(-anchorx, -anchory);
    }
    /**
     * Concatenates this transform with a transform that rotates
     * coordinates according to a rotation vector.
     * All coordinates rotate about the origin by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both <code>vecx</code> and <code>vecy</code> are 0.0,
     * no additional rotation is added to this transform.
     * This operation is equivalent to calling:
     * <pre>
     *          rotate(Math.atan2(vecy, vecx));
     * </pre>
     *
     * @param vecx the X coordinate of the rotation vector
     * @param vecy the Y coordinate of the rotation vector
     * @since 1.6
     */
      void rotate(double vecx, double vecy) {
 if (vecy == 0.0) {
     if (vecx < 0.0) {
  rotate180();
     }
     // If vecx > 0.0 - no rotation
     // If vecx == 0.0 - undefined rotation - treat as no rotation
 } else if (vecx == 0.0) {
     if (vecy > 0.0) {
  rotate90();
     } else {  // vecy must be < 0.0
  rotate270();
     }
 } else {
     double len = square_root(vecx * vecx + vecy * vecy);
     double sin1 = vecy / len;
     double cos1 = vecx / len;
     double M0, M1;
     M0 = m00;
     M1 = m01;
     m00 =  cos1 * M0 + sin1 * M1;
     m01 = -sin1 * M0 + cos1 * M1;
     M0 = m10;
     M1 = m11;
     m10 =  cos1 * M0 + sin1 * M1;
     m11 = -sin1 * M0 + cos1 * M1;
     updateState();
 }
    }
    /**
     * Concatenates this transform with a transform that rotates
     * coordinates around an anchor point according to a rotation
     * vector.
     * All coordinates rotate about the specified anchor coordinates
     * by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both <code>vecx</code> and <code>vecy</code> are 0.0,
     * the transform is not modified in any way.
     * This method is equivalent to calling:
     * <pre>
     *     rotate(Math.atan2(vecy, vecx), anchorx, anchory);
     * </pre>
     *
     * @param vecx the X coordinate of the rotation vector
     * @param vecy the Y coordinate of the rotation vector
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
     * @since 1.6
     */
      void rotate(double vecx, double vecy,
         double anchorx, double anchory)
    {
 // REMIND: Simple for now - optimize later
 translate(anchorx, anchory);
 rotate(vecx, vecy);
 translate(-anchorx, -anchory);
    }
    /**
     * Concatenates this transform with a transform that rotates
     * coordinates by the specified number of quadrants.
     * This is equivalent to calling:
     * <pre>
     *     rotate(numquadrants * Math.PI / 2.0);
     * </pre>
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     * @param numquadrants the number of 90 degree arcs to rotate by
     * @since 1.6
     */
      void quadrantRotate(int numquadrants) {
 switch (numquadrants & 3) {
 case 0:
     break;
 case 1:
     rotate90();
     break;
 case 2:
     rotate180();
     break;
 case 3:
     rotate270();
     break;
 }
    }
    /**
     * Concatenates this transform with a transform that rotates
     * coordinates by the specified number of quadrants around
     * the specified anchor point.
     * This method is equivalent to calling:
     * <pre>
     *     rotate(numquadrants * Math.PI / 2.0, anchorx, anchory);
     * </pre>
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     *
     * @param numquadrants the number of 90 degree arcs to rotate by
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
     * @since 1.6
     */
      void quadrantRotate(int numquadrants,
          double anchorx, double anchory)
    {
 switch (numquadrants & 3) {
 case 0:
     return;
 case 1:
     m02 += anchorx * (m00 - m01) + anchory * (m01 + m00);
     m12 += anchorx * (m10 - m11) + anchory * (m11 + m10);
     rotate90();
     break;
 case 2:
     m02 += anchorx * (m00 + m00) + anchory * (m01 + m01);
     m12 += anchorx * (m10 + m10) + anchory * (m11 + m11);
     rotate180();
     break;
 case 3:
     m02 += anchorx * (m00 + m01) + anchory * (m01 - m00);
     m12 += anchorx * (m10 + m11) + anchory * (m11 - m10);
     rotate270();
     break;
 }
 if (m02 == 0.0 && m12 == 0.0) {
     state &= ~APPLY_TRANSLATE;
 } else {
     state |= APPLY_TRANSLATE;
 }
    }
    /**
     * Concatenates this transform with a scaling transformation.
     * This is equivalent to calling concatenate(S), where S is an
     * <code>AffineTransform</code> represented by the following matrix:
     * <pre>
     *  [   sx   0    0   ]
     *  [   0    sy   0   ]
     *  [   0    0    1   ]
     * </pre>
     * @param sx the factor by which coordinates are scaled along the   
     * X axis direction
     * @param sy the factor by which coordinates are scaled along the
     * Y axis direction 
     * @since 1.2
     */
 void scale(double sx, double sy) {
 int state = this.state;
 switch (state) {
// default:
//     stateError();
//     /* NOTREACHED */
 case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
 case (APPLY_SHEAR | APPLY_SCALE):
     m00 *= sx;
     m11 *= sy;
     /* NOBREAK */
 case (APPLY_SHEAR | APPLY_TRANSLATE):
 case (APPLY_SHEAR):
     m01 *= sy;
     m10 *= sx;
     if (m01 == 0 && m10 == 0) {
  state &= APPLY_TRANSLATE;
  if (m00 == 1.0 && m11 == 1.0) {
      this.type = (state == APPLY_IDENTITY
     ? TYPE_IDENTITY
     : TYPE_TRANSLATION);
  } else {
      state |= APPLY_SCALE;
      this.type = TYPE_UNKNOWN;
  }
  this.state = state;
     }
     return;
 case (APPLY_SCALE | APPLY_TRANSLATE):
 case (APPLY_SCALE):
     m00 *= sx;
     m11 *= sy;
     if (m00 == 1.0 && m11 == 1.0) {
  this.state = (state &= APPLY_TRANSLATE);
  this.type = (state == APPLY_IDENTITY
        ? TYPE_IDENTITY
        : TYPE_TRANSLATION);
     } else {
  this.type = TYPE_UNKNOWN;
     }
     return;
 case (APPLY_TRANSLATE):
 case (APPLY_IDENTITY):
     m00 = sx;
     m11 = sy;
     if (sx != 1.0 || sy != 1.0) {
  this.state = state | APPLY_SCALE;
  this.type = TYPE_UNKNOWN;
     }
     return;
 }
    }
    /**
     * Concatenates this transform with a shearing transformation.
     * This is equivalent to calling concatenate(SH), where SH is an
     * <code>AffineTransform</code> represented by the following matrix:
     * <pre>
     *  [   1   shx   0   ]
     *  [  shy   1    0   ]
     *  [   0    0    1   ]
     * </pre>
     * @param shx the multiplier by which coordinates are shifted in the
     * direction of the positive X axis as a factor of their Y coordinate
     * @param shy the multiplier by which coordinates are shifted in the
     * direction of the positive Y axis as a factor of their X coordinate
     * @since 1.2
     */
      void shear(double shx, double shy) {
 int state = this.state;
 switch (state) {
// default:
//     stateError();
     /* NOTREACHED */
 case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
 case (APPLY_SHEAR | APPLY_SCALE): {
     double M0, M1;
     M0 = m00;
     M1 = m01;
     m00 = M0 + M1 * shy;
     m01 = M0 * shx + M1;
     M0 = m10;
     M1 = m11;
     m10 = M0 + M1 * shy;
     m11 = M0 * shx + M1;
     updateState();
     return;
}
 case (APPLY_SHEAR | APPLY_TRANSLATE):
 case (APPLY_SHEAR): {
     m00 = m01 * shy;
     m11 = m10 * shx;
     if (m00 != 0.0 || m11 != 0.0) {
  this.state = state | APPLY_SCALE;
     }
     this.type = TYPE_UNKNOWN;
     return;
}
 case (APPLY_SCALE | APPLY_TRANSLATE):
 case (APPLY_SCALE):
{
     m01 = m00 * shx;
     m10 = m11 * shy;
     if (m01 != 0.0 || m10 != 0.0) {
  this.state = state | APPLY_SHEAR;
     }
     this.type = TYPE_UNKNOWN;
     return;
}
 case (APPLY_TRANSLATE):
 case (APPLY_IDENTITY): {
     m01 = shx;
     m10 = shy;
     if (m01 != 0.0 || m10 != 0.0) {
  this.state = state | APPLY_SCALE | APPLY_SHEAR;
  this.type = TYPE_UNKNOWN;
     }
     return;}
 }
    }
    /**
     * Resets this transform to the Identity transform.
     * @since 1.2
     */
      void setToIdentity() {
 m00 = m11 = 1.0;
 m10 = m01 = m02 = m12 = 0.0;
 state = APPLY_IDENTITY;
 type = TYPE_IDENTITY;
    }
    /**
     * Sets this transform to a translation transformation.
     * The matrix representing this transform becomes:
     * <pre>
     *  [   1    0    tx  ]
     *  [   0    1    ty  ]
     *  [   0    0    1   ]
     * </pre>
     * @param tx the distance by which coordinates are translated in the
     * X axis direction
     * @param ty the distance by which coordinates are translated in the
     * Y axis direction
     * @since 1.2
     */
      void setToTranslation(double tx, double ty) {
 m00 = 1.0;
 m10 = 0.0;
 m01 = 0.0;
 m11 = 1.0;
 m02 = tx;
 m12 = ty;
 if (tx != 0.0 || ty != 0.0) {
     state = APPLY_TRANSLATE;
     type = TYPE_TRANSLATION;
 } else {
     state = APPLY_IDENTITY;
     type = TYPE_IDENTITY;
 }
    }
    /**
     * Sets this transform to a rotation transformation.
     * The matrix representing this transform becomes:
     * <pre>
     *  [   cos(theta)    -sin(theta)    0   ]
     *  [   sin(theta)     cos(theta)    0   ]
     *  [       0              0         1   ]
     * </pre>
     * Rotating by a positive angle theta rotates points on the positive
     * X axis toward the positive Y axis.
     * Note also the discussion of
     * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
     * above.
     * @param theta the angle of rotation measured in radians
     * @since 1.2
     */
      void setToRotation(double theta) {
 double sin1 = sin(theta);
 double cos1;
 if (sin1 == 1.0 || sin1 == -1.0) {
     cos1 = 0.0;
     state = APPLY_SHEAR;
     type = TYPE_QUADRANT_ROTATION;
 } else {
     cos1 = cos(theta);
     if (cos1 == -1.0) {
  sin1 = 0.0;
  state = APPLY_SCALE;
  type = TYPE_QUADRANT_ROTATION;
     } else if (cos1 == 1.0) {
  sin1 = 0.0;
  state = APPLY_IDENTITY;
  type = TYPE_IDENTITY;
     } else {
  state = APPLY_SHEAR | APPLY_SCALE;
  type = TYPE_GENERAL_ROTATION;
     }
 }
 m00 =  cos1;
 m10 =  sin1;
 m01 = -sin1;
 m11 =  cos1;
 m02 =  0.0;
 m12 =  0.0;
    }
    /**
     * Sets this transform to a translated rotation transformation.
     * This operation is equivalent to translating the coordinates so
     * that the anchor point is at the origin (S1), then rotating them
     * about the new origin (S2), and finally translating so that the
     * intermediate origin is restored to the coordinates of the original
     * anchor point (S3).
     * <p>
     * This operation is equivalent to the following sequence of calls:
     * <pre>
     *     setToTranslation(anchorx, anchory); // S3: final translation
     *     rotate(theta);                      // S2: rotate around anchor
     *     translate(-anchorx, -anchory);      // S1: translate anchor to origin
     * </pre>
     * The matrix representing this transform becomes:
     * <pre>
     *  [   cos(theta)    -sin(theta)    x-x*cos+y*sin1 ]
     *  [   sin(theta)     cos(theta)    y-x*sin-y*cos1  ]
     *  [       0              0               1        ]
     * </pre>
     * Rotating by a positive angle theta rotates points on the positive
     * X axis toward the positive Y axis.
     * Note also the discussion of
     * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
     * above.
     *
     * @param theta the angle of rotation measured in radians
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
     * @since 1.2
     */
      void setToRotation(double theta, double anchorx, double anchory) {
 setToRotation(theta);
 double sin1= m10;
 double oneMinuscos1 = 1.0 - m00;
 m02 = anchorx * oneMinuscos1 + anchory * sin1;
 m12 = anchory * oneMinuscos1 - anchorx * sin1;
 if (m02 != 0.0 || m12 != 0.0) {
     state |= APPLY_TRANSLATE;
     type |= TYPE_TRANSLATION;
 }
    }
    /**
     * Sets this transform to a rotation transformation that rotates
     * coordinates according to a rotation vector.
     * All coordinates rotate about the origin by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both <code>vecx</code> and <code>vecy</code> are 0.0,
     * the transform is set to an identity transform.
     * This operation is equivalent to calling:
     * <pre>
     *     setToRotation(Math.atan2(vecy, vecx));
     * </pre>
     *
     * @param vecx the X coordinate of the rotation vector
     * @param vecy the Y coordinate of the rotation vector
     * @since 1.6
     */
      void setToRotation(double vecx, double vecy) {
 double sin1; double cos1;
 if (vecy == 0) {
     sin1= 0.0;
     if (vecx < 0.0) {
  cos1 = -1.0;
  state = APPLY_SCALE;
  type = TYPE_QUADRANT_ROTATION;
     } else {
  cos1 = 1.0;
  state = APPLY_IDENTITY;
  type = TYPE_IDENTITY;
     }
 } else if (vecx == 0) {
     cos1 = 0.0;
     sin1= (vecy > 0.0) ? 1.0 : -1.0;
     state = APPLY_SHEAR;
     type = TYPE_QUADRANT_ROTATION;
 } else {
     double len = square_root(vecx * vecx + vecy * vecy);
     cos1 = vecx / len;
     sin1= vecy / len;
     state = APPLY_SHEAR | APPLY_SCALE;
     type = TYPE_GENERAL_ROTATION;
 }
 m00 =  cos1;
 m10 =  sin1;
 m01 = -sin1;
 m11 =  cos1;
 m02 =  0.0;
 m12 =  0.0;
    }
    /**
     * Sets this transform to a rotation transformation that rotates
     * coordinates around an anchor point according to a rotation
     * vector.
     * All coordinates rotate about the specified anchor coordinates
     * by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both <code>vecx</code> and <code>vecy</code> are 0.0,
     * the transform is set to an identity transform.
     * This operation is equivalent to calling:
     * <pre>
     *     setToTranslation(Math.atan2(vecy, vecx), anchorx, anchory);
     * </pre>
     *
     * @param vecx the X coordinate of the rotation vector
     * @param vecy the Y coordinate of the rotation vector
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
     * @since 1.6
     */
      void setToRotation(double vecx, double vecy,
         double anchorx, double anchory)
    {
 setToRotation(vecx, vecy);
 double sin1= m10;
 double oneMinuscos1 = 1.0 - m00;
 m02 = anchorx * oneMinuscos1 + anchory * sin1;
 m12 = anchory * oneMinuscos1 - anchorx * sin1;
 if (m02 != 0.0 || m12 != 0.0) {
     state |= APPLY_TRANSLATE;
     type |= TYPE_TRANSLATION;
 }
    }
    /**
     * Sets this transform to a rotation transformation that rotates
     * coordinates by the specified number of quadrants.
     * This operation is equivalent to calling:
     * <pre>
     *     setToRotation(numquadrants * Math.PI / 2.0);
     * </pre>
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     * @param numquadrants the number of 90 degree arcs to rotate by
     * @since 1.6
     */
      void setToQuadrantRotation(int numquadrants) {
 switch (numquadrants & 3) {
 case 0:
     m00 =  1.0;
     m10 =  0.0;
     m01 =  0.0;
     m11 =  1.0;
     m02 =  0.0;
     m12 =  0.0;
     state = APPLY_IDENTITY;
     type = TYPE_IDENTITY;
     break;
 case 1:
     m00 =  0.0;
     m10 =  1.0;
     m01 = -1.0;
     m11 =  0.0;
     m02 =  0.0;
     m12 =  0.0;
     state = APPLY_SHEAR;
     type = TYPE_QUADRANT_ROTATION;
     break;
 case 2:
     m00 = -1.0;
     m10 =  0.0;
     m01 =  0.0;
     m11 = -1.0;
     m02 =  0.0;
     m12 =  0.0;
     state = APPLY_SCALE;
     type = TYPE_QUADRANT_ROTATION;
     break;
 case 3:
     m00 =  0.0;
     m10 = -1.0;
     m01 =  1.0;
     m11 =  0.0;
     m02 =  0.0;
     m12 =  0.0;
     state = APPLY_SHEAR;
     type = TYPE_QUADRANT_ROTATION;
     break;
 }
    }
    /**
     * Sets this transform to a translated rotation transformation
     * that rotates coordinates by the specified number of quadrants
     * around the specified anchor point.
     * This operation is equivalent to calling:
     * <pre>
     *     setToRotation(numquadrants * Math.PI / 2.0, anchorx, anchory);
     * </pre>
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     *
     * @param numquadrants the number of 90 degree arcs to rotate by
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
     * @since 1.6
     */
      void setToQuadrantRotation(int numquadrants,
          double anchorx, double anchory)
    {
 switch (numquadrants & 3) {
 case 0:
     m00 =  1.0;
     m10 =  0.0;
     m01 =  0.0;
     m11 =  1.0;
     m02 =  0.0;
     m12 =  0.0;
     state = APPLY_IDENTITY;
     type = TYPE_IDENTITY;
     break;
 case 1:
     m00 =  0.0;
     m10 =  1.0;
     m01 = -1.0;
     m11 =  0.0;
     m02 =  anchorx + anchory;
     m12 =  anchory - anchorx;
     if (m02 == 0.0 && m12 == 0.0) {
  state = APPLY_SHEAR;
  type = TYPE_QUADRANT_ROTATION;
     } else {
  state = APPLY_SHEAR | APPLY_TRANSLATE;
  type = TYPE_QUADRANT_ROTATION | TYPE_TRANSLATION;
     }
     break;
 case 2:
     m00 = -1.0;
     m10 =  0.0;
     m01 =  0.0;
     m11 = -1.0;
     m02 =  anchorx + anchorx;
     m12 =  anchory + anchory;
     if (m02 == 0.0 && m12 == 0.0) {
  state = APPLY_SCALE;
  type = TYPE_QUADRANT_ROTATION;
     } else {
  state = APPLY_SCALE | APPLY_TRANSLATE;
  type = TYPE_QUADRANT_ROTATION | TYPE_TRANSLATION;
     }
     break;
 case 3:
     m00 =  0.0;
     m10 = -1.0;
     m01 =  1.0;
     m11 =  0.0;
     m02 =  anchorx - anchory;
     m12 =  anchory + anchorx;
     if (m02 == 0.0 && m12 == 0.0) {
  state = APPLY_SHEAR;
  type = TYPE_QUADRANT_ROTATION;
     } else {
  state = APPLY_SHEAR | APPLY_TRANSLATE;
  type = TYPE_QUADRANT_ROTATION | TYPE_TRANSLATION;
     }
     break;
 }
    }
    /**
     * Sets this transform to a scaling transformation.
     * The matrix representing this transform becomes:
     * <pre>
     *  [   sx   0    0   ]
     *  [   0    sy   0   ]
     *  [   0    0    1   ]
     * </pre>
     * @param sx the factor by which coordinates are scaled along the
     * X axis direction
     * @param sy the factor by which coordinates are scaled along the
     * Y axis direction
     * @since 1.2
     */
      void setToScale(double sx, double sy) {
 m00 = sx;
 m10 = 0.0;
 m01 = 0.0;
 m11 = sy;
 m02 = 0.0;
 m12 = 0.0;
 if (sx != 1.0 || sy != 1.0) {
     state = APPLY_SCALE;
     type = TYPE_UNKNOWN;
 } else {
     state = APPLY_IDENTITY;
     type = TYPE_IDENTITY;
 }
    }
    /**
     * Sets this transform to a shearing transformation.
     * The matrix representing this transform becomes:
     * <pre>
     *  [   1   shx   0   ]
     *  [  shy   1    0   ]
     *  [   0    0    1   ]
     * </pre>
     * @param shx the multiplier by which coordinates are shifted in the
     * direction of the positive X axis as a factor of their Y coordinate
     * @param shy the multiplier by which coordinates are shifted in the
     * direction of the positive Y axis as a factor of their X coordinate
     * @since 1.2
     */
      void setToShear(double shx, double shy) {
 m00 = 1.0;
 m01 = shx;
 m10 = shy;
 m11 = 1.0;
 m02 = 0.0;
 m12 = 0.0;
 if (shx != 0.0 || shy != 0.0) {
     state = (APPLY_SHEAR | APPLY_SCALE);
     type = TYPE_UNKNOWN;
 } else {
     state = APPLY_IDENTITY;
     type = TYPE_IDENTITY;
 }
    }
    /**
     * Sets this transform to a copy of the transform in the specified
     * <code>AffineTransform</code> object.
     * @param Tx the <code>AffineTransform</code> object from which to
     * copy the transform
     * @since 1.2
     */
      void setTransform(AffineTransform Tx) {
 this.m00 = Tx.m00;
 this.m10 = Tx.m10;
 this.m01 = Tx.m01;
 this.m11 = Tx.m11;
 this.m02 = Tx.m02;
 this.m12 = Tx.m12;
 this.state = Tx.state;
 this.type = Tx.type;
    }
    /**
     * Sets this transform to the matrix specified by the 6
     * double precision values.
     *
     * @param m00 the X coordinate scaling element of the 3x3 matrix
     * @param m10 the Y coordinate shearing element of the 3x3 matrix
     * @param m01 the X coordinate shearing element of the 3x3 matrix
     * @param m11 the Y coordinate scaling element of the 3x3 matrix
     * @param m02 the X coordinate translation element of the 3x3 matrix
     * @param m12 the Y coordinate translation element of the 3x3 matrix
     * @since 1.2
     */
      void setTransform(double m00, double m10,
        double m01, double m11,
        double m02, double m12) {
 this.m00 = m00;
 this.m10 = m10;
 this.m01 = m01;
 this.m11 = m11;
 this.m02 = m02;
 this.m12 = m12;
 updateState();
    }
    /**
     * Concatenates an <code>AffineTransform</code> <code>Tx</code> to
     * this <code>AffineTransform</code> Cx in the most commonly useful
     * way to provide a new user space
     * that is mapped to the former user space by <code>Tx</code>.
     * Cx is updated to perform the combined transformation.
     * Transforming a point p by the updated transform Cx' is
     * equivalent to first transforming p by <code>Tx</code> and then
     * transforming the result by the original transform Cx like this:
     * Cx'(p) = Cx(Tx(p))  
     * In matrix notation, if this transform Cx is
     * represented by the matrix [this] and <code>Tx</code> is represented
     * by the matrix [Tx] then this method does the following:
     * <pre>
     *  [this] = [this] x [Tx]
     * </pre>
     * @param Tx the <code>AffineTransform</code> object to be
     * concatenated with this <code>AffineTransform</code> object.
     * @see #preConcatenate
     * @since 1.2
     */
      void concatenate(AffineTransform Tx) {
        double M0, M1;
 double T00, T01, T10, T11;
 double T02, T12;
 int mystate = state;
 int txstate = Tx.state;
 switch ((txstate << HI_SHIFT) | mystate) {
     /* ---------- Tx == IDENTITY cases ---------- */
 case (HI_IDENTITY | APPLY_IDENTITY):
 case (HI_IDENTITY | APPLY_TRANSLATE):
 case (HI_IDENTITY | APPLY_SCALE):
 case (HI_IDENTITY | APPLY_SCALE | APPLY_TRANSLATE):
 case (HI_IDENTITY | APPLY_SHEAR):
 case (HI_IDENTITY | APPLY_SHEAR | APPLY_TRANSLATE):
 case (HI_IDENTITY | APPLY_SHEAR | APPLY_SCALE):
 case (HI_IDENTITY | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
     return;
     /* ---------- this == IDENTITY cases ---------- */
 case (HI_SHEAR | HI_SCALE | HI_TRANSLATE | APPLY_IDENTITY):
     m01 = Tx.m01;
     m10 = Tx.m10;
     /* NOBREAK */
 case (HI_SCALE | HI_TRANSLATE | APPLY_IDENTITY):
     m00 = Tx.m00;
     m11 = Tx.m11;
     /* NOBREAK */
 case (HI_TRANSLATE | APPLY_IDENTITY):
     m02 = Tx.m02;
     m12 = Tx.m12;
     state = txstate;
     type = Tx.type;
     return;
 case (HI_SHEAR | HI_SCALE | APPLY_IDENTITY):
     m01 = Tx.m01;
     m10 = Tx.m10;
     /* NOBREAK */
 case (HI_SCALE | APPLY_IDENTITY):
     m00 = Tx.m00;
     m11 = Tx.m11;
     state = txstate;
     type = Tx.type;
     return;
 case (HI_SHEAR | HI_TRANSLATE | APPLY_IDENTITY):
     m02 = Tx.m02;
     m12 = Tx.m12;
     /* NOBREAK */
 case (HI_SHEAR | APPLY_IDENTITY):
     m01 = Tx.m01;
     m10 = Tx.m10;
            m00 = m11 = 0.0;
     state = txstate;
     type = Tx.type;
     return;
     /* ---------- Tx == TRANSLATE cases ---------- */
 case (HI_TRANSLATE | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
 case (HI_TRANSLATE | APPLY_SHEAR | APPLY_SCALE):
 case (HI_TRANSLATE | APPLY_SHEAR | APPLY_TRANSLATE):
 case (HI_TRANSLATE | APPLY_SHEAR):
 case (HI_TRANSLATE | APPLY_SCALE | APPLY_TRANSLATE):
 case (HI_TRANSLATE | APPLY_SCALE):
 case (HI_TRANSLATE | APPLY_TRANSLATE):
     translate(Tx.m02, Tx.m12);
     return;
     /* ---------- Tx == SCALE cases ---------- */
 case (HI_SCALE | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
 case (HI_SCALE | APPLY_SHEAR | APPLY_SCALE):
 case (HI_SCALE | APPLY_SHEAR | APPLY_TRANSLATE):
 case (HI_SCALE | APPLY_SHEAR):
 case (HI_SCALE | APPLY_SCALE | APPLY_TRANSLATE):
 case (HI_SCALE | APPLY_SCALE):
 case (HI_SCALE | APPLY_TRANSLATE):
     scale(Tx.m00, Tx.m11);
     return;
     /* ---------- Tx == SHEAR cases ---------- */
 case (HI_SHEAR | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
 case (HI_SHEAR | APPLY_SHEAR | APPLY_SCALE):
     T01 = Tx.m01; T10 = Tx.m10;
     M0 = m00;
     m00 = m01 * T10;
     m01 = M0 * T01;
     M0 = m10;
     m10 = m11 * T10;
     m11 = M0 * T01;
     type = TYPE_UNKNOWN;
     return;
 case (HI_SHEAR | APPLY_SHEAR | APPLY_TRANSLATE):
 case (HI_SHEAR | APPLY_SHEAR):
     m00 = m01 * Tx.m10;
     m01 = 0.0;
     m11 = m10 * Tx.m01;
     m10 = 0.0;
     state = mystate ^ (APPLY_SHEAR | APPLY_SCALE);
     type = TYPE_UNKNOWN;
     return;
 case (HI_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
 case (HI_SHEAR | APPLY_SCALE):
     m01 = m00 * Tx.m01;
     m00 = 0.0;
     m10 = m11 * Tx.m10;
     m11 = 0.0;
     state = mystate ^ (APPLY_SHEAR | APPLY_SCALE);
     type = TYPE_UNKNOWN;
     return;
 case (HI_SHEAR | APPLY_TRANSLATE):
     m00 = 0.0;
     m01 = Tx.m01;
     m10 = Tx.m10;
     m11 = 0.0;
     state = APPLY_TRANSLATE | APPLY_SHEAR;
     type = TYPE_UNKNOWN;
     return;
 }
 // If Tx has more than one attribute, it is not worth optimizing
 // all of those cases...
 T00 = Tx.m00; T01 = Tx.m01; T02 = Tx.m02;
 T10 = Tx.m10; T11 = Tx.m11; T12 = Tx.m12;
 switch (mystate) {
// default:
//     stateError();
     /* NOTREACHED */
 case (APPLY_SHEAR | APPLY_SCALE):
     state = mystate | txstate;
     /* NOBREAK */
 case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
     M0 = m00;
     M1 = m01;
     m00  = T00 * M0 + T10 * M1;
     m01  = T01 * M0 + T11 * M1;
     m02 += T02 * M0 + T12 * M1;
     M0 = m10;
     M1 = m11;
     m10  = T00 * M0 + T10 * M1;
     m11  = T01 * M0 + T11 * M1;
     m12 += T02 * M0 + T12 * M1;
     type = TYPE_UNKNOWN;
     return;
 case (APPLY_SHEAR | APPLY_TRANSLATE):
 case (APPLY_SHEAR):
     M0 = m01;
     m00  = T10 * M0;
     m01  = T11 * M0;
     m02 += T12 * M0;
     M0 = m10;
     m10  = T00 * M0;
     m11  = T01 * M0;
     m12 += T02 * M0;
     break;
 case (APPLY_SCALE | APPLY_TRANSLATE):
 case (APPLY_SCALE):
     M0 = m00;
     m00  = T00 * M0;
     m01  = T01 * M0;
     m02 += T02 * M0;
     M0 = m11;
     m10  = T10 * M0;
     m11  = T11 * M0;
     m12 += T12 * M0;
     break;
 case (APPLY_TRANSLATE):
     m00  = T00;
     m01  = T01;
     m02 += T02;
     m10  = T10;
     m11  = T11;
     m12 += T12;
     state = txstate | APPLY_TRANSLATE;
     type = TYPE_UNKNOWN;
     return;
 }
 updateState();
    }
    /**
     * Concatenates an <code>AffineTransform</code> <code>Tx</code> to
     * this <code>AffineTransform</code> Cx
     * in a less commonly used way such that <code>Tx</code> modifies the
     * coordinate transformation relative to the absolute pixel
     * space rather than relative to the existing user space.
     * Cx is updated to perform the combined transformation.
     * Transforming a point p by the updated transform Cx' is
     * equivalent to first transforming p by the original transform
     * Cx and then transforming the result by 
     * <code>Tx</code> like this: 
     * Cx'(p) = Tx(Cx(p))  
     * In matrix notation, if this transform Cx
     * is represented by the matrix [this] and <code>Tx</code> is
     * represented by the matrix [Tx] then this method does the
     * following:
     * <pre>
     *  [this] = [Tx] x [this]
     * </pre>
     * @param Tx the <code>AffineTransform</code> object to be
     * concatenated with this <code>AffineTransform</code> object.
     * @see #concatenate
     * @since 1.2
     */
      void preConcatenate(AffineTransform Tx) {
 double M0, M1;
 double T00, T01, T10, T11;
 double T02, T12;
 int mystate = state;
 int txstate = Tx.state;
 switch ((txstate << HI_SHIFT) | mystate) {
 case (HI_IDENTITY | APPLY_IDENTITY):
 case (HI_IDENTITY | APPLY_TRANSLATE):
 case (HI_IDENTITY | APPLY_SCALE):
 case (HI_IDENTITY | APPLY_SCALE | APPLY_TRANSLATE):
 case (HI_IDENTITY | APPLY_SHEAR):
 case (HI_IDENTITY | APPLY_SHEAR | APPLY_TRANSLATE):
 case (HI_IDENTITY | APPLY_SHEAR | APPLY_SCALE):
 case (HI_IDENTITY | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
     // Tx is IDENTITY...
     return;
 case (HI_TRANSLATE | APPLY_IDENTITY):
 case (HI_TRANSLATE | APPLY_SCALE):
 case (HI_TRANSLATE | APPLY_SHEAR):
 case (HI_TRANSLATE | APPLY_SHEAR | APPLY_SCALE):
     // Tx is TRANSLATE, this has no TRANSLATE
     m02 = Tx.m02;
     m12 = Tx.m12;
     state = mystate | APPLY_TRANSLATE;
     type |= TYPE_TRANSLATION;
     return;
 case (HI_TRANSLATE | APPLY_TRANSLATE):
 case (HI_TRANSLATE | APPLY_SCALE | APPLY_TRANSLATE):
 case (HI_TRANSLATE | APPLY_SHEAR | APPLY_TRANSLATE):
 case (HI_TRANSLATE | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
     // Tx is TRANSLATE, this has one too
     m02 = m02 + Tx.m02;
     m12 = m12 + Tx.m12;
     return;
 case (HI_SCALE | APPLY_TRANSLATE):
 case (HI_SCALE | APPLY_IDENTITY):
     // Only these two existing states need a new state
     state = mystate | APPLY_SCALE;
     /* NOBREAK */
 case (HI_SCALE | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
 case (HI_SCALE | APPLY_SHEAR | APPLY_SCALE):
 case (HI_SCALE | APPLY_SHEAR | APPLY_TRANSLATE):
 case (HI_SCALE | APPLY_SHEAR):
 case (HI_SCALE | APPLY_SCALE | APPLY_TRANSLATE):
 case (HI_SCALE | APPLY_SCALE):
     // Tx is SCALE, this is anything
     T00 = Tx.m00;
     T11 = Tx.m11;
     if ((mystate & APPLY_SHEAR) != 0) {
  m01 = m01 * T00;
  m10 = m10 * T11;
  if ((mystate & APPLY_SCALE) != 0) {
      m00 = m00 * T00;
      m11 = m11 * T11;
  }
     } else {
  m00 = m00 * T00;
  m11 = m11 * T11;
     }
     if ((mystate & APPLY_TRANSLATE) != 0) {
  m02 = m02 * T00;
  m12 = m12 * T11;
     }
     type = TYPE_UNKNOWN;
     return;
 case (HI_SHEAR | APPLY_SHEAR | APPLY_TRANSLATE):
 case (HI_SHEAR | APPLY_SHEAR):
     mystate = mystate | APPLY_SCALE;
     /* NOBREAK */
 case (HI_SHEAR | APPLY_TRANSLATE):
 case (HI_SHEAR | APPLY_IDENTITY):
 case (HI_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
 case (HI_SHEAR | APPLY_SCALE):
     state = mystate ^ APPLY_SHEAR;
     /* NOBREAK */
 case (HI_SHEAR | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
 case (HI_SHEAR | APPLY_SHEAR | APPLY_SCALE):
     // Tx is SHEAR, this is anything
     T01 = Tx.m01;
     T10 = Tx.m10;
     M0 = m00;
     m00 = m10 * T01;
     m10 = M0 * T10;
     M0 = m01;
     m01 = m11 * T01;
     m11 = M0 * T10;
     M0 = m02;
     m02 = m12 * T01;
     m12 = M0 * T10;
     type = TYPE_UNKNOWN;
     return;
 }
 // If Tx has more than one attribute, it is not worth optimizing
 // all of those cases...
 T00 = Tx.m00; T01 = Tx.m01; T02 = Tx.m02;
 T10 = Tx.m10; T11 = Tx.m11; T12 = Tx.m12;
 switch (mystate) {
// default:
//     stateError();
     /* NOTREACHED */
 case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
     M0 = m02;
     M1 = m12;
     T02 += M0 * T00 + M1 * T01;
     T12 += M0 * T10 + M1 * T11;
     /* NOBREAK */
 case (APPLY_SHEAR | APPLY_SCALE):
     m02 = T02;
     m12 = T12;
     M0 = m00;
     M1 = m10;
     m00 = M0 * T00 + M1 * T01;
     m10 = M0 * T10 + M1 * T11;
     M0 = m01;
     M1 = m11;
     m01 = M0 * T00 + M1 * T01;
     m11 = M0 * T10 + M1 * T11;
     break;
 case (APPLY_SHEAR | APPLY_TRANSLATE):
     M0 = m02;
     M1 = m12;
     T02 += M0 * T00 + M1 * T01;
     T12 += M0 * T10 + M1 * T11;
     /* NOBREAK */
 case (APPLY_SHEAR):
     m02 = T02;
     m12 = T12;
     M0 = m10;
     m00 = M0 * T01;
     m10 = M0 * T11;
     M0 = m01;
     m01 = M0 * T00;
     m11 = M0 * T10;
     break;
 case (APPLY_SCALE | APPLY_TRANSLATE):
     M0 = m02;
     M1 = m12;
     T02 += M0 * T00 + M1 * T01;
     T12 += M0 * T10 + M1 * T11;
     /* NOBREAK */
 case (APPLY_SCALE):
     m02 = T02;
     m12 = T12;
     M0 = m00;
     m00 = M0 * T00;
     m10 = M0 * T10;
     M0 = m11;
     m01 = M0 * T01;
     m11 = M0 * T11;
     break;
 case (APPLY_TRANSLATE):
     M0 = m02;
     M1 = m12;
     T02 += M0 * T00 + M1 * T01;
     T12 += M0 * T10 + M1 * T11;
     /* NOBREAK */
 case (APPLY_IDENTITY):
     m02 = T02;
     m12 = T12;
     m00 = T00;
     m10 = T10;
     m01 = T01;
     m11 = T11;
     state = mystate | txstate;
     type = TYPE_UNKNOWN;
     return;
 }
 updateState();
    }
    /**
     * Returns an <code>AffineTransform</code> object representing the
     * inverse transformation.
     * The inverse transform Tx' of this transform Tx 
     * maps coordinates transformed by Tx back
     * to their original coordinates.
     * In other words, Tx'(Tx(p)) = p = Tx(Tx'(p)).
     * <p>
     * If this transform maps all coordinates onto a point or a line
     * then it will not have an inverse, since coordinates that do
     * not lie on the destination point or line will not have an inverse
     * mapping.
     * The <code>getDeterminant</code> method can be used to determine if this
     * transform has no inverse, in which case an exception will be
     * thrown if the <code>createInverse</code> method is called.
     * @return a new <code>AffineTransform</code> object representing the
     * inverse transformation.
     * @see #getDeterminant
     * @exception NoninvertibleTransformException
     * if the matrix cannot be inverted.
     * @since 1.2
     */
      AffineTransform@ createInverse()
    {
 double det;
 switch (state) {
// default:
//     stateError();
     /* NOTREACHED */
 case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
     det = m00 * m11 - m01 * m10;
     if (Math_abs(det) <= MIN_VALUE) {
 return null;
     }
     return newAffineTransform( m11 / det, -m10 / det,
           -m01 / det,  m00 / det,
           (m01 * m12 - m11 * m02) / det,
           (m10 * m02 - m00 * m12) / det,
           (APPLY_SHEAR |
     APPLY_SCALE |
     APPLY_TRANSLATE));
 case (APPLY_SHEAR | APPLY_SCALE):
     det = m00 * m11 - m01 * m10;
     if (Math_abs(det) <= MIN_VALUE) {
 return null;
     }
     return newAffineTransform( m11 / det, -m10 / det,
           -m01 / det,  m00 / det,
            0.0,        0.0,
           (APPLY_SHEAR | APPLY_SCALE));
 case (APPLY_SHEAR | APPLY_TRANSLATE):
     if (m01 == 0.0 || m10 == 0.0) {
 return null;
     }
     return newAffineTransform( 0.0,        1.0 / m01,
            1.0 / m10,  0.0,
           -m12 / m10, -m02 / m01,
           (APPLY_SHEAR | APPLY_TRANSLATE));
 case (APPLY_SHEAR):
     if (m01 == 0.0 || m10 == 0.0) {
 return null;
     }
     return newAffineTransform(0.0,       1.0 / m01,
           1.0 / m10, 0.0,
           0.0,       0.0,
           (APPLY_SHEAR));
 case (APPLY_SCALE | APPLY_TRANSLATE):
     if (m00 == 0.0 || m11 == 0.0) {
 return null;
     }
     return newAffineTransform( 1.0 / m00,  0.0,
            0.0,        1.0 / m11,
           -m02 / m00, -m12 / m11,
           (APPLY_SCALE | APPLY_TRANSLATE));
 case (APPLY_SCALE):
     if (m00 == 0.0 || m11 == 0.0) {
 return null;
     }
     return newAffineTransform(1.0 / m00, 0.0,
           0.0,       1.0 / m11,
           0.0,       0.0,
           (APPLY_SCALE));
 case (APPLY_TRANSLATE):
     return newAffineTransform( 1.0,  0.0,
            0.0,  1.0,
           -m02, -m12,
           (APPLY_TRANSLATE));
 case (APPLY_IDENTITY):
     return newAffineTransform();
 }
 /* NOTREACHED */
 return newAffineTransform();
    }
    /**
     * Sets this transform to the inverse of itself.
     * The inverse transform Tx' of this transform Tx 
     * maps coordinates transformed by Tx back
     * to their original coordinates.
     * In other words, Tx'(Tx(p)) = p = Tx(Tx'(p)).
     * <p>
     * If this transform maps all coordinates onto a point or a line
     * then it will not have an inverse, since coordinates that do
     * not lie on the destination point or line will not have an inverse
     * mapping.
     * The <code>getDeterminant</code> method can be used to determine if this
     * transform has no inverse, in which case an exception will be
     * thrown if the <code>invert</code> method is called.
     * @see #getDeterminant
     * @exception NoninvertibleTransformException
     * if the matrix cannot be inverted.
     * @since 1.6
     */
      void invert()
    {
 double M00, M01, M02;
 double M10, M11, M12;
 double det;
 switch (state) {
// default:
//     stateError();
     /* NOTREACHED */
 case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
     M00 = m00; M01 = m01; M02 = m02;
     M10 = m10; M11 = m11; M12 = m12;
     det = M00 * M11 - M01 * M10;
     if (Math_abs(det) <= MIN_VALUE) {
 return;
     }
     m00 =  M11 / det;
     m10 = -M10 / det;
     m01 = -M01 / det;
     m11 =  M00 / det;
     m02 = (M01 * M12 - M11 * M02) / det;
     m12 = (M10 * M02 - M00 * M12) / det;
     break;
 case (APPLY_SHEAR | APPLY_SCALE):
     M00 = m00; M01 = m01;
     M10 = m10; M11 = m11;
     det = M00 * M11 - M01 * M10;
     if (abs(det) <= MIN_VALUE) {
 return;
     }
     m00 =  M11 / det;
     m10 = -M10 / det;
     m01 = -M01 / det;
     m11 =  M00 / det;
     // m02 = 0.0;
     // m12 = 0.0;
     break;
 case (APPLY_SHEAR | APPLY_TRANSLATE):
     M01 = m01; M02 = m02;
     M10 = m10; M12 = m12;
     if (M01 == 0.0 || M10 == 0.0) {
 return;
     }
     // m00 = 0.0;
     m10 = 1.0 / M01;
     m01 = 1.0 / M10;
     // m11 = 0.0;
     m02 = -M12 / M10;
     m12 = -M02 / M01;
     break;
 case (APPLY_SHEAR):
     M01 = m01;
     M10 = m10;
     if (M01 == 0.0 || M10 == 0.0) {
  thrownewNoninvertibleTransformException("Determinant is 0");
     }
     // m00 = 0.0;
     m10 = 1.0 / M01;
     m01 = 1.0 / M10;
     // m11 = 0.0;
     // m02 = 0.0;
     // m12 = 0.0;
     break;
 case (APPLY_SCALE | APPLY_TRANSLATE):
     M00 = m00; M02 = m02;
     M11 = m11; M12 = m12;
     if (M00 == 0.0 || M11 == 0.0) {
  thrownewNoninvertibleTransformException("Determinant is 0");
     }
     m00 = 1.0 / M00;
     // m10 = 0.0;
     // m01 = 0.0;
     m11 = 1.0 / M11;
     m02 = -M02 / M00;
     m12 = -M12 / M11;
     break;
 case (APPLY_SCALE):
     M00 = m00;
     M11 = m11;
     if (M00 == 0.0 || M11 == 0.0) {
  thrownewNoninvertibleTransformException("Determinant is 0");
     }
     m00 = 1.0 / M00;
     // m10 = 0.0;
     // m01 = 0.0;
     m11 = 1.0 / M11;
     // m02 = 0.0;
     // m12 = 0.0;
     break;
 case (APPLY_TRANSLATE):
     // m00 = 1.0;
     // m10 = 0.0;
     // m01 = 0.0;
     // m11 = 1.0;
     m02 = -m02;
     m12 = -m12;
     break;
 case (APPLY_IDENTITY):
     // m00 = 1.0;
     // m10 = 0.0;
     // m01 = 0.0;
     // m11 = 1.0;
     // m02 = 0.0;
     // m12 = 0.0;
     break;
 }
    }
    /**
     * Transforms the specified <code>ptSrc</code> and stores the result
     * in <code>ptDst</code>.
     * If <code>ptDst</code> is <code>null</code>, a new {@link vector}
     * object is allocated and then the result of the transformation is
     * stored in this object.
     * In either case, <code>ptDst</code>, which contains the
     * transformed point, is returned for convenience.
     * If <code>ptSrc</code> and <code>ptDst</code> are the same
     * object, the input point is correctly overwritten with
     * the transformed point.
     * @param ptSrc the specified <code>vector</code> to be transformed
     * @param ptDst the specified <code>vector</code> that stores the
     * result of transforming <code>ptSrc</code>
     * @return the <code>ptDst</code> after transforming
     * <code>ptSrc</code> and stroring the result in <code>ptDst</code>.
     * @since 1.2
     */
      vector transform(vector ptSrc, vector ptDst) {
/* if (ptDst == null) {
     if (ptSrc instanceof vector.Double) {
  ptDst = new vector.Double();
     } else {
  ptDst = new vector.Float();
     }
 }
*/
 // Copy source coords into local variables in case src == dst
 double x = ptSrc.x;
 double y = ptSrc.y;
 switch (state) {
// default:
//     stateError();
     /* NOTREACHED */
 case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
     ptDst.x=x * m00 + y * m01 + m02; ptDst.y=
         x * m10 + y * m11 + m12;
     return ptDst;
 case (APPLY_SHEAR | APPLY_SCALE):
     ptDst.x=x * m00 + y * m01; ptDst.y = x * m10 + y * m11;
     return ptDst;
 case (APPLY_SHEAR | APPLY_TRANSLATE):
     ptDst.x=y * m01 + m02; ptDst.y= x * m10 + m12;
     return ptDst;
 case (APPLY_SHEAR):
     ptDst.x=y * m01; ptDst.y= x * m10;
     return ptDst;
 case (APPLY_SCALE | APPLY_TRANSLATE):
     ptDst.x=x * m00 + m02; ptDst.y= y * m11 + m12;
     return ptDst;
 case (APPLY_SCALE):
     ptDst.x=x * m00; ptDst.y= y * m11;
     return ptDst;
 case (APPLY_TRANSLATE):
     ptDst.x=x + m02; ptDst.y= y + m12;
     return ptDst;
 case (APPLY_IDENTITY):
     ptDst.x=x; ptDst.y= y;
     return ptDst;
 }
 /* NOTREACHED */
 return ptDst;
    }
    /**
     * Transforms an array of point objects by this transform.
     * If any element of the <code>ptDst</code> array is
     * <code>null</code>, a new <code>vector</code> object is allocated
     * and stored into that element before storing the results of the
     * transformation.
     * <p>
     * Note that this method does not take any precautions to
     * avoid problems caused by storing results into <code>vector</code>
     * objects that will be used as the source for calculations
     * further down the source array.
     * This method does guarantee that if a specified <code>vector</code> 
     * object is both the source and destination for the same single point
     * transform operation then the results will not be stored until
     * the calculations are complete to avoid storing the results on
     * top of the operands.
     * If, however, the destination <code>vector</code> object for one
     * operation is the same object as the source <code>vector</code> 
     * object for another operation further down the source array then
     * the original coordinates in that point are overwritten before
     * they can be converted.
     * @param ptSrc the array containing the source point objects
     * @param ptDst the array into which the transform point objects are
     * returned
     * @param srcOff the offset to the first point object to be
     * transformed in the source array
     * @param dstOff the offset to the location of the first
     * transformed point object that is stored in the destination array
     * @param numPts the number of point objects to be transformed
     * @since 1.2
     */
      void transform(vector[]@ ptSrc, int srcOff,
     vector[]@ ptDst, int dstOff,
     int numPts) {
 int state = this.state;
        while (--numPts >= 0) {
            // Copy source coords into local variables in case src == dst
     vector src = ptSrc[srcOff++];
            double x = src.x;
            double y = src.y;
     vector dst = ptDst[dstOff++];
/*     if (dst == null) {
  if (src instanceof vector.Double) {
      dst = new vector.Double();
  } else {
      dst = new vector.Float();
  }
  ptDst[dstOff - 1] = dst;
     }*/
     switch (state) {
//     default:
//  stateError();
  /* NOTREACHED */
     case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
  dst.x=x * m00 + y * m01 + m02;
    dst.y=x * m10 + y * m11 + m12;
  break;
     case (APPLY_SHEAR | APPLY_SCALE):
  dst.x=x * m00 + y * m01; dst.y= x * m10 + y * m11;
  break;
     case (APPLY_SHEAR | APPLY_TRANSLATE):
  dst.x=y * m01 + m02; dst.y= x * m10 + m12;
  break;
     case (APPLY_SHEAR):
  dst.x=y * m01; dst.y= x * m10;
  break;
     case (APPLY_SCALE | APPLY_TRANSLATE):
  dst.x=x * m00 + m02; dst.y= y * m11 + m12;
  break;
     case (APPLY_SCALE):
  dst.x=x * m00; dst.y= y * m11;
  break;
     case (APPLY_TRANSLATE):
  dst.x=x + m02; dst.y= y + m12;
  break;
     case (APPLY_IDENTITY):
  dst.x=x; dst.y= y;
  break;
     }
 }
 /* NOTREACHED */
    }
    /**
     * Transforms an array of floating point coordinates by this transform.
     * The two coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are overwritten by a
     * previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
     * @param srcPts the array containing the source point coordinates.
     * Each point is stored as a pair of x,&nbsp;y coordinates.
     * @param dstPts the array into which the transformed point coordinates
     * are returned.  Each point is stored as a pair of x,&nbsp;y
     * coordinates.
     * @param srcOff the offset to the first point to be transformed
     * in the source array
     * @param dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param numPts the number of points to be transformed
     * @since 1.2
     */
      void transform(float[]@ srcPts, int srcOff,
     float[]@ dstPts, int dstOff,
     int numPts) {
 double M00, M01, M02, M10, M11, M12; // For caching
 if (dstPts == srcPts &&
     dstOff > srcOff && dstOff < srcOff + numPts * 2)
 {
     // If the arrays overlap partially with the destination higher
     // than the source and we transform the coordinates normally
     // we would overwrite some of the later source coordinates
     // with results of previous transformations.
     // To get around this we use arraycopy to copy the points
     // to their final destination with correct overwrite
     // handling and then transform them in place in the new
     // safer location.
 dstPts=arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
     // srcPts = dstPts;  // They are known to be equal.
     srcOff = dstOff;
 }
 switch (state) {
// default:
//     stateError();
     /* NOTREACHED */
 case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
     M00 = m00; M01 = m01; M02 = m02;
     M10 = m10; M11 = m11; M12 = m12;
     while (--numPts >= 0) {
  double x = srcPts[srcOff++];
  double y = srcPts[srcOff++];
  dstPts[dstOff++] =  (M00 * x + M01 * y + M02);
  dstPts[dstOff++] =  (M10 * x + M11 * y + M12);
     }
     return;
 case (APPLY_SHEAR | APPLY_SCALE):
     M00 = m00; M01 = m01;
     M10 = m10; M11 = m11;
     while (--numPts >= 0) {
  double x = srcPts[srcOff++];
  double y = srcPts[srcOff++];
  dstPts[dstOff++] =  (M00 * x + M01 * y);
  dstPts[dstOff++] =  (M10 * x + M11 * y);
     }
     return;
 case (APPLY_SHEAR | APPLY_TRANSLATE):
     M01 = m01; M02 = m02;
     M10 = m10; M12 = m12;
     while (--numPts >= 0) {
  double x = srcPts[srcOff++];
  dstPts[dstOff++] =  (M01 * srcPts[srcOff++] + M02);
  dstPts[dstOff++] =  (M10 * x + M12);
     }
     return;
 case (APPLY_SHEAR):
     M01 = m01; M10 = m10;
     while (--numPts >= 0) {
  double x = srcPts[srcOff++];
  dstPts[dstOff++] =  (M01 * srcPts[srcOff++]);
  dstPts[dstOff++] =  (M10 * x);
     }
     return;
 case (APPLY_SCALE | APPLY_TRANSLATE):
     M00 = m00; M02 = m02;
     M11 = m11; M12 = m12;
     while (--numPts >= 0) {
  dstPts[dstOff++] =  (M00 * srcPts[srcOff++] + M02);
  dstPts[dstOff++] =  (M11 * srcPts[srcOff++] + M12);
     }
     return;
 case (APPLY_SCALE):
     M00 = m00; M11 = m11;
     while (--numPts >= 0) {
  dstPts[dstOff++] =  (M00 * srcPts[srcOff++]);
  dstPts[dstOff++] =  (M11 * srcPts[srcOff++]);
     }
     return;
 case (APPLY_TRANSLATE):
     M02 = m02; M12 = m12;
     while (--numPts >= 0) {
  dstPts[dstOff++] =   (srcPts[srcOff++] + M02);
  dstPts[dstOff++] =   (srcPts[srcOff++] + M12);
     }
     return;
 case (APPLY_IDENTITY):
     if (srcPts != dstPts || srcOff != dstOff) {
 dstPts=arraycopy(srcPts, srcOff, dstPts, dstOff,
     numPts * 2);
     }
     return;
 }
 /* NOTREACHED */
    }
    /**
     * Transforms an array of double precision coordinates by this transform.
     * The two coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are
     * overwritten by a previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the indicated
     * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
     * @param srcPts the array containing the source point coordinates.
     * Each point is stored as a pair of x,&nbsp;y coordinates.
     * @param dstPts the array into which the transformed point
     * coordinates are returned.  Each point is stored as a pair of
     * x,&nbsp;y coordinates.
     * @param srcOff the offset to the first point to be transformed
     * in the source array
     * @param dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param numPts the number of point objects to be transformed
     * @since 1.2
     */
      void transform(double[]@ srcPts, int srcOff,
     double[]@ dstPts, int dstOff,
     int numPts) {
 double M00, M01, M02, M10, M11, M12; // For caching
 if (dstPts == srcPts &&
     dstOff > srcOff && dstOff < srcOff + numPts * 2)
 {
     // If the arrays overlap partially with the destination higher
     // than the source and we transform the coordinates normally
     // we would overwrite some of the later source coordinates
     // with results of previous transformations.
     // To get around this we use arraycopy to copy the points
     // to their final destination with correct overwrite
     // handling and then transform them in place in the new
     // safer location.
 dstPts=arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
     // srcPts = dstPts;  // They are known to be equal.
     srcOff = dstOff;
 }
 switch (state) {
// default:
//     stateError();
     /* NOTREACHED */
 case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
     M00 = m00; M01 = m01; M02 = m02;
     M10 = m10; M11 = m11; M12 = m12;
     while (--numPts >= 0) {
  double x = srcPts[srcOff++];
  double y = srcPts[srcOff++];
  dstPts[dstOff++] = M00 * x + M01 * y + M02;
  dstPts[dstOff++] = M10 * x + M11 * y + M12;
     }
     return;
 case (APPLY_SHEAR | APPLY_SCALE):
     M00 = m00; M01 = m01;
     M10 = m10; M11 = m11;
     while (--numPts >= 0) {
  double x = srcPts[srcOff++];
  double y = srcPts[srcOff++];
  dstPts[dstOff++] = M00 * x + M01 * y;
  dstPts[dstOff++] = M10 * x + M11 * y;
     }
     return;
 case (APPLY_SHEAR | APPLY_TRANSLATE):
     M01 = m01; M02 = m02;
     M10 = m10; M12 = m12;
     while (--numPts >= 0) {
  double x = srcPts[srcOff++];
  dstPts[dstOff++] = M01 * srcPts[srcOff++] + M02;
  dstPts[dstOff++] = M10 * x + M12;
     }
     return;
 case (APPLY_SHEAR):
     M01 = m01; M10 = m10;
     while (--numPts >= 0) {
  double x = srcPts[srcOff++];
  dstPts[dstOff++] = M01 * srcPts[srcOff++];
  dstPts[dstOff++] = M10 * x;
     }
     return;
 case (APPLY_SCALE | APPLY_TRANSLATE):
     M00 = m00; M02 = m02;
     M11 = m11; M12 = m12;
     while (--numPts >= 0) {
  dstPts[dstOff++] = M00 * srcPts[srcOff++] + M02;
  dstPts[dstOff++] = M11 * srcPts[srcOff++] + M12;
     }
     return;
 case (APPLY_SCALE):
     M00 = m00; M11 = m11;
     while (--numPts >= 0) {
  dstPts[dstOff++] = M00 * srcPts[srcOff++];
  dstPts[dstOff++] = M11 * srcPts[srcOff++];
     }
     return;
 case (APPLY_TRANSLATE):
     M02 = m02; M12 = m12;
     while (--numPts >= 0) {
  dstPts[dstOff++] = srcPts[srcOff++] + M02;
  dstPts[dstOff++] = srcPts[srcOff++] + M12;
     }
     return;
 case (APPLY_IDENTITY):
     if (srcPts != dstPts || srcOff != dstOff) {
 dstPts=arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
//  System.arraycopy(srcPts, srcOff, dstPts, dstOff,     numPts * 2);
     }
     return;
 }
 /* NOTREACHED */
    }
    /**
     * Transforms an array of floating point coordinates by this transform
     * and stores the results into an array of doubles.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
     * @param srcPts the array containing the source point coordinates.
     * Each point is stored as a pair of x,&nbsp;y coordinates.
     * @param dstPts the array into which the transformed point coordinates
     * are returned.  Each point is stored as a pair of x,&nbsp;y
     * coordinates.
     * @param srcOff the offset to the first point to be transformed
     * in the source array
     * @param dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param numPts the number of points to be transformed
     * @since 1.2
     */
      void transform(float[]@ srcPts, int srcOff,
     double[]@ dstPts, int dstOff,
     int numPts) {
 double M00, M01, M02, M10, M11, M12; // For caching
 switch (state) {
// default:
//     stateError();
     /* NOTREACHED */
 case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
     M00 = m00; M01 = m01; M02 = m02;
     M10 = m10; M11 = m11; M12 = m12;
     while (--numPts >= 0) {
  double x = srcPts[srcOff++];
  double y = srcPts[srcOff++];
  dstPts[dstOff++] = M00 * x + M01 * y + M02;
  dstPts[dstOff++] = M10 * x + M11 * y + M12;
     }
     return;
 case (APPLY_SHEAR | APPLY_SCALE):
     M00 = m00; M01 = m01;
     M10 = m10; M11 = m11;
     while (--numPts >= 0) {
  double x = srcPts[srcOff++];
  double y = srcPts[srcOff++];
  dstPts[dstOff++] = M00 * x + M01 * y;
  dstPts[dstOff++] = M10 * x + M11 * y;
     }
     return;
 case (APPLY_SHEAR | APPLY_TRANSLATE):
     M01 = m01; M02 = m02;
     M10 = m10; M12 = m12;
     while (--numPts >= 0) {
  double x = srcPts[srcOff++];
  dstPts[dstOff++] = M01 * srcPts[srcOff++] + M02;
  dstPts[dstOff++] = M10 * x + M12;
     }
     return;
 case (APPLY_SHEAR):
     M01 = m01; M10 = m10;
     while (--numPts >= 0) {
  double x = srcPts[srcOff++];
  dstPts[dstOff++] = M01 * srcPts[srcOff++];
  dstPts[dstOff++] = M10 * x;
     }
     return;
 case (APPLY_SCALE | APPLY_TRANSLATE):
     M00 = m00; M02 = m02;
     M11 = m11; M12 = m12;
     while (--numPts >= 0) {
  dstPts[dstOff++] = M00 * srcPts[srcOff++] + M02;
  dstPts[dstOff++] = M11 * srcPts[srcOff++] + M12;
     }
     return;
 case (APPLY_SCALE):
     M00 = m00; M11 = m11;
     while (--numPts >= 0) {
  dstPts[dstOff++] = M00 * srcPts[srcOff++];
  dstPts[dstOff++] = M11 * srcPts[srcOff++];
     }
     return;
 case (APPLY_TRANSLATE):
     M02 = m02; M12 = m12;
     while (--numPts >= 0) {
  dstPts[dstOff++] = srcPts[srcOff++] + M02;
  dstPts[dstOff++] = srcPts[srcOff++] + M12;
     }
     return;
 case (APPLY_IDENTITY):
     while (--numPts >= 0) {
  dstPts[dstOff++] = srcPts[srcOff++];
  dstPts[dstOff++] = srcPts[srcOff++];
     }
     return;
 }
 /* NOTREACHED */
    }
    /**
     * Transforms an array of double precision coordinates by this transform
     * and stores the results into an array of floats.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
     * @param srcPts the array containing the source point coordinates.
     * Each point is stored as a pair of x,&nbsp;y coordinates.
     * @param dstPts the array into which the transformed point
     * coordinates are returned.  Each point is stored as a pair of 
     * x,&nbsp;y coordinates.
     * @param srcOff the offset to the first point to be transformed
     * in the source array
     * @param dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param numPts the number of point objects to be transformed
     * @since 1.2
     */
      void transform(double[]@ srcPts, int srcOff,
     float[]@ dstPts, int dstOff,
     int numPts) {
 double M00, M01, M02, M10, M11, M12; // For caching
 switch (state) {
// default:
//     stateError();
     /* NOTREACHED */
 case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
     M00 = m00; M01 = m01; M02 = m02;
     M10 = m10; M11 = m11; M12 = m12;
     while (--numPts >= 0) {
  double x = srcPts[srcOff++];
  double y = srcPts[srcOff++];
  dstPts[dstOff++] =   (M00 * x + M01 * y + M02);
  dstPts[dstOff++] =   (M10 * x + M11 * y + M12);
     }
     return;
 case (APPLY_SHEAR | APPLY_SCALE):
     M00 = m00; M01 = m01;
     M10 = m10; M11 = m11;
     while (--numPts >= 0) {
  double x = srcPts[srcOff++];
  double y = srcPts[srcOff++];
  dstPts[dstOff++] =   (M00 * x + M01 * y);
  dstPts[dstOff++] =   (M10 * x + M11 * y);
     }
     return;
 case (APPLY_SHEAR | APPLY_TRANSLATE):
     M01 = m01; M02 = m02;
     M10 = m10; M12 = m12;
     while (--numPts >= 0) {
  double x = srcPts[srcOff++];
  dstPts[dstOff++] =   (M01 * srcPts[srcOff++] + M02);
  dstPts[dstOff++] =   (M10 * x + M12);
     }
     return;
 case (APPLY_SHEAR):
     M01 = m01; M10 = m10;
     while (--numPts >= 0) {
  double x = srcPts[srcOff++];
  dstPts[dstOff++] =   (M01 * srcPts[srcOff++]);
  dstPts[dstOff++] =   (M10 * x);
     }
     return;
 case (APPLY_SCALE | APPLY_TRANSLATE):
     M00 = m00; M02 = m02;
     M11 = m11; M12 = m12;
     while (--numPts >= 0) {
  dstPts[dstOff++] =   (M00 * srcPts[srcOff++] + M02);
  dstPts[dstOff++] =   (M11 * srcPts[srcOff++] + M12);
     }
     return;
 case (APPLY_SCALE):
     M00 = m00; M11 = m11;
     while (--numPts >= 0) {
  dstPts[dstOff++] =   (M00 * srcPts[srcOff++]);
  dstPts[dstOff++] =   (M11 * srcPts[srcOff++]);
     }
     return;
 case (APPLY_TRANSLATE):
     M02 = m02; M12 = m12;
     while (--numPts >= 0) {
  dstPts[dstOff++] =   (srcPts[srcOff++] + M02);
  dstPts[dstOff++] =   (srcPts[srcOff++] + M12);
     }
     return;
 case (APPLY_IDENTITY):
     while (--numPts >= 0) {
  dstPts[dstOff++] =   (srcPts[srcOff++]);
  dstPts[dstOff++] =   (srcPts[srcOff++]);
     }
     return;
 }
 /* NOTREACHED */
    }
    /**
     * Inverse transforms the specified <code>ptSrc</code> and stores the
     * result in <code>ptDst</code>.
     * If <code>ptDst</code> is <code>null</code>, a new
     * <code>vector</code> object is allocated and then the result of the
     * transform is stored in this object.
     * In either case, <code>ptDst</code>, which contains the transformed
     * point, is returned for convenience.
     * If <code>ptSrc</code> and <code>ptDst</code> are the same
     * object, the input point is correctly overwritten with the
     * transformed point.
     * @param ptSrc the point to be inverse transformed
     * @param ptDst the resulting transformed point
     * @return <code>ptDst</code>, which contains the result of the 
     * inverse transform.
     * @exception NoninvertibleTransformException  if the matrix cannot be
     *                                         inverted.
     * @since 1.2
     */
 vector inverseTransform(vector ptSrc, vector ptDst)

    {
/* if (ptDst == null) {
     if (ptSrc instanceof vector.Double) {
  ptDst = new vector.Double();
     } else {
  ptDst = new vector.Float();
     }
 }*/
 // Copy source coords into local variables in case src == dst
 double x = ptSrc.x;
 double y = ptSrc.y;
 switch (state) {
// default:
//     stateError();
     /* NOTREACHED */
 case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE): {
     x -= m02;
     y -= m12;
     /* NOBREAK */
};
 case (APPLY_SHEAR | APPLY_SCALE): {
     double det = m00 * m11 - m01 * m10;
     if (abs(det) <= MIN_VALUE) {
  thrownewNoninvertibleTransformException("Determinant is "+
         det);
     }
     ptDst.x=(x * m11 - y * m01) / det;
     ptDst.y=(y * m00 - x * m10) / det;
     return ptDst; }
 case (APPLY_SHEAR | APPLY_TRANSLATE): {
     x -= m02;
     y -= m12;
     /* NOBREAK */
}
 case (APPLY_SHEAR): {
     if (m01 == 0.0 || m10 == 0.0) {
  thrownewNoninvertibleTransformException("Determinant is 0");
     }
     ptDst.x=y / m10; ptDst.y= x / m01;
     return ptDst;}
 case (APPLY_SCALE | APPLY_TRANSLATE): {
     x -= m02;
     y -= m12;
 }     /* NOBREAK */
 case (APPLY_SCALE): {
     if (m00 == 0.0 || m11 == 0.0) {
  thrownewNoninvertibleTransformException("Determinant is 0");
     }
     ptDst.x=x / m00; ptDst.y=y / m11;
     return ptDst; }
 case (APPLY_TRANSLATE): {
     ptDst.x=x - m02; ptDst.y= y - m12;
     return ptDst;}
 case (APPLY_IDENTITY): {
     ptDst.x=x; ptDst.y= y;
     return ptDst;}
 }
 /* NOTREACHED */
 return ptDst;
    }
    /**
     * Inverse transforms an array of double precision coordinates by
     * this transform.  
     * The two coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are
     * overwritten by a previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
     * @param srcPts the array containing the source point coordinates.
     * Each point is stored as a pair of x,&nbsp;y coordinates.
     * @param dstPts the array into which the transformed point
     * coordinates are returned.  Each point is stored as a pair of 
     * x,&nbsp;y coordinates.
     * @param srcOff the offset to the first point to be transformed
     * in the source array
     * @param dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param numPts the number of point objects to be transformed
     * @exception NoninvertibleTransformException  if the matrix cannot be
     *                                         inverted.
     * @since 1.2
     */
      void inverseTransform(double[]@ srcPts, int srcOff,
                                 double[]@ dstPts, int dstOff,
                                 int numPts)

    {
 double M00, M01, M02, M10, M11, M12; // For caching
 double det;
 if (dstPts == srcPts &&
     dstOff > srcOff && dstOff < srcOff + numPts * 2)
 {
     // If the arrays overlap partially with the destination higher
     // than the source and we transform the coordinates normally
     // we would overwrite some of the later source coordinates
     // with results of previous transformations.
     // To get around this we use arraycopy to copy the points
     // to their final destination with correct overwrite
     // handling and then transform them in place in the new
     // safer location.
 dstPts=arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
//      dstPts=arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
     // srcPts = dstPts;  // They are known to be equal.
     srcOff = dstOff;
 }
 switch (state) {
// default:
//     stateError();
     /* NOTREACHED */
 case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
     M00 = m00; M01 = m01; M02 = m02;
     M10 = m10; M11 = m11; M12 = m12;
     det = M00 * M11 - M01 * M10;
     if (abs(det) <= MIN_VALUE) {
  thrownewNoninvertibleTransformException("Determinant is "+
         det);
     }
     while (--numPts >= 0) {
  double x = srcPts[srcOff++] - M02;
  double y = srcPts[srcOff++] - M12;
  dstPts[dstOff++] = (x * M11 - y * M01) / det;
  dstPts[dstOff++] = (y * M00 - x * M10) / det;
     }
     return;
 case (APPLY_SHEAR | APPLY_SCALE):
     M00 = m00; M01 = m01;
     M10 = m10; M11 = m11;
     det = M00 * M11 - M01 * M10;
     if (abs(det) <= MIN_VALUE) {
  thrownewNoninvertibleTransformException("Determinant is "+
         det);
     }
     while (--numPts >= 0) {
  double x = srcPts[srcOff++];
  double y = srcPts[srcOff++];
  dstPts[dstOff++] = (x * M11 - y * M01) / det;
  dstPts[dstOff++] = (y * M00 - x * M10) / det;
     }
     return;
 case (APPLY_SHEAR | APPLY_TRANSLATE):
     M01 = m01; M02 = m02;
     M10 = m10; M12 = m12;
     if (M01 == 0.0 || M10 == 0.0) {
  thrownewNoninvertibleTransformException("Determinant is 0");
     }
     while (--numPts >= 0) {
  double x = srcPts[srcOff++] - M02;
  dstPts[dstOff++] = (srcPts[srcOff++] - M12) / M10;
  dstPts[dstOff++] = x / M01;
     }
     return;
 case (APPLY_SHEAR):
     M01 = m01; M10 = m10;
     if (M01 == 0.0 || M10 == 0.0) {
  thrownewNoninvertibleTransformException("Determinant is 0");
     }
     while (--numPts >= 0) {
  double x = srcPts[srcOff++];
  dstPts[dstOff++] = srcPts[srcOff++] / M10;
  dstPts[dstOff++] = x / M01;
     }
     return;
 case (APPLY_SCALE | APPLY_TRANSLATE):
     M00 = m00; M02 = m02;
     M11 = m11; M12 = m12;
     if (M00 == 0.0 || M11 == 0.0) {
  thrownewNoninvertibleTransformException("Determinant is 0");
     }
     while (--numPts >= 0) {
  dstPts[dstOff++] = (srcPts[srcOff++] - M02) / M00;
  dstPts[dstOff++] = (srcPts[srcOff++] - M12) / M11;
     }
     return;
 case (APPLY_SCALE):
     M00 = m00; M11 = m11;
     if (M00 == 0.0 || M11 == 0.0) {
  thrownewNoninvertibleTransformException("Determinant is 0");
     }
     while (--numPts >= 0) {
  dstPts[dstOff++] = srcPts[srcOff++] / M00;
  dstPts[dstOff++] = srcPts[srcOff++] / M11;
     }
     return;
 case (APPLY_TRANSLATE):
     M02 = m02; M12 = m12;
     while (--numPts >= 0) {
  dstPts[dstOff++] = srcPts[srcOff++] - M02;
  dstPts[dstOff++] = srcPts[srcOff++] - M12;
     }
     return;
 case (APPLY_IDENTITY):
     if (srcPts != dstPts || srcOff != dstOff) {
 dstPts=arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
//  System.arraycopy(srcPts, srcOff, dstPts, dstOff,     numPts * 2);
     }
     return;
 }
 /* NOTREACHED */
    }
    /**
     * Transforms the relative distance vector specified by 
     * <code>ptSrc</code> and stores the result in <code>ptDst</code>.
     * A relative distance vector is transformed without applying the
     * translation components of the affine transformation matrix
     * using the following equations:
     * <pre>
     * [  x' ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]
     * [  y' ] = [  m10  m11 (m12) ] [  y  ] = [ m10x + m11y ]
     * [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]
     * </pre>
     * If <code>ptDst</code> is <code>null</code>, a new
     * <code>vector</code> object is allocated and then the result of the
     * transform is stored in this object.
     * In either case, <code>ptDst</code>, which contains the
     * transformed point, is returned for convenience.
     * If <code>ptSrc</code> and <code>ptDst</code> are the same object,
     * the input point is correctly overwritten with the transformed
     * point.
     * @param ptSrc the distance vector to be delta transformed
     * @param ptDst the resulting transformed distance vector
     * @return <code>ptDst</code>, which contains the result of the
     * transformation.
     * @since 1.2
     */
      vector deltaTransform(vector ptSrc, vector ptDst) {
 // Copy source coords into local variables in case src == dst
 double x = ptSrc.x;
 double y = ptSrc.y;
 switch (state) {
// default:
//     stateError();
     /* NOTREACHED */
 case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
 case (APPLY_SHEAR | APPLY_SCALE):
     ptDst.x=x * m00 + y * m01; ptDst.y= x * m10 + y * m11;
     return ptDst;
 case (APPLY_SHEAR | APPLY_TRANSLATE):
 case (APPLY_SHEAR):
     ptDst.x=y * m01; ptDst.y= x * m10;
     return ptDst;
 case (APPLY_SCALE | APPLY_TRANSLATE):
 case (APPLY_SCALE):
     ptDst.x=x * m00; ptDst.y= y * m11;
     return ptDst;
 case (APPLY_TRANSLATE):
 case (APPLY_IDENTITY):
     ptDst.x=x; ptDst.y= y;
     return ptDst;
 }
 /* NOTREACHED */
 return ptDst;
    }
    /**
     * Transforms an array of relative distance vectors by this
     * transform.
     * A relative distance vector is transformed without applying the
     * translation components of the affine transformation matrix
     * using the following equations:
     * <pre>
     * [  x' ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]
     * [  y' ] = [  m10  m11 (m12) ] [  y  ] = [ m10x + m11y ]
     * [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]
     * </pre>
     * The two coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are
     * overwritten by a previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the indicated
     * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
     * @param srcPts the array containing the source distance vectors.
     * Each vector is stored as a pair of relative x,&nbsp;y coordinates.
     * @param dstPts the array into which the transformed distance vectors
     * are returned.  Each vector is stored as a pair of relative
     * x,&nbsp;y coordinates.
     * @param srcOff the offset to the first vector to be transformed
     * in the source array
     * @param dstOff the offset to the location of the first
     * transformed vector that is stored in the destination array
     * @param numPts the number of vector coordinate pairs to be
     * transformed
     * @since 1.2
     */
      void deltaTransform(double[]@ srcPts, int srcOff,
          double[]@ dstPts, int dstOff,
          int numPts) {
 double M00, M01, M10, M11; // For caching
 if (dstPts == srcPts &&
     dstOff > srcOff && dstOff < srcOff + numPts * 2)
 {
     // If the arrays overlap partially with the destination higher
     // than the source and we transform the coordinates normally
     // we would overwrite some of the later source coordinates
     // with results of previous transformations.
     // To get around this we use arraycopy to copy the points
     // to their final destination with correct overwrite
     // handling and then transform them in place in the new
     // safer location.
      dstPts=arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
     // srcPts = dstPts;  // They are known to be equal.
     srcOff = dstOff;
 }
 switch (state) {
// default:
//     stateError();
     /* NOTREACHED */
 case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
 case (APPLY_SHEAR | APPLY_SCALE):
     M00 = m00; M01 = m01;
     M10 = m10; M11 = m11;
     while (--numPts >= 0) {
  double x = srcPts[srcOff++];
  double y = srcPts[srcOff++];
  dstPts[dstOff++] = x * M00 + y * M01;
  dstPts[dstOff++] = x * M10 + y * M11;
     }
     return;
 case (APPLY_SHEAR | APPLY_TRANSLATE):
 case (APPLY_SHEAR):
     M01 = m01; M10 = m10;
     while (--numPts >= 0) {
  double x = srcPts[srcOff++];
  dstPts[dstOff++] = srcPts[srcOff++] * M01;
  dstPts[dstOff++] = x * M10;
     }
     return;
 case (APPLY_SCALE | APPLY_TRANSLATE):
 case (APPLY_SCALE):
     M00 = m00; M11 = m11;
     while (--numPts >= 0) {
  dstPts[dstOff++] = srcPts[srcOff++] * M00;
  dstPts[dstOff++] = srcPts[srcOff++] * M11;
     }
     return;
 case (APPLY_TRANSLATE):
 case (APPLY_IDENTITY):
     if (srcPts != dstPts || srcOff != dstOff) {
 dstPts=arraycopy(srcPts, srcOff, dstPts, dstOff,     numPts * 2);
     }
     return;
 }
 /* NOTREACHED */
    }
    /**
     * Returns a new {@link Shape} object defined by the geometry of the
     * specified <code>Shape</code> after it has been transformed by
     * this transform.
     * @param pSrc the specified <code>Shape</code> object to be
     * transformed by this transform.
     * @return a new <code>Shape</code> object that defines the geometry
     * of the transformed <code>Shape</code>, or null if {@code pSrc} is null.
     * @since 1.2
     */
      Shape@ createTransformedShape(Shape@ pSrc) {
        if (@pSrc == null) {
            return null;
        }
        return newPath2D(pSrc, this);
    }
    // Round values to sane precision for printing
    // Note that sin(Math.PI) has an error of about 10^-16
 double _matround(double matval) {
 double E15=1000000000000000;
 return round(matval * E15, 0) / E15;
    }
    /**
     * Returns a <code>String</code> that represents the value of this
     * {@link Object}.
     * @return a <code>String</code> representing the value of this
     * <code>Object</code>.
     * @since 1.2
     */
      string toString() {
 return ("AffineTransform[["
  + _matround(m00) + ", "
  + _matround(m01) + ", "
  + _matround(m02) + "], ["
  + _matround(m10) + ", "
  + _matround(m11) + ", "
  + _matround(m12) + "]]");
    }
    /**
     * Returns <code>true</code> if this <code>AffineTransform</code> is
     * an identity transform.
     * @return <code>true</code> if this <code>AffineTransform</code> is
     * an identity transform; <code>false</code> otherwise.
     * @since 1.2
     */
      bool isIdentity() {
        return (state == APPLY_IDENTITY || (getType() == TYPE_IDENTITY));
    }
    /**
     * Returns a copy of this <code>AffineTransform</code> object.
     * @return an <code>Object</code> that is a copy of this
     * <code>AffineTransform</code> object.
     * @since 1.2
     */
 AffineTransform@ clone() {
 AffineTransform ret(m00, m01, m02, m10, m11, m12);
 ret.state=state; ret.type=type;
 return ret;
    }
    /**
     * Returns the hashcode for this transform.
     * @return      a hash code for this transform.
     * @since 1.2
     */
/*      int hashCode() {
 long bits = Double.doubleToLongBits(m00);
 bits = bits * 31 + Double.doubleToLongBits(m01);
 bits = bits * 31 + Double.doubleToLongBits(m02);
 bits = bits * 31 + Double.doubleToLongBits(m10);
 bits = bits * 31 + Double.doubleToLongBits(m11);
 bits = bits * 31 + Double.doubleToLongBits(m12);
 return ((  bits) ^ (  (bits >> 32)));
    }
*/ // I hope we don't need that.
    /**
     * Returns <code>true</code> if this <code>AffineTransform</code> 
     * represents the same affine coordinate transform as the specified
     * argument.
     * @param obj the <code>Object</code> to test for equality with this
     * <code>AffineTransform</code>
     * @return <code>true</code> if <code>obj</code> equals this
     * <code>AffineTransform</code> object; <code>false</code> otherwise.
     * @since 1.2
     */
      bool equals(AffineTransform@ obj) {
//        if (!(obj instanceof AffineTransform)) {
//            return false;
//        }
//        AffineTransform a = (AffineTransform)obj;
 AffineTransform@ a=obj;
 return ((m00 == a.m00) && (m01 == a.m01) && (m02 == a.m02) &&
  (m10 == a.m10) && (m11 == a.m11) && (m12 == a.m12));
    }
}
    /**
     * Returns a transform representing a translation transformation.
     * The matrix representing the returned transform is:
     * <pre>
     *  [   1    0    tx  ]
     *  [   0    1    ty  ]
     *  [   0    0    1   ]
     * </pre>
     * @param tx the distance by which coordinates are translated in the
     * X axis direction
     * @param ty the distance by which coordinates are translated in the
     * Y axis direction
     * @return an <code>AffineTransform</code> object that represents a
     *  translation transformation, created with the specified vector.
     * @since 1.2
     */
 AffineTransform@ getTranslateInstance(double tx, double ty) {
 AffineTransform Tx = newAffineTransform();
 Tx.setToTranslation(tx, ty);
 return Tx;
    }
    /**
     * Returns a transform representing a rotation transformation.
     * The matrix representing the returned transform is:
     * <pre>
     *  [   cos(theta)    -sin(theta)    0   ]
     *  [   sin(theta)     cos(theta)    0   ]
     *  [       0              0         1   ]
     * </pre>
     * Rotating by a positive angle theta rotates points on the positive
     * X axis toward the positive Y axis.
     * Note also the discussion of
     * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
     * above.
     * @param theta the angle of rotation measured in radians
     * @return an <code>AffineTransform</code> object that is a rotation
     * transformation, created with the specified angle of rotation.
     * @since 1.2
     */
 AffineTransform@ getRotateInstance(double theta) {
 AffineTransform Tx = newAffineTransform();
 Tx.setToRotation(theta);
 return Tx;
    }
    /**
     * Returns a transform that rotates coordinates around an anchor point.
     * This operation is equivalent to translating the coordinates so
     * that the anchor point is at the origin (S1), then rotating them
     * about the new origin (S2), and finally translating so that the
     * intermediate origin is restored to the coordinates of the original
     * anchor point (S3).
     * <p>
     * This operation is equivalent to the following sequence of calls:
     * <pre>
     *     AffineTransform Tx = newAffineTransform();
     *     Tx.translate(anchorx, anchory);    // S3: final translation
     *     Tx.rotate(theta);        // S2: rotate around anchor
     *     Tx.translate(-anchorx, -anchory);  // S1: translate anchor to origin
     * </pre>
     * The matrix representing the returned transform is:
     * <pre>
     *  [   cos(theta)    -sin(theta)    x-x*cos+y*sin1 ]
     *  [   sin(theta)     cos(theta)    y-x*sin-y*cos1  ]
     *  [       0              0               1        ]
     * </pre>
     * Rotating by a positive angle theta rotates points on the positive
     * X axis toward the positive Y axis.
     * Note also the discussion of
     * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
     * above.
     *
     * @param theta the angle of rotation measured in radians
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
     * @return an <code>AffineTransform</code> object that rotates 
     * coordinates around the specified point by the specified angle of
     * rotation.
     * @since 1.2
     */
 AffineTransform@ getRotateInstance(double theta,
          double anchorx,
          double anchory)
    {
 AffineTransform Tx = newAffineTransform();
 Tx.setToRotation(theta, anchorx, anchory);
 return Tx;
    }
    /**
     * Returns a transform that rotates coordinates according to
     * a rotation vector.
     * All coordinates rotate about the origin by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both <code>vecx</code> and <code>vecy</code> are 0.0,
     * an identity transform is returned.
     * This operation is equivalent to calling:
     * <pre>
     *     AffineTransform.getRotateInstance(Math.atan2(vecy, vecx));
     * </pre>
     *
     * @param vecx the X coordinate of the rotation vector
     * @param vecy the Y coordinate of the rotation vector
     * @return an <code>AffineTransform</code> object that rotates
     *  coordinates according to the specified rotation vector.
     * @since 1.6
     */
    AffineTransform@ getRotateInstance(double vecx, double vecy) {
 AffineTransform Tx = newAffineTransform();
 Tx.setToRotation(vecx, vecy);
 return Tx;
    }
    /**
     * Returns a transform that rotates coordinates around an anchor
     * point accordinate to a rotation vector.
     * All coordinates rotate about the specified anchor coordinates
     * by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both <code>vecx</code> and <code>vecy</code> are 0.0,
     * an identity transform is returned.
     * This operation is equivalent to calling:
     * <pre>
     *     AffineTransform.getRotateInstance(Math.atan2(vecy, vecx),
     *                                       anchorx, anchory);
     * </pre>
     *
     * @param vecx the X coordinate of the rotation vector
     * @param vecy the Y coordinate of the rotation vector
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
     * @return an <code>AffineTransform</code> object that rotates 
     * coordinates around the specified point according to the
     *  specified rotation vector.
     * @since 1.6
     */
    AffineTransform@ getRotateInstance(double vecx,
          double vecy,
          double anchorx,
          double anchory)
    {
 AffineTransform Tx = newAffineTransform();
 Tx.setToRotation(vecx, vecy, anchorx, anchory);
 return Tx;
    }
    /**
     * Returns a transform that rotates coordinates by the specified
     * number of quadrants.
     * This operation is equivalent to calling:
     * <pre>
     *     AffineTransform.getRotateInstance(numquadrants * Math.PI / 2.0);
     * </pre>
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     * @param numquadrants the number of 90 degree arcs to rotate by
     * @return an <code>AffineTransform</code> object that rotates
     *  coordinates by the specified number of quadrants.
     * @since 1.6
     */
    AffineTransform@ getQuadrantRotateInstance(int numquadrants) {
 AffineTransform Tx = newAffineTransform();
 Tx.setToQuadrantRotation(numquadrants);
 return Tx;
    }
    /**
     * Returns a transform that rotates coordinates by the specified
     * number of quadrants around the specified anchor point.
     * This operation is equivalent to calling:
     * <pre>
     *     AffineTransform.getRotateInstance(numquadrants * Math.PI / 2.0,
     *                                       anchorx, anchory);
     * </pre>
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     *
     * @param numquadrants the number of 90 degree arcs to rotate by
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
     * @return an <code>AffineTransform</code> object that rotates 
     * coordinates by the specified number of quadrants around the
     *  specified anchor point.
     * @since 1.6
     */
    AffineTransform@ getQuadrantRotateInstance(int numquadrants,
           double anchorx,
           double anchory)
    {
 AffineTransform Tx = newAffineTransform();
 Tx.setToQuadrantRotation(numquadrants, anchorx, anchory);
 return Tx;
    }
    /**
     * Returns a transform representing a scaling transformation.
     * The matrix representing the returned transform is:
     * <pre>
     *  [   sx   0    0   ]
     *  [   0    sy   0   ]
     *  [   0    0    1   ]
     * </pre>
     * @param sx the factor by which coordinates are scaled along the
     * X axis direction
     * @param sy the factor by which coordinates are scaled along the
     * Y axis direction
     * @return an <code>AffineTransform</code> object that scales 
     * coordinates by the specified factors.
     * @since 1.2
     */
    AffineTransform@ getScaleInstance(double sx, double sy) {
 AffineTransform Tx = newAffineTransform();
 Tx.setToScale(sx, sy);
 return Tx;
    }
    /**
     * Returns a transform representing a shearing transformation.
     * The matrix representing the returned transform is:
     * <pre>
     *  [   1   shx   0   ]
     *  [  shy   1    0   ]
     *  [   0    0    1   ]
     * </pre>
     * @param shx the multiplier by which coordinates are shifted in the
     * direction of the positive X axis as a factor of their Y coordinate
     * @param shy the multiplier by which coordinates are shifted in the
     * direction of the positive Y axis as a factor of their X coordinate
     * @return an <code>AffineTransform</code> object that shears 
     * coordinates by the specified multipliers.
     * @since 1.2
     */
    AffineTransform@ getShearInstance(double shx, double shy) {
 AffineTransform Tx = newAffineTransform();
 Tx.setToShear(shx, shy);
 return Tx;
    }

 int[] rot90conversion = {
 /* IDENTITY => */        APPLY_SHEAR,
 /* TRANSLATE (TR) => */  APPLY_SHEAR | APPLY_TRANSLATE,
 /* SCALE (SC) => */      APPLY_SHEAR,
 /* SC | TR => */         APPLY_SHEAR | APPLY_TRANSLATE,
 /* SHEAR (SH) => */      APPLY_SCALE,
 /* SH | TR => */         APPLY_SCALE | APPLY_TRANSLATE,
 /* SH | SC => */         APPLY_SHEAR | APPLY_SCALE,
 /* SH | SC | TR => */    APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE,
    };

void   thrownewNoninvertibleTransformException(string str) {int w=0;}

 AffineTransform@ newAffineTransform() {AffineTransform ret; return ret;}
 AffineTransform@ newAffineTransform(
 double m1, double m2,
 double m3, double m4,
 double m5, double m6,
 int app

) {
 AffineTransform ret(m1, m2, m3, m4, m5, m6, app);
return ret;
}

 double[] arraycopy(double[]@ src, int srcpos, double[]@ dst, int dstpos, int len) {
 if(dst.length()<dstpos+len) dst.resize(dstpos+len);
 if(src.length()<srcpos+len) src.resize(srcpos+len);
 for(uint i=0; i<len; i++) {
 dst[dstpos+i]=src[srcpos+i];
 }// MEH!!!
 return dst;
 }// Arraycopy, because porting java is not fun.
 float[] arraycopy(float[]@ src, int srcpos, float[]@ dst, int dstpos, int len) {
 if(dst.length()<dstpos+len) dst.resize(dstpos+len);
 if(src.length()<srcpos+len) src.resize(srcpos+len);
 for(uint i=0; i<len; i++) {
 dst[dstpos+i]=src[srcpos+i];
 }// MEH!!!
 return dst;
 }// Arraycopy, because porting java is not fun.



 PathIterator@ newPathIterator() {FlatteningPathIterator ret; return ret;}
 Shape@ newPath2D(Shape@ s, AffineTransform@ at) {
 PathIterator@ fpi=s.getPathIterator(at, 0.1);
 Polygon ret;
 if(@fpi==null) {
return s;
}
 while(!fpi.isDone()) {
 double[] coords={0, 0, 0, 0, 0, 0};
 int type=fpi.currentSegment(coords);
  ret.addPoint(coords[0], coords[1]);
 fpi.next();
}
 return ret;
}


    /**
     * The winding rule constant for specifying an even-odd rule     * for determining the interior of a path.
     * The even-odd rule specifies that a point lies inside the     * path if a ray drawn in any direction from that point to     * infinity is crossed by path segments an odd number of times.
     */
    const int WIND_EVEN_ODD = 0;
    /**
     * The winding rule constant for specifying a non-zero rule     * for determining the interior of a path.
     * The non-zero rule specifies that a point lies inside the     * path if a ray drawn in any direction from that point to     * infinity is crossed by path segments a different number     * of times in the counter-clockwise direction than the     * clockwise direction.
     */
    const int WIND_NON_ZERO = 1;
    /**
     * The segment type constant for a point that specifies the
     * starting location for a new subpath.
     */
    const int SEG_MOVETO  = 0;
    /**
     * The segment type constant for a point that specifies the     * end point of a line to be drawn from the most recently     * specified point.
     */
    const int SEG_LINETO  = 1;
    /**
     * The segment type constant for the pair of points that specify     * a quadratic parametric curve to be drawn from the most recently     * specified point.
     * The curve is interpolated by solving the parametric control     * equation in the range <code>(t=[0..1])</code> using 
    * the most recently specified (current) point (CP),
     * the first control point (P1),
     * and the final interpolated control point (P2).
     * The parametric control equation for this curve is:
     *          P(t) = B(2,0)*CP + B(2,1)*P1 + B(2,2)*P2
     *          0 &lt;= t &lt;= 1
     *
     *        B(n,m) = mth coefficient of nth degree Bernstein polynomial
     *               = C(n,m) * t^(m) * (1 - t)^(n-m)
     *        C(n,m) = Combinations of n things, taken m at a time
     *               = n! / (m! * (n-m)!)
     */
    const int SEG_QUADTO  = 2;
    /**
     * The segment type constant for the set of 3 points that specify     * a cubic parametric curve to be drawn from the most recently     * specified point.
     * The curve is interpolated by solving the parametric control     * equation in the range <code>(t=[0..1])</code> using
     * the most recently specified (current) point (CP),
     * the first control point (P1),
     * the second control point (P2),
     * and the final interpolated control point (P3).
     * The parametric control equation for this curve is:
     *          P(t) = B(3,0)*CP + B(3,1)*P1 + B(3,2)*P2 + B(3,3)*P3
     *          0 &lt;= t &lt;= 1
     *
     *        B(n,m) = mth coefficient of nth degree Bernstein polynomial
     *               = C(n,m) * t^(m) * (1 - t)^(n-m)
     *        C(n,m) = Combinations of n things, taken m at a time
     *               = n! / (m! * (n-m)!)
     * This form of curve is commonly known as a B&eacute;zier curve.
     */
    const int SEG_CUBICTO  = 3;
    /**
     * The segment type constant that specifies that     * the preceding subpath should be closed by appending a line segment     * back to the point corresponding to the most recent SEG_MOVETO.
     */
    const int SEG_CLOSE  = 4;


 interface PathIterator {
 int getWindingRule();
 bool isDone();
void next();
    /**
     * Returns the coordinates and type of the current path segment in     * the iteration.
     * The return value is the path-segment type:
     * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.
     * A float array of length 6 must be passed in and can be used to     * store the coordinates of the point(s).
     * Each point is stored as a pair of float x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types returns one point,
     * SEG_QUADTO returns two points,
     * SEG_CUBICTO returns 3 points
     * and SEG_CLOSE does not return any points.
     * @param coords an array that holds the data returned from     * this method
     * @return the path-segment type of the current path segment.
     */
 int currentSegment(float[] &out coords);
    /**
     * Returns the coordinates and type of the current path segment in     * the iteration.
     * The return value is the path-segment type:
     * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.
     * A double array of length 6 must be passed in and can be used to     * store the coordinates of the point(s).
     * Each point is stored as a pair of double x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types returns one point,
     * SEG_QUADTO returns two points,
     * SEG_CUBICTO returns 3 points
     * and SEG_CLOSE does not return any points.
     * @param coords an array that holds the data returned from     * this method
     * @return the path-segment type of the current path segment.
     */
 int currentSegment(double[] &out coords);
}

const int GROW_SIZE = 24; // Multiple of cubic & quad curve size
 class FlatteningPathIterator : PathIterator {

    PathIterator@ src;   // The source iterator
    double squareflat;   // Square of the flatness parameter
     // for testing against squared lengths
    int limit;    // Maximum number of recursion levels
    double[] hold;// = new double[14]; // The cache of interpolated coords
     // Note that this must be long enough     // to store a full cubic segment and     // a relative cubic segment to avoid     // aliasing when copying the coords     // of a curve to the end of the array.
     // This is also serendipitously equal     // to the size of a full quad segment     // and 2 relative quad segments.
    double curx; double cury;   // The ending x,y of the last segment
    double movx; double movy;   // The x,y of the last move segment
    int holdType;   // The type of the curve being held     // for interpolation
    int holdEnd;   // The index of the last curve segment     // being held for interpolation
    int holdIndex;   // The index of the curve segment     // that was last interpolated.  This     // is the curve segment ready to be     // returned in the next call to     // currentSegment().
    int[] levels;   // The recursion level at which
     // each curve being held in storage     // was generated.
    int levelIndex;   // The index of the entry in the     // levels array of the curve segment     // at the holdIndex
    bool done;   // True when iteration is done
    /**
     * Constructs a new <code>FlatteningPathIterator</code> object that 
     * flattens a path as it iterates over it.  The iterator does not 
     * subdivide any curve read from the source iterator to more than 
     * 10 levels of subdivision which yields a maximum of 1024 line 
     * segments per curve.
     * @param src the original unflattened path being iterated over
     * @param flatness the maximum allowable distance between the
     * control points and the flattened curve
     */
 FlatteningPathIterator() {init(null, 0, 10);}
 FlatteningPathIterator(PathIterator@ src, double flatness) {
 init(src, flatness, 10);
    }
    /**
     * Constructs a new <code>FlatteningPathIterator</code> object 
     * that flattens a path as it iterates over it.
     * The <code>limit</code> parameter allows you to control the
     * maximum number of recursive subdivisions that the iterator
     * can make before it assumes that the curve is flat enough
     * without measuring against the <code>flatness</code> parameter.
     * The flattened iteration therefore never generates more than
     * a maximum of <code>(2^limit)</code> line segments per curve.
     * @param src the original unflattened path being iterated over
     * @param flatness the maximum allowable distance between the
     * control points and the flattened curve
     * @param limit the maximum number of recursive subdivisions
     * allowed for any curved segment
     * @exception <code>IllegalArgumentException</code> if 
     *   <code>flatness</code> or <code>limit</code>
     *  is less than zero
     */
 FlatteningPathIterator(PathIterator@ src, double flatness,
      int limit) { init(src, flatness, limit);}
 void init(PathIterator@ src, double flatness, int limit) {
 if (flatness < 0.0) {
 flatness=absolute(flatness);
 }
 if (limit < 0) {
 limit=absolute(limit);
 }
 @(this.src) = src;
 this.squareflat = flatness * flatness;
 this.limit = limit;
 this.levels.resize(limit + 1);
 for(uint i=0; i<levels.length(); i++) {levels[i]=0;} // Because java initializes that and bgt doesn't. Hopefully I'm not going to be using any super giant path iterators that will makethis loop a time-hog.
 // prime the first path segment
 next(false);
    }
    /**
     * Returns the flatness of this iterator.
     * @return the flatness of this <code>FlatteningPathIterator</code>.
     */
 double getFlatness() {
 return square_root(squareflat);
    }
    /**
     * Returns the recursion limit of this iterator.
     * @return the recursion limit of this      * <code>FlatteningPathIterator</code>.
     */
 int getRecursionLimit() {
 return limit;
    }
    /**
     * Returns the winding rule for determining the interior of the     * path.
     * @return the winding rule of the original unflattened path being     * iterated over.
     */
 int getWindingRule() {
 return src.getWindingRule();
    }
    /**
     * Tests if the iteration is complete.
     * @return <code>true</code> if all the segments have     * been read; <code>false</code> otherwise.
     */
 bool isDone() {
 return done;
    }
    /*
     * Ensures that the hold array can hold up to (want) more values.
     * It is currently holding (hold.length - holdIndex) values.
     */
    void ensureHoldCapacity(int want) {
 if (holdIndex - want < 0) {
     int have = hold.length - holdIndex;
     int newsize = hold.length + GROW_SIZE;
     double[] newhold(newsize);
 newhold=arraycopy(hold, holdIndex,
        newhold, holdIndex + GROW_SIZE,
        have);
     hold = newhold;
     holdIndex += GROW_SIZE;
     holdEnd += GROW_SIZE;
 }
    }
    /**
     * Moves the iterator to the next segment of the path forwards     * along the primary direction of traversal as long as there are     * more points in that direction.
     */
 void next() {
 next(true);
    }
 void next(bool doNext) {
 int level;
 if (holdIndex >= holdEnd) {
     if (doNext) {
  src.next();
     }
     if (src.isDone()) {
  done = true;
  return;
     }
     holdType = src.currentSegment(hold);
     levelIndex = 0;
     levels[0] = 0;
 }
 switch (holdType) {
 case SEG_MOVETO:
 case SEG_LINETO:
     curx = hold[0];
     cury = hold[1];
     if (holdType == SEG_MOVETO) {
  movx = curx;
  movy = cury;
     }
     holdIndex = 0;
     holdEnd = 0;
     break;
 case SEG_CLOSE:
     curx = movx;
     cury = movy;
     holdIndex = 0;
     holdEnd = 0;
     break;
 case SEG_QUADTO:
     if (holdIndex >= holdEnd) {
  // Move the coordinates to the end of the array.
  holdIndex = hold.length - 6;
  holdEnd = hold.length - 2;
  hold[holdIndex + 0] = curx;
  hold[holdIndex + 1] = cury;
  hold[holdIndex + 2] = hold[0];
  hold[holdIndex + 3] = hold[1];
  hold[holdIndex + 4] = curx = hold[2];
  hold[holdIndex + 5] = cury = hold[3];
     }
     level = levels[levelIndex];
     while (level < limit) {
  if (QuadCurve2D_getFlatnessSq(hold, holdIndex) < squareflat) {
      break;
  }
  ensureHoldCapacity(4);
  QuadCurve2D_subdivide(hold, holdIndex,
          hold, holdIndex - 4,
          hold, holdIndex);
  holdIndex -= 4;
  // Now that we have subdivided, we have constructed
  // two curves of one depth lower than the original
  // curve.  One of those curves is in the place of
  // the former curve and one of them is in the next
  // set of held coordinate slots.  We now set both
  // curves level values to the next higher level.
  level++;
  levels[levelIndex] = level;
  levelIndex++;
  levels[levelIndex] = level;
     }
     // This curve segment is flat enough, or it is too deep
     // in recursion levels to try to flatten any more.  The
     // two coordinates at holdIndex+4 and holdIndex+5 now
     // contain the endpoint of the curve which can be the
     // endpoint of an approximating line segment.
     holdIndex += 4;
     levelIndex--;
     break;
 case SEG_CUBICTO:
     if (holdIndex >= holdEnd) {
  // Move the coordinates to the end of the array.
  holdIndex = hold.length - 8;
  holdEnd = hold.length - 2;
  hold[holdIndex + 0] = curx;
  hold[holdIndex + 1] = cury;
  hold[holdIndex + 2] = hold[0];
  hold[holdIndex + 3] = hold[1];
  hold[holdIndex + 4] = hold[2];
  hold[holdIndex + 5] = hold[3];
  hold[holdIndex + 6] = curx = hold[4];
  hold[holdIndex + 7] = cury = hold[5];
     }
     level = levels[levelIndex];
     while (level < limit) {
  if (CubicCurve2D_getFlatnessSq(hold, holdIndex) < squareflat) {
      break;
  }
  ensureHoldCapacity(6);
  CubicCurve2D_subdivide(hold, holdIndex,
           hold, holdIndex - 6,
           hold, holdIndex);
  holdIndex -= 6;
  // Now that we have subdivided, we have constructed
  // two curves of one depth lower than the original
  // curve.  One of those curves is in the place of
  // the former curve and one of them is in the next
  // set of held coordinate slots.  We now set both
  // curves level values to the next higher level.
  level++;
  levels[levelIndex] = level;
  levelIndex++;
  levels[levelIndex] = level;
     }
     // This curve segment is flat enough, or it is too deep
     // in recursion levels to try to flatten any more.  The
     // two coordinates at holdIndex+6 and holdIndex+7 now
     // contain the endpoint of the curve which can be the
     // endpoint of an approximating line segment.
     holdIndex += 6;
     levelIndex--;
     break;
 }
    }
    /**
     * Returns the coordinates and type of the current path segment in     * the iteration.
     * The return value is the path segment type:
     * SEG_MOVETO, SEG_LINETO, or SEG_CLOSE.
     * A float array of length 6 must be passed in and can be used to     * store the coordinates of the point(s).
     * Each point is stored as a pair of float x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types return one point,
     * and SEG_CLOSE does not return any points.
     * @param coords an array that holds the data returned from
     * this method
     * @return the path segment type of the current path segment.
     * @exception <code>NoSuchElementException</code> if there
     *  are no more elements in the flattening path to be     *  returned.
     */
 int currentSegment(float[] &out coords) {
 if (isDone()) {
 return -1;
 }
 int type = holdType;
 if (type != SEG_CLOSE) {
     coords[0] =   hold[holdIndex + 0];
     coords[1] =   hold[holdIndex + 1];
     if (type != SEG_MOVETO) {
  type = SEG_LINETO;
     }
 }
 return type;
    }
    /**
     * Returns the coordinates and type of the current path segment in
     * the iteration.
     * The return value is the path segment type:
     * SEG_MOVETO, SEG_LINETO, or SEG_CLOSE.
     * A double array of length 6 must be passed in and can be used to     * store the coordinates of the point(s).
     * Each point is stored as a pair of double x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types return one point,
     * and SEG_CLOSE does not return any points.
     * @param coords an array that holds the data returned from     * this method
     * @return the path segment type of the current path segment.
     */
 int currentSegment(double[] &out coords) {
 if (isDone()) {
 return -1;
 }
 int type = holdType;
 if (type != SEG_CLOSE) {
     coords[0] = hold[holdIndex + 0];
     coords[1] = hold[holdIndex + 1];
     if (type != SEG_MOVETO) {
  type = SEG_LINETO;
     }
 }
 return type;
    }
}

class RectIterator : PathIterator {
    double x; double y; double w; double h;
    AffineTransform@ affine;
    int index;
    RectIterator(Rectangle@ r, AffineTransform at) {
 index=0;
 x=r.x;
 y=r.y;
 w=r.width;
 h=r.height;
 @(this.affine) = at;
 if (w < 0 || h < 0) {
     index = 6;
 }
    }
    /**
     * Return the winding rule for determining the insideness of the
     * path.
     * @see #WIND_EVEN_ODD
     * @see #WIND_NON_ZERO
     */
 int getWindingRule() {
 return WIND_NON_ZERO;
    }
    /**
     * Tests if there are more points to read.
     * @return true if there are more points to read
     */
 bool isDone() {
 return index > 5;
    }
    /**
     * Moves the iterator to the next segment of the path forwards
     * along the primary direction of traversal as long as there are
     * more points in that direction.
     */
 void next() {
 index++;
    }
    /**
     * Returns the coordinates and type of the current path segment in
     * the iteration.
     * The return value is the path segment type:
     * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.
     * A float array of length 6 must be passed in and may be used to
     * store the coordinates of the point(s).
     * Each point is stored as a pair of float x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point,
     * SEG_QUADTO will return two points,
     * SEG_CUBICTO will return 3 points
     * and SEG_CLOSE will not return any points.
     */
 int currentSegment(float[] &out coords) {
 if (isDone()) {
 return -1;
 }
 if (index == 5) {
     return SEG_CLOSE;
 }
 coords[0] =   x;
 coords[1] =   y;
 if (index == 1 || index == 2) {
     coords[0] +=   w;
 }
 if (index == 2 || index == 3) {
     coords[1] +=   h;
 }
 if (@affine != null) {
     affine.transform(coords, 0, coords, 0, 1);
 }
 return (index == 0 ? SEG_MOVETO : SEG_LINETO);
    }
    /**
     * Returns the coordinates and type of the current path segment in
     * the iteration.
     * The return value is the path segment type:
     * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.
     * A double array of length 6 must be passed in and may be used to     * store the coordinates of the point(s).
     * Each point is stored as a pair of double x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point,
     * SEG_QUADTO will return two points,
     * SEG_CUBICTO will return 3 points
     * and SEG_CLOSE will not return any points.
     */
 int currentSegment(double[] &out coords) {
 if (isDone()) {
 return -1;
 }
 if (index == 5) {
     return SEG_CLOSE;
 }
 coords[0] = x;
 coords[1] = y;
 if (index == 1 || index == 2) {
     coords[0] += w;
 }
 if (index == 2 || index == 3) {
     coords[1] += h;
 }
 if (@affine != null) {
     affine.transform(coords, 0, coords, 0, 1);
 }
 return (index == 0 ? SEG_MOVETO : SEG_LINETO);
    }
}



// Quad Curve 2D


    /**
     * Fill an array with the coefficients of the parametric equation
     * in t, ready for solving against val with solveQuadratic.
     * We currently have:
     *     val = Py(t) = C1*(1-t)^2 + 2*CP*t*(1-t) + C2*t^2
     *                 = C1 - 2*C1*t + C1*t^2 + 2*CP*t - 2*CP*t^2 + C2*t^2
     *                 = C1 + (2*CP - 2*C1)*t + (C1 - 2*CP + C2)*t^2
     *               0 = (C1 - val) + (2*CP - 2*C1)*t + (C1 - 2*CP + C2)*t^2
     *               0 = C + Bt + At^2
     *     C = C1 - val
     *     B = 2*CP - 2*C1
     *     A = C1 - 2*CP + C2
     */
 void fillEqn(double[]@ eqn, double val,
    double c1, double cp, double c2) {
 eqn[0] = c1 - val;
 eqn[1] = cp + cp - c1 - c1;
 eqn[2] = c1 - cp - cp + c2;
 return;
    }
    /**
     * Evaluate the t values in the first num slots of the vals[] array
     * and place the evaluated values back into the same array.  Only
     * evaluate t values that are within the range <0, 1>, including
     * the 0 and 1 ends of the range iff the include0 or include1
     * booleans are true.  If an "inflection" equation is handed in,
     * then any points which represent a point of inflection for that
     * quadratic equation are also ignored.
     */
 int evalQuadratic(double[]@ vals, int num,
         bool include0,
         bool include1,
         double[]@ inflect,
         double c1, double ctrl, double c2) {
 int j = 0;
 for (int i = 0; i < num; i++) {
     double t = vals[i];
     if ((include0 ? t >= 0 : t > 0) &&
  (include1 ? t <= 1 : t < 1) &&
  (@inflect == null ||
   inflect[1] + 2*inflect[2]*t != 0))
     {
  double u = 1 - t;
  vals[j++] = c1*u*u + 2*ctrl*t*u + c2*t*t;
     }
 }
 return j;
    }
 const int BELOW = -2;
const int LOWEDGE = -1;
 const int INSIDE = 0;
 const int HIGHEDGE = 1;
 const int ABOVE = 2;
    /**
     * Determine where coord lies with respect to the range from
     * low to high.  It is assumed that low <= high.  The return
     * value is one of the 5 values BELOW, LOWEDGE, INSIDE, HIGHEDGE,
     * or ABOVE.
     */
 int getTag(double coord, double low, double high) {
 if (coord <= low) {
     return (coord < low ? BELOW : LOWEDGE);
 }
 if (coord >= high) {
     return (coord > high ? ABOVE : HIGHEDGE);
 }
 return INSIDE;
    }
    /**
     * Determine if the pttag represents a coordinate that is already
     * in its test range, or is on the border with either of the two
     * opttags representing another coordinate that is "towards the
     * inside" of that test range.  In other words, are either of the
     * two "opt" points "drawing the pt inward"?
     */
 bool inwards(int pttag, int opt1tag, int opt2tag) {
 switch (pttag) {
 case BELOW:
 case ABOVE: {return false;}
 case LOWEDGE:
{     return (opt1tag >= INSIDE || opt2tag >= INSIDE);}
 case INSIDE:
{     return true;}
 case HIGHEDGE:
{     return (opt1tag <= INSIDE || opt2tag <= INSIDE);}
 default:
     return false;

 }
 return false;
    }

    /**
     * Subdivides the quadratic curve specified by the <code>src</code>      * parameter and stores the resulting two subdivided curves into the     * <code>left</code> and <code>right</code> curve parameters.
     * Either or both of the <code>left</code> and <code>right</code>      * objects can be the same as the <code>src</code> object or      * <code>null</code>.
     * @param src the quadratic curve to be subdivided
     * @param left the <code>QuadCurve2D</code> object for storing the     *  left or first half of the subdivided curve
     * @param right the <code>QuadCurve2D</code> object for storing the     *  right or second half of the subdivided curve
     * @since 1.2
     */
 void QuadCurve2D_subdivide(QuadCurve2D@ src,
     QuadCurve2D@ left,
     QuadCurve2D@ right) { subdivide(src, left, right);}

 void subdivide(QuadCurve2D@ src,
     QuadCurve2D@ left,
     QuadCurve2D@ right) {
 double x1 = src.getX1();
 double y1 = src.getY1();
 double ctrlx = src.getCtrlX();
 double ctrly = src.getCtrlY();
 double x2 = src.getX2();
 double y2 = src.getY2();
 double ctrlx1 = (x1 + ctrlx) / 2.0;
 double ctrly1 = (y1 + ctrly) / 2.0;
 double ctrlx2 = (x2 + ctrlx) / 2.0;
 double ctrly2 = (y2 + ctrly) / 2.0;
 ctrlx = (ctrlx1 + ctrlx2) / 2.0;
 ctrly = (ctrly1 + ctrly2) / 2.0;
 if (@left != null) {
     left.setCurve(x1, y1, ctrlx1, ctrly1, ctrlx, ctrly);
 }
 if (@right != null) {
     right.setCurve(ctrlx, ctrly, ctrlx2, ctrly2, x2, y2);
 }
    }
    /**
     * Subdivides the quadratic curve specified by the coordinates     * stored in the <code>src</code> array at indices      * <code>srcoff</code> through <code>srcoff</code>&nbsp;+&nbsp;5     * and stores the resulting two subdivided curves into the two     * result arrays at the corresponding indices.     * Either or both of the <code>left</code> and <code>right</code>      * arrays can be <code>null</code> or a reference to the same array     * and offset as the <code>src</code> array.
     * Note that the last point in the first subdivided curve is the     * same as the first point in the second subdivided curve.  Thus,
     * it is possible to pass the same array for <code>left</code> and     * <code>right</code> and to use offsets such that      * <code>rightoff</code> equals <code>leftoff</code> + 4 in order     * to avoid allocating extra storage for this common point.
     * @param src the array holding the coordinates for the source curve
     * @param srcoff the offset into the array of the beginning of the     * the 6 source coordinates
     * @param left the array for storing the coordinates for the first     * half of the subdivided curve
     * @param leftoff the offset into the array of the beginning of the     * the 6 left coordinates
     * @param right the array for storing the coordinates for the second     * half of the subdivided curve
     * @param rightoff the offset into the array of the beginning of the     * the 6 right coordinates
     * @since 1.2
     */
 void QuadCurve2D_subdivide(double[]@ src, int srcoff,
     double[]@ left, int leftoff,
     double[]@ right, int rightoff) {
 subdivide(src, srcoff, left, leftoff, right, rightoff);}
 void subdivide(double[]@ src, int srcoff,
     double[]@ left, int leftoff,
     double[]@ right, int rightoff) {
 double x1 = src[srcoff + 0];
 double y1 = src[srcoff + 1];
 double ctrlx = src[srcoff + 2];
 double ctrly = src[srcoff + 3];
 double x2 = src[srcoff + 4];
 double y2 = src[srcoff + 5];
 if (@left != null) {
     left[leftoff + 0] = x1;
     left[leftoff + 1] = y1;
 }
 if (@right != null) {
     right[rightoff + 4] = x2;
     right[rightoff + 5] = y2;
 }
 x1 = (x1 + ctrlx) / 2.0;
 y1 = (y1 + ctrly) / 2.0;
 x2 = (x2 + ctrlx) / 2.0;
 y2 = (y2 + ctrly) / 2.0;
 ctrlx = (x1 + x2) / 2.0;
 ctrly = (y1 + y2) / 2.0;
 if (@left != null) {
     left[leftoff + 2] = x1;
     left[leftoff + 3] = y1;
     left[leftoff + 4] = ctrlx;
     left[leftoff + 5] = ctrly;
 }
 if (@right != null) {
     right[rightoff + 0] = ctrlx;
     right[rightoff + 1] = ctrly;
     right[rightoff + 2] = x2;
     right[rightoff + 3] = y2;
 }
    }
    /**
     * Solves the quadratic whose coefficients are in the <code>eqn</code> 
     * array and places the non-complex roots back into the same array,
     * returning the number of roots.  The quadratic solved is represented
     * by the equation:
     * <pre>
     *     eqn = {C, B, A};
     *     ax^2 + bx + c = 0
     * </pre>
     * A return value of <code>-1</code> is used to distinguish a constant
     * equation, which might be always 0 or never 0, from an equation that
     * has no zeroes.
     * @param eqn the array that contains the quadratic coefficients
     * @return the number of roots, or <code>-1</code> if the equation is
     *  a constant
     * @since 1.2
     */
 int solveQuadratic(double[]@ eqn) {
 return solveQuadratic(eqn, eqn);
    }
    /**
     * Solves the quadratic whose coefficients are in the <code>eqn</code> 
     * array and places the non-complex roots into the <code>res</code>
     * array, returning the number of roots.
     * The quadratic solved is represented by the equation:
     * <pre>
     *     eqn = {C, B, A};
     *     ax^2 + bx + c = 0
     * </pre>
     * A return value of <code>-1</code> is used to distinguish a constant
     * equation, which might be always 0 or never 0, from an equation that
     * has no zeroes.
     * @param eqn the specified array of coefficients to use to solve
     *        the quadratic equation
     * @param res the array that contains the non-complex roots 
     *        resulting from the solution of the quadratic equation
     * @return the number of roots, or <code>-1</code> if the equation is
     * a constant.
     * @since 1.3
     */
 int solveQuadratic(double[]@ eqn, double[]@ res) {
 double a = eqn[2];
 double b = eqn[1];
 double c = eqn[0];
 int roots = 0;
 if (a == 0.0) {
     // The quadratic parabola has degenerated to a line.
     if (b == 0.0) {
  // The line has degenerated to a constant.
  return -1;
     } 
     res[roots++] = -c / b;
 } else {
     // From Numerical Recipes, 5.6, Quadratic and Cubic Equations
     double d = b * b - 4.0 * a * c;
     if (d < 0.0) {
  // If d < 0.0, then there are no roots
  return 0;
     }
     d = square_root(d);
     // For accuracy, calculate one root using:
     //     (-b +/- d) / 2a
     // and the other using:
     //     2c / (-b +/- d)
     // Choose the sign of the +/- so that b+d gets larger in magnitude
     if (b < 0.0) {
  d = -d;
     }
     double q = (b + d) / -2.0;
     // We already tested a for being 0 above
     res[roots++] = q / a;
     if (q != 0.0) {
  res[roots++] = c / q;
     }
 }
 return roots;
    }


    /**
     * Returns the square of the flatness, or maximum distance of a     * control point from the line connecting the end points, of the     * quadratic curve specified by the indicated control points.
     * @param x1 the X coordinate of the start point     * @param y1 the Y coordinate of the start point     * @param ctrlx the X coordinate of the control point     * @param ctrly the Y coordinate of the control point     * @param x2 the X coordinate of the end point     * @param y2 the Y coordinate of the end point     * @return the square of the flatness of the quadratic curve     *  defined by the specified coordinates.
     * @since 1.2
     */
 double QuadCurve2D_getFlatnessSq(double x1, double y1, double ctrlx, double ctrly, double x2, double y2) {return getFlatnessSq(x1, y1, ctrlx, ctrly, x2, y2);}
 double getFlatnessSq(double x1, double y1,
           double ctrlx, double ctrly,
           double x2, double y2) {
 return Line2D_ptSegDistSq(x1, y1, x2, y2, ctrlx, ctrly);
    }
    /**
     * Returns the flatness, or maximum distance of a     * control point from the line connecting the end points, of the     * quadratic curve specified by the indicated control points.
     * @param x1 the X coordinate of the start point
     * @param y1 the Y coordinate of the start point
     * @param ctrlx the X coordinate of the control point
     * @param ctrly the Y coordinate of the control point
     * @param x2 the X coordinate of the end point
     * @param y2 the Y coordinate of the end point
     * @return the flatness of the quadratic curve defined by the 
     *  specified coordinates. 
     * @since 1.2
     */
 double QuadCurve2D_getFlatness(double x1, double y1,
         double ctrlx, double ctrly,
         double x2, double y2) {
 return Line2D_ptSegDist(x1, y1, x2, y2, ctrlx, ctrly);
    }

 double getFlatness(double x1, double y1,
         double ctrlx, double ctrly,
         double x2, double y2) {
 return Line2D_ptSegDist(x1, y1, x2, y2, ctrlx, ctrly);
    }
    /**
     * Returns the square of the flatness, or maximum distance of a     * control point from the line connecting the end points, of the     * quadratic curve specified by the control points stored in the     * indicated array at the indicated index.     * @param coords an array containing coordinate values     * @param offset the index into <code>coords</code> from which to     *  to start getting the values from the array     * @return the flatness of the quadratic curve that is defined by the     *   values in the specified array at the specified index.     * @since 1.2
     */
 double getFlatnessSq(double[]@ coords, int offset) {
 return Line2D_ptSegDistSq(coords[offset + 0], coords[offset + 1],
      coords[offset + 4], coords[offset + 5],
      coords[offset + 2], coords[offset + 3]);
    }
 double QuadCurve2D_getFlatnessSq(double[]@ coords, int offset) {
 return Line2D_ptSegDistSq(coords[offset + 0], coords[offset + 1],
      coords[offset + 4], coords[offset + 5],
      coords[offset + 2], coords[offset + 3]);
    }
    /**
     * Returns the flatness, or maximum distance of a     * control point from the line connecting the end points, of the     * quadratic curve specified by the control points stored in the     * indicated array at the indicated index.
     * @param coords an array containing coordinate values
     * @param offset the index into <code>coords</code> from which to
     *  start getting the coordinate values
     * @return the flatness of a quadratic curve defined by the 
     *  specified array at the specified offset.
     * @since 1.2
     */
 double getFlatness(double[]@ coords, int offset) {
 return Line2D_ptSegDist(coords[offset + 0], coords[offset + 1],
    coords[offset + 4], coords[offset + 5],
    coords[offset + 2], coords[offset + 3]);
    }
 double QuadCurve2D_getFlatness(double[]@ coords, int offset) {
 return Line2D_ptSegDist(coords[offset + 0], coords[offset + 1],
    coords[offset + 4], coords[offset + 5],
    coords[offset + 2], coords[offset + 3]);
    }




 class QuadCurve2D : Shape {
 double x1;
 double y1;
 double ctrlx;
 double ctrly;
 double x2;
 double y2;
 /**
  * Constructs and initializes a <code>QuadCurve2D</code> with         * coordinates (0, 0, 0, 0, 0, 0).         * @since 1.2
  */
 QuadCurve2D() {
 x1=0; x2=0; y1=0; y2=0; ctrlx=0; ctrly=0;
 }
 /**
  * Constructs and initializes a <code>QuadCurve2D</code> from the         * specified {@code double} coordinates.
         * @param x1 the X coordinate of the start point
         * @param y1 the Y coordinate of the start point
         * @param ctrlx the X coordinate of the control point
         * @param ctrly the Y coordinate of the control point
         * @param x2 the X coordinate of the end point
         * @param y2 the Y coordinate of the end point
         * @since 1.2
  */
 QuadCurve2D(double x1, double y1,
        double ctrlx, double ctrly,
        double x2, double y2)
        {
     setCurve(x1, y1, ctrlx, ctrly, x2, y2);
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
 double getX1() {
     return x1;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
 double getY1() {
     return y1;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
 vector getP1() {
     return newvector(x1, y1);
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
 double getCtrlX() {
     return ctrlx;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
 double getCtrlY() {
     return ctrly;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
 vector getCtrlPt() {
     return newvector(ctrlx, ctrly);
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
 double getX2() {
     return x2;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
 double getY2() {
     return y2;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
 vector getP2() {
     return newvector(x2, y2);
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
 void setCurve(double x1, double y1,
        double ctrlx, double ctrly,
        double x2, double y2)
        {
     this.x1    = x1;
     this.y1    = y1;
     this.ctrlx = ctrlx;
     this.ctrly = ctrly;
     this.x2    = x2;
     this.y2    = y2;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
 Rectangle@ getBounds2D() {
     double left   = math_min(math_min(x1, x2), ctrlx);
     double top    = math_min(math_min(y1, y2), ctrly);
     double right  = math_max(math_max(x1, x2), ctrlx);
     double bottom = math_max(math_max(y1, y2), ctrly);
     return newRectangle(left, top,
       right - left, bottom - top);
 }
 void setCurve(double[] coords, int offset) {
 setCurve(coords[offset + 0], coords[offset + 1],
   coords[offset + 2], coords[offset + 3],
   coords[offset + 4], coords[offset + 5]);
    }
    /**
     * Sets the location of the end points and control point of this     * <code>QuadCurve2D</code> to the specified <code>vector</code>      * coordinates.
     * @param p1 the start point
     * @param cp the control point
     * @param p2 the end point
     * @since 1.2
     */
 void setCurve(vector p1, vector cp, vector p2) {
 setCurve(p1.x, p1.y,
   cp.x, cp.y,
   p2.x, p2.y);
    }
    /**
     * Sets the location of the end points and control points of this     * <code>QuadCurve2D</code> to the coordinates of the      * <code>vector</code> objects at the specified offset in     * the specified array.
     * @param pts an array containing <code>vector</code> that define     *  coordinate values
     * @param offset the index into <code>pts</code> from which to start     *  getting the coordinate values and assigning them to this     *  <code>QuadCurve2D</code>
     * @since 1.2
     */
 void setCurve(vector[] pts, int offset) {
 setCurve(pts[offset + 0].x, pts[offset + 0].y,
   pts[offset + 1].x, pts[offset + 1].y,
   pts[offset + 2].x, pts[offset + 2].y);
    }
    /**
     * Sets the location of the end points and control point of this      * <code>QuadCurve2D</code> to the same as those in the specified     * <code>QuadCurve2D</code>.
     * @param c the specified <code>QuadCurve2D</code>
     * @since 1.2
     */
 void setCurve(QuadCurve2D@ c) {
 setCurve(c.getX1(), c.getY1(),
   c.getCtrlX(), c.getCtrlY(),
   c.getX2(), c.getY2());
    }

    /**
     * Returns the square of the flatness, or maximum distance of a     * control point from the line connecting the end points, of this      * <code>QuadCurve2D</code>.
     * @return the square of the flatness of this     *  <code>QuadCurve2D</code>.
     * @since 1.2
     */
 double getFlatnessSq() {
 return Line2D_ptSegDistSq(getX1(), getY1(),
      getX2(), getY2(),
      getCtrlX(), getCtrlY());
    }
    /**
     * Returns the flatness, or maximum distance of a     * control point from the line connecting the end points, of this     * <code>QuadCurve2D</code>.
     * @return the flatness of this <code>QuadCurve2D</code>.
     * @since 1.2
     */
 double getFlatness() {
 return Line2D_ptSegDist(getX1(), getY1(),
    getX2(), getY2(),
    getCtrlX(), getCtrlY());
    }
    /**
     * Subdivides this <code>QuadCurve2D</code> and stores the resulting     * two subdivided curves into the <code>left</code> and      * <code>right</code> curve parameters.
     * Either or both of the <code>left</code> and <code>right</code>      * objects can be the same as this <code>QuadCurve2D</code> or     * <code>null</code>.
     * @param left the <code>QuadCurve2D</code> object for storing the     * left or first half of the subdivided curve
     * @param right the <code>QuadCurve2D</code> object for storing the     * right or second half of the subdivided curve
     * @since 1.2
     */
 void subdivide(QuadCurve2D@ left, QuadCurve2D@ right) {
 QuadCurve2D_subdivide(this, left, right);
    }
    /**
     * {@inheritDoc}
     * @since 1.2
     */
 bool contains(double x, double y) {
 double x1 = getX1();
 double y1 = getY1();
 double xc = getCtrlX();
 double yc = getCtrlY();
 double x2 = getX2();
 double y2 = getY2();
 /*
  * We have a convex shape bounded by quad curve Pc(t)
  * and ine Pl(t).
  *
  *     P1 = (x1, y1) - start point of curve
  *     P2 = (x2, y2) - end point of curve
  *     Pc = (xc, yc) - control point
  *
  *     Pq(t) = P1*(1 - t)^2 + 2*Pc*t*(1 - t) + P2*t^2 =
  *           = (P1 - 2*Pc + P2)*t^2 + 2*(Pc - P1)*t + P1
  *     Pl(t) = P1*(1 - t) + P2*t
  *     t = [0:1]
  *
  *     P = (x, y) - point of interest
  *
  * Let's look at second derivative of quad curve equation:
  *
  *     Pq''(t) = 2 * (P1 - 2 * Pc + P2) = Pq''
  *     It's constant vector.
  *
  * Let's draw a line through P to be parallel to this
  * vector and find the intersection of the quad curve
  * and the line.
  *
  * Pq(t) is point of intersection if system of equations
  * below has the solution.
  *
  *     L(s) = P + Pq''*s == Pq(t)
  *     Pq''*s + (P - Pq(t)) == 0
  *
  *     | xq''*s + (x - xq(t)) == 0
  *     | yq''*s + (y - yq(t)) == 0
  *
  * This system has the solution if rank of its matrix equals to 1.
  * That is, determinant of the matrix should be zero.
  *
  *     (y - yq(t))*xq'' == (x - xq(t))*yq''
  *
  * Let's solve this equation with 't' variable.
  * Also let kx = x1 - 2*xc + x2
  *          ky = y1 - 2*yc + y2
  *
  *     t0q = (1/2)*((x - x1)*ky - (y - y1)*kx) /
  *                 ((xc - x1)*ky - (yc - y1)*kx)
  *
  * Let's do the same for our line Pl(t):
  *
  *     t0l = ((x - x1)*ky - (y - y1)*kx) /
  *           ((x2 - x1)*ky - (y2 - y1)*kx)
  *
  * It's easy to check that t0q == t0l. This fact means
  * we can compute t0 only one time.
  *
  * In case t0 < 0 or t0 > 1, we have an intersections outside
  * of shape bounds. So, P is definitely out of shape.
  *
  * In case t0 is inside [0:1], we should calculate Pq(t0)
  * and Pl(t0). We have three points for now, and all of them
  * lie on one line. So, we just need to detect, is our point
  * of interest between points of intersections or not.
  *
  * If the denominator in the t0q and t0l equations is
  * zero, then the points must be collinear and so the
  * curve is degenerate and encloses no area.  Thus the
  * result is false.
  */
 double kx = x1 - 2 * xc + x2;
 double ky = y1 - 2 * yc + y2;
 double dx = x - x1;
 double dy = y - y1;
 double dxl = x2 - x1;
 double dyl = y2 - y1;
 double t0 = (dx * ky - dy * kx) / (dxl * ky - dyl * kx);
 if (t0 < 0 || t0 > 1 || t0 != t0) {
     return false;
 }
 double xb = kx * t0 * t0 + 2 * (xc - x1) * t0 + x1;
 double yb = ky * t0 * t0 + 2 * (yc - y1) * t0 + y1;
 double xl = dxl * t0 + x1;
 double yl = dyl * t0 + y1;
 return (x >= xb && x < xl) ||
        (x >= xl && x < xb) ||
        (y >= yb && y < yl) ||
        (y >= yl && y < yb);
    }
    /**
     * {@inheritDoc}
     * @since 1.2
     */
 bool contains(vector p) {
 return contains(p.x, p.y);
    }
    /**
     * {@inheritDoc}
     * @since 1.2
     */
 bool intersects(double x, double y, double w, double h) {
 // Trivially reject non-existant rectangles
 if (w <= 0 || h <= 0) {
     return false;
 }
 // Trivially accept if either endpoint is inside the rectangle
 // (not on its border since it may end there and not go inside)
 // Record where they lie with respect to the rectangle.
 //     -1 => left, 0 => inside, 1 => right
 double x1 = getX1();
 double y1 = getY1();
 int x1tag = getTag(x1, x, x+w);
 int y1tag = getTag(y1, y, y+h);
 if (x1tag == INSIDE && y1tag == INSIDE) {
     return true;
 }
 double x2 = getX2();
 double y2 = getY2();
 int x2tag = getTag(x2, x, x+w);
 int y2tag = getTag(y2, y, y+h);
 if (x2tag == INSIDE && y2tag == INSIDE) {
     return true;
 }
 double ctrlx = getCtrlX();
 double ctrly = getCtrlY();
 int ctrlxtag = getTag(ctrlx, x, x+w);
 int ctrlytag = getTag(ctrly, y, y+h);
 // Trivially reject if all points are entirely to one side of
 // the rectangle.
 if (x1tag < INSIDE && x2tag < INSIDE && ctrlxtag < INSIDE) {
     return false; // All points left
 }
 if (y1tag < INSIDE && y2tag < INSIDE && ctrlytag < INSIDE) {
     return false; // All points above
 }
 if (x1tag > INSIDE && x2tag > INSIDE && ctrlxtag > INSIDE) {
     return false; // All points right
 }
 if (y1tag > INSIDE && y2tag > INSIDE && ctrlytag > INSIDE) {
     return false; // All points below
 }
 // Test for endpoints on the edge where either the segment
 // or the curve is headed "inwards" from them
 // Note: These tests are a superset of the fast endpoint tests
 //       above and thus repeat those tests, but take more time
 //       and cover more cases
 if (inwards(x1tag, x2tag, ctrlxtag) &&
     inwards(y1tag, y2tag, ctrlytag))
 {
     // First endpoint on border with either edge moving inside
     return true;
 }
 if (inwards(x2tag, x1tag, ctrlxtag) &&
     inwards(y2tag, y1tag, ctrlytag))
 {
     // Second endpoint on border with either edge moving inside
     return true;
 }
 // Trivially accept if endpoints span directly across the rectangle
 bool xoverlap = (x1tag * x2tag <= 0);
 bool yoverlap = (y1tag * y2tag <= 0);
 if (x1tag == INSIDE && x2tag == INSIDE && yoverlap) {
     return true;
 }
 if (y1tag == INSIDE && y2tag == INSIDE && xoverlap) {
     return true;
 }
 // We now know that both endpoints are outside the rectangle
 // but the 3 points are not all on one side of the rectangle.
 // Therefore the curve cannot be contained inside the rectangle,
 // but the rectangle might be contained inside the curve, or
 // the curve might intersect the boundary of the rectangle.
 double[] eqn (3);
 double[] res (3);
 if (!yoverlap) {
            // Both Y coordinates for the closing segment are above or
     // below the rectangle which means that we can only intersect
     // if the curve crosses the top (or bottom) of the rectangle
     // in more than one place and if those crossing locations
     // span the horizontal range of the rectangle.
     fillEqn(eqn, (y1tag < INSIDE ? y : y+h), y1, ctrly, y2);
     return (solveQuadratic(eqn, res) == 2 &&
      evalQuadratic(res, 2, true, true, null,
      x1, ctrlx, x2) == 2 &&
      getTag(res[0], x, x+w) * getTag(res[1], x, x+w) <= 0);
 }
 // Y ranges overlap.  Now we examine the X ranges
 if (!xoverlap) {
            // Both X coordinates for the closing segment are left of
     // or right of the rectangle which means that we can only
     // intersect if the curve crosses the left (or right) edge
     // of the rectangle in more than one place and if those
     // crossing locations span the vertical range of the rectangle.
     fillEqn(eqn, (x1tag < INSIDE ? x : x+w), x1, ctrlx, x2);
     return (solveQuadratic(eqn, res) == 2 &&
      evalQuadratic(res, 2, true, true, null,
      y1, ctrly, y2) == 2 &&
      getTag(res[0], y, y+h) * getTag(res[1], y, y+h) <= 0);
 }
 // The X and Y ranges of the endpoints overlap the X and Y
 // ranges of the rectangle, now find out how the endpoint
 // line segment intersects the Y range of the rectangle
 double dx = x2 - x1;
 double dy = y2 - y1;
 double k = y2 * x1 - x2 * y1;
 int c1tag, c2tag;
 if (y1tag == INSIDE) {
     c1tag = x1tag;
 } else {
     c1tag = getTag((k + dx * (y1tag < INSIDE ? y : y+h)) / dy, x, x+w);
 }
 if (y2tag == INSIDE) {
     c2tag = x2tag;
 } else {
     c2tag = getTag((k + dx * (y2tag < INSIDE ? y : y+h)) / dy, x, x+w);
 }
 // If the part of the line segment that intersects the Y range
 // of the rectangle crosses it horizontally - trivially accept
 if (c1tag * c2tag <= 0) {
     return true;
 }
 // Now we know that both the X and Y ranges intersect and that
 // the endpoint line segment does not directly cross the rectangle.
 //
 // We can almost treat this case like one of the cases above
 // where both endpoints are to one side, except that we will
 // only get one intersection of the curve with the vertical
 // side of the rectangle.  This is because the endpoint segment
 // accounts for the other intersection.
 //
 // (Remember there is overlap in both the X and Y ranges which
 //  means that the segment must cross at least one vertical edge
 //  of the rectangle - in particular, the "near vertical side" -
 //  leaving only one intersection for the curve.)
 //
 // Now we calculate the y tags of the two intersections on the
 // "near vertical side" of the rectangle.  We will have one with
 // the endpoint segment, and one with the curve.  If those two
 // vertical intersections overlap the Y range of the rectangle,
 // we have an intersection.  Otherwise, we don't.
 // c1tag = vertical intersection class of the endpoint segment
 //
 // Choose the y tag of the endpoint that was not on the same
 // side of the rectangle as the subsegment calculated above.
 // Note that we can "steal" the existing Y tag of that endpoint
 // since it will be provably the same as the vertical intersection.
 c1tag = ((c1tag * x1tag <= 0) ? y1tag : y2tag);
 // c2tag = vertical intersection class of the curve
 //
 // We have to calculate this one the straightforward way.
 // Note that the c2tag can still tell us which vertical edge
 // to test against.
 fillEqn(eqn, (c2tag < INSIDE ? x : x+w), x1, ctrlx, x2);
 int num = solveQuadratic(eqn, res);
 // Note: We should be able to assert(num == 2); since the
 // X range "crosses" (not touches) the vertical boundary,
 // but we pass num to evalQuadratic for completeness.
 evalQuadratic(res, num, true, true, null, y1, ctrly, y2);
 // Note: We can assert(num evals == 1); since one of the
 // 2 crossings will be out of the [0,1] range.
 c2tag = getTag(res[0], y, y+h);
 // Finally, we have an intersection if the two crossings
 // overlap the Y range of the rectangle.
 return (c1tag * c2tag <= 0);
    }
    /**
     * {@inheritDoc}
     * @since 1.2
     */
 bool intersects(Rectangle@ r) {
 return intersects(r.x, r.y, r.width, r.height);
    }
    /**
     * {@inheritDoc}
     * @since 1.2
     */
 bool contains(double x, double y, double w, double h) {
        if (w <= 0 || h <= 0) {
            return false;
        }
 // Assertion: Quadratic curves closed by connecting their
 // endpoints are always convex.
 return (contains(x, y) &&
  contains(x + w, y) &&
  contains(x + w, y + h) &&
  contains(x, y + h));
    }
    /**
     * {@inheritDoc}
     * @since 1.2
     */
 bool contains(Rectangle@ r) {
 return contains(r.x, r.y, r.width, r.height);
    }
    /**
     * {@inheritDoc}
     * @since 1.2
     */
 Rectangle@ getBounds() {
 return getBounds2D().getBounds();
    }
    /**
     * Returns an iteration object that defines the boundary of the
     * shape of this <code>QuadCurve2D</code>.
     * The iterator for this class is not multi-threaded safe,
     * which means that this <code>QuadCurve2D</code> class does not
     * guarantee that modifications to the geometry of this
     * <code>QuadCurve2D</code> object do not affect any iterations of
     * that geometry that are already in process.
     * @param at an optional {@link AffineTransform} to apply to the
     *  shape boundary
     * @return a {@link PathIterator} object that defines the boundary
     *  of the shape.
     * @since 1.2
     */
 PathIterator@ getPathIterator(AffineTransform@ at) {
 return newQuadIterator(this, at);
    }
    /**
     * Returns an iteration object that defines the boundary of the
     * flattened shape of this <code>QuadCurve2D</code>.
     * The iterator for this class is not multi-threaded safe,
     * which means that this <code>QuadCurve2D</code> class does not
     * guarantee that modifications to the geometry of this
     * <code>QuadCurve2D</code> object do not affect any iterations of
     * that geometry that are already in process. 
     * @param at an optional <code>AffineTransform</code> to apply
     *  to the boundary of the shape
     * @param flatness the maximum distance that the control points for a 
     *  subdivided curve can be with respect to a line connecting
     *   the end points of this curve before this curve is
     *  replaced by a straight line connecting the end points.
     * @return a <code>PathIterator</code> object that defines the 
     *  flattened boundary of the shape.
     * @since 1.2
     */
 PathIterator@ getPathIterator(AffineTransform@ at, double flatness) {
 QuadIterator@ qi=newQuadIterator(this, at);
 FlatteningPathIterator ret(qi, flatness);
 return ret;
    }
    /**
     * Creates a new object of the same class and with the same contents 
     * as this object.
     *
     * @return     a clone of this instance.
     * @exception  OutOfMemoryError            if there is not enough memory.
     * @see        java.lang.Cloneable
     * @since      1.2
     */
 QuadCurve2D@ clone() {
 QuadCurve2D ret(x1, y1, ctrlx, ctrly, x2, y2);
 return ret;
    }

 Shape@ translate(double dx, double dy) {
 QuadCurve2D@ ret=clone();
 ret.x1+=dx; ret.x2+=dx; ret.ctrlx+=dx;
 ret.y1+=dy; ret.y2+=dy; ret.ctrly+=dy;
 return ret;
}
 Shape@ rotate(double theta) {
 double cx=(x1+x2)/2;
 double cy=(y1+y2)/2;
 return rotate(cx, cy, theta);
}// Rotate about the center?
 Shape@ rotate(double cx, double cy, double theta) {return rotate(newVector(cx, cy), theta);}
 Shape@ rotate(vector v, double theta) {
 QuadCurve2D@ ret=clone();
 vector p1(x1, y1);
 vector p2(x2, y2);
 vector cp(ctrlx, ctrly);
 p1= ::rotate(p1, v, theta);
 p2= ::rotate(p2, v, theta);
 cp= ::rotate(cp, v, theta);
 ret.x1=p1.x; ret.y1=p1.y;
 ret.x2=p2.x; ret.y2=p2.y;
 ret.ctrlx=cp.x; ret.ctrly=cp.y;
 return ret;
}// Rotate.
 Shape@ mirrorX() {
 QuadCurve2D ret(-x1, y1, -ctrlx, ctrly, -x2, y2); return ret;
}
 Shape@ mirrorY() {
 QuadCurve2D ret(x1, -y1, ctrlx, -ctrly, x2, -y2); return ret;
}
}
vector newvector(double x, double y, double z=0) {vector ret(x, y, z); return ret;}
 QuadCurve2D@ newQuadCurve2D(double x1, double y1, double ctrlx, double ctrly, double x2, double y2) {QuadCurve2D ret(x1, y1, ctrlx, ctrly, x2, y2); return ret;}




    /**
     * Subdivides the cubic curve specified by the <code>src</code> parameter
     * and stores the resulting two subdivided curves into the 
     * <code>left</code> and <code>right</code> curve parameters.
     * Either or both of the <code>left</code> and <code>right</code> objects 
     * may be the same as the <code>src</code> object or <code>null</code>.
     * @param src the cubic curve to be subdivided
     * @param left the cubic curve object for storing the left or
     * first half of the subdivided curve
     * @param right the cubic curve object for storing the right or
     * second half of the subdivided curve
     * @since 1.2
     */
 void CubicCurve2D_subdivide(CubicCurve2D@ src,
     CubicCurve2D@ left,
     CubicCurve2D@ right) {
 double x1 = src.getX1();
 double y1 = src.getY1();
 double ctrlx1 = src.getCtrlX1();
 double ctrly1 = src.getCtrlY1();
 double ctrlx2 = src.getCtrlX2();
 double ctrly2 = src.getCtrlY2();
 double x2 = src.getX2();
 double y2 = src.getY2();
 double centerx = (ctrlx1 + ctrlx2) / 2.0;
 double centery = (ctrly1 + ctrly2) / 2.0;
 ctrlx1 = (x1 + ctrlx1) / 2.0;
 ctrly1 = (y1 + ctrly1) / 2.0;
 ctrlx2 = (x2 + ctrlx2) / 2.0;
 ctrly2 = (y2 + ctrly2) / 2.0;
 double ctrlx12 = (ctrlx1 + centerx) / 2.0;
 double ctrly12 = (ctrly1 + centery) / 2.0;
 double ctrlx21 = (ctrlx2 + centerx) / 2.0;
 double ctrly21 = (ctrly2 + centery) / 2.0;
 centerx = (ctrlx12 + ctrlx21) / 2.0;
 centery = (ctrly12 + ctrly21) / 2.0;
 if (@left != null) {
     left.setCurve(x1, y1, ctrlx1, ctrly1,
     ctrlx12, ctrly12, centerx, centery);
 }
 if (@right != null) {
     right.setCurve(centerx, centery, ctrlx21, ctrly21,
      ctrlx2, ctrly2, x2, y2);
 }
    }
    /**
     * Subdivides the cubic curve specified by the coordinates
     * stored in the <code>src</code> array at indices <code>srcoff</code> 
     * through (<code>srcoff</code>&nbsp;+&nbsp;7) and stores the
     * resulting two subdivided curves into the two result arrays at the
     * corresponding indices.
     * Either or both of the <code>left</code> and <code>right</code>
     * arrays may be <code>null</code> or a reference to the same array 
     * as the <code>src</code> array.
     * Note that the last point in the first subdivided curve is the
     * same as the first point in the second subdivided curve. Thus,
     * it is possible to pass the same array for <code>left</code>
     * and <code>right</code> and to use offsets, such as <code>rightoff</code>
     * equals (<code>leftoff</code> + 6), in order
     * to avoid allocating extra storage for this common point.
     * @param src the array holding the coordinates for the source curve
     * @param srcoff the offset into the array of the beginning of the
     * the 6 source coordinates
     * @param left the array for storing the coordinates for the first
     * half of the subdivided curve
     * @param leftoff the offset into the array of the beginning of the
     * the 6 left coordinates
     * @param right the array for storing the coordinates for the second
     * half of the subdivided curve
     * @param rightoff the offset into the array of the beginning of the
     * the 6 right coordinates
     * @since 1.2
     */
 void CubicCurve2D_subdivide(double[]@ src, int srcoff,
     double[]@ left, int leftoff,
     double[]@ right, int rightoff) {
 double x1 = src[srcoff + 0];
 double y1 = src[srcoff + 1];
 double ctrlx1 = src[srcoff + 2];
 double ctrly1 = src[srcoff + 3];
 double ctrlx2 = src[srcoff + 4];
 double ctrly2 = src[srcoff + 5];
 double x2 = src[srcoff + 6];
 double y2 = src[srcoff + 7];
 if (@left != null) {
     left[leftoff + 0] = x1;
     left[leftoff + 1] = y1;
 }
 if (@right != null) {
     right[rightoff + 6] = x2;
     right[rightoff + 7] = y2;
 }
 x1 = (x1 + ctrlx1) / 2.0;
 y1 = (y1 + ctrly1) / 2.0;
 x2 = (x2 + ctrlx2) / 2.0;
 y2 = (y2 + ctrly2) / 2.0;
 double centerx = (ctrlx1 + ctrlx2) / 2.0;
 double centery = (ctrly1 + ctrly2) / 2.0;
 ctrlx1 = (x1 + centerx) / 2.0;
 ctrly1 = (y1 + centery) / 2.0;
 ctrlx2 = (x2 + centerx) / 2.0;
 ctrly2 = (y2 + centery) / 2.0;
 centerx = (ctrlx1 + ctrlx2) / 2.0;
 centery = (ctrly1 + ctrly2) / 2.0;
 if (@left != null) {
     left[leftoff + 2] = x1;
     left[leftoff + 3] = y1;
     left[leftoff + 4] = ctrlx1;
     left[leftoff + 5] = ctrly1;
     left[leftoff + 6] = centerx;
     left[leftoff + 7] = centery;
 }
 if (@right != null) {
     right[rightoff + 0] = centerx;
     right[rightoff + 1] = centery;
     right[rightoff + 2] = ctrlx2;
     right[rightoff + 3] = ctrly2;
     right[rightoff + 4] = x2;
     right[rightoff + 5] = y2;
 }
    }
    /**
     * Solves the cubic whose coefficients are in the <code>eqn</code> 
     * array and places the non-complex roots back into the same array, 
     * returning the number of roots.  The solved cubic is represented 
     * by the equation:
     * <pre>
     *     eqn = {c, b, a, d}
     *     dx^3 + ax^2 + bx + c = 0
     * </pre>
     * A return value of -1 is used to distinguish a constant equation
     * that might be always 0 or never 0 from an equation that has no
     * zeroes.
     * @param eqn an array containing coefficients for a cubic
     * @return the number of roots, or -1 if the equation is a constant.
     * @since 1.2
     */
 int solveCubic(double[]@ eqn) {
 return solveCubic(eqn, eqn);
    }
    /**
     * Solve the cubic whose coefficients are in the <code>eqn</code>
     * array and place the non-complex roots into the <code>res</code>
     * array, returning the number of roots.
     * The cubic solved is represented by the equation:
     *     eqn = {c, b, a, d}
     *     dx^3 + ax^2 + bx + c = 0
     * A return value of -1 is used to distinguish a constant equation,
     * which may be always 0 or never 0, from an equation which has no
     * zeroes.
     * @param eqn the specified array of coefficients to use to solve
     *        the cubic equation
     * @param res the array that contains the non-complex roots 
     *        resulting from the solution of the cubic equation
     * @return the number of roots, or -1 if the equation is a constant
     * @since 1.3
     */
 int solveCubic(double[]@ eqn, double[]@ res) {
 // From Numerical Recipes, 5.6, Quadratic and Cubic Equations
 double d = eqn[3];
 if (d == 0.0) {
     // The cubic has degenerated to quadratic (or line or ...).
     return solveQuadratic(eqn, res);
 }
 double a = eqn[2] / d;
 double b = eqn[1] / d;
 double c = eqn[0] / d;
 int roots = 0;
 double Q = (a * a - 3.0 * b) / 9.0;
 double R = (2.0 * a * a * a - 9.0 * a * b + 27.0 * c) / 54.0;
 double R2 = R * R;
 double Q3 = Q * Q * Q;
 a = a / 3.0;
 if (R2 < Q3) {
     double theta = arc_cosine(R / square_root(Q3));
     Q = -2.0 * square_root(Q);
     if (res == eqn) {
  // Copy the eqn so that we don't clobber it with the
  // roots.  This is needed so that fixRoots can do its
  // work with the original equation.
 double[] temp(4); @eqn=temp;
//  eqn = new double[4];
 arraycopy(res, 0, eqn, 0, 4);
     }
     res[roots++] = Q * cosine(theta / 3.0) - a;
     res[roots++] = Q * cosine((theta + PI * 2.0)/ 3.0) - a;
     res[roots++] = Q * cosine((theta - PI * 2.0)/ 3.0) - a;
     fixRoots(res, eqn);
 } else {
     bool neg = (R < 0.0);
     double S = square_root(R2 - Q3);
     if (neg) {
  R = -R;
     }
     double A = power(R + S, 1.0 / 3.0);
     if (!neg) {
  A = -A;
     }
     double B = (A == 0.0) ? 0.0 : (Q / A);
     res[roots++] = (A + B) - a;
 }
 return roots;
    }
    /*
     * This pruning step is necessary since solveCubic uses the
     * cosine function to calculate the roots when there are 3
     * of them.  Since the cosine method can have an error of
     * +/- 1E-14 we need to make sure that we don't make any
     * bad decisions due to an error.
     * 
     * If the root is not near one of the endpoints, then we will
     * only have a slight inaccuracy in calculating the x intercept
     * which will only cause a slightly wrong answer for some
     * points very close to the curve.  While the results in that
     * case are not as accurate as they could be, they are not
     * disastrously inaccurate either.
     * 
     * On the other hand, if the error happens near one end of
     * the curve, then our processing to reject values outside
     * of the t=[0,1] range will fail and the results of that
     * failure will be disastrous since for an entire horizontal
     * range of test points, we will either overcount or undercount
     * the crossings and get a wrong answer for all of them, even
     * when they are clearly and obviously inside or outside the
     * curve.
     * 
     * To work around this problem, we try a couple of Newton-Raphson
     * iterations to see if the true root is closer to the endpoint
     * or further away.  If it is further away, then we can stop
     * since we know we are on the right side of the endpoint.  If
     * we change direction, then either we are now being dragged away
     * from the endpoint in which case the first condition will cause
     * us to stop, or we have passed the endpoint and are headed back.
     * In the second case, we simply evaluate the slope at the
     * endpoint itself and place ourselves on the appropriate side
     * of it or on it depending on that result.
     */
 void fixRoots(double[]@ res, double[]@ eqn) {
  double EPSILON = 1*power(10, -5);
 for (int i = 0; i < 3; i++) {
     double t = res[i];
     if (math_abs(t) < EPSILON) {
  res[i] = findZero(t, 0, eqn);
     } else if (math_abs(t - 1) < EPSILON) {
  res[i] = findZero(t, 1, eqn);
     }
 }
    }
 double solveEqn(double[]@ eqn, int order, double t) {
 double v = eqn[order];
 while (--order >= 0) {
     v = v * t + eqn[order];
 }
 return v;
    }
 double findZero(double t, double target, double[]@ eqn) {
 double[] slopeqn = {eqn[1], 2*eqn[2], 3*eqn[3]};
 double slope;
 double origdelta = 0;
 double origt = t;
 while (true) {
     slope = solveEqn(slopeqn, 2, t);
     if (slope == 0) {
  // At a local minima - must return
  return t;
     }
     double y = solveEqn(eqn, 3, t);
     if (y == 0) {
  // Found it! - return it
  return t;
     }
     // assert(slope != 0 && y != 0);
     double delta = - (y / slope);
     // assert(delta != 0);
     if (origdelta == 0) {
  origdelta = delta;
     }
     if (t < target) {
  if (delta < 0) return t;
     } else if (t > target) {
  if (delta > 0) return t;
     } else { /* t == target */
  return (delta > 0
   ? (target + MIN_VALUE)
   : (target - MIN_VALUE));
     }
     double newt = t + delta;
     if (t == newt) {
  // The deltas are so small that we aren't moving...
  return t;
     }
     if (delta * origdelta < 0) {
  // We have reversed our path.
  int tag = (origt < t
      ? getTag(target, origt, t)
      : getTag(target, t, origt));
  if (tag != INSIDE) {
      // Local minima found away from target - return the middle
      return (origt + t) / 2;
  }
  // Local minima somewhere near target - move to target
  // and let the slope determine the resulting t.
  t = target;
     } else {
  t = newt;
     }
 }
 return t; // Should be unreachable, if the java was written correctly.
    }


    /**
     * Returns the square of the flatness of the cubic curve specified
     * by the indicated control points. The flatness is the maximum distance 
     * of a control point from the line connecting the end points.
     *
     * @param x1 the X coordinate that specifies the start point
     *           of a {@code CubicCurve2D}
     * @param y1 the Y coordinate that specifies the start point
     *           of a {@code CubicCurve2D}
     * @param ctrlx1 the X coordinate that specifies the first control point
     *               of a {@code CubicCurve2D}
     * @param ctrly1 the Y coordinate that specifies the first control point
     *               of a {@code CubicCurve2D}
     * @param ctrlx2 the X coordinate that specifies the second control point
     *               of a {@code CubicCurve2D}
     * @param ctrly2 the Y coordinate that specifies the second control point
     *               of a {@code CubicCurve2D}
     * @param x2 the X coordinate that specifies the end point
     *           of a {@code CubicCurve2D}
     * @param y2 the Y coordinate that specifies the end point
     *           of a {@code CubicCurve2D}
     * @return the square of the flatness of the {@code CubicCurve2D}
     *  represented by the specified coordinates.
     * @since 1.2
     */
 double CubicCurve2D_getFlatnessSq(double x1, double y1,
           double ctrlx1, double ctrly1,
           double ctrlx2, double ctrly2,
           double x2, double y2) {
 return math_max(Line2D_ptSegDistSq(x1, y1, x2, y2, ctrlx1, ctrly1),
   Line2D_ptSegDistSq(x1, y1, x2, y2, ctrlx2, ctrly2));
   
    }
    /**
     * Returns the flatness of the cubic curve specified
     * by the indicated control points. The flatness is the maximum distance 
     * of a control point from the line connecting the end points.
     *
     * @param x1 the X coordinate that specifies the start point
     *           of a {@code CubicCurve2D}
     * @param y1 the Y coordinate that specifies the start point
     *           of a {@code CubicCurve2D}
     * @param ctrlx1 the X coordinate that specifies the first control point
     *               of a {@code CubicCurve2D}
     * @param ctrly1 the Y coordinate that specifies the first control point
     *               of a {@code CubicCurve2D}
     * @param ctrlx2 the X coordinate that specifies the second control point
     *               of a {@code CubicCurve2D}
     * @param ctrly2 the Y coordinate that specifies the second control point
     *               of a {@code CubicCurve2D}
     * @param x2 the X coordinate that specifies the end point
     *           of a {@code CubicCurve2D}
     * @param y2 the Y coordinate that specifies the end point
     *           of a {@code CubicCurve2D}
     * @return the flatness of the {@code CubicCurve2D}
     *  represented by the specified coordinates.
     * @since 1.2
     */
 double CubicCurve2D_getFlatness(double x1, double y1,
         double ctrlx1, double ctrly1,
         double ctrlx2, double ctrly2,
         double x2, double y2) {
 return square_root(CubicCurve2D_getFlatnessSq(x1, y1, ctrlx1, ctrly1,
           ctrlx2, ctrly2, x2, y2));
    }
    /**
     * Returns the square of the flatness of the cubic curve specified
     * by the control points stored in the indicated array at the 
     * indicated index. The flatness is the maximum distance 
     * of a control point from the line connecting the end points.
     * @param coords an array containing coordinates
     * @param offset the index of <code>coords</code> from which to begin 
     *          getting the end points and control points of the curve
     * @return the square of the flatness of the <code>CubicCurve2D</code>
     *  specified by the coordinates in <code>coords</code> at
     *  the specified offset.
     * @since 1.2
     */
 double CubicCurve2D_getFlatnessSq(double[]@ coords, int offset) {
 return CubicCurve2D_getFlatnessSq(coords[offset + 0], coords[offset + 1],
        coords[offset + 2], coords[offset + 3],
        coords[offset + 4], coords[offset + 5],
        coords[offset + 6], coords[offset + 7]);
    }
    /**
     * Returns the flatness of the cubic curve specified
     * by the control points stored in the indicated array at the 
     * indicated index.  The flatness is the maximum distance 
     * of a control point from the line connecting the end points.
     * @param coords an array containing coordinates
     * @param offset the index of <code>coords</code> from which to begin 
     *          getting the end points and control points of the curve
     * @return the flatness of the <code>CubicCurve2D</code>
     *  specified by the coordinates in <code>coords</code> at
     *  the specified offset.
     * @since 1.2
     */
 double CubicCurve2D_getFlatness(double[]@ coords, int offset) {
 return CubicCurve2D_getFlatness(coords[offset + 0], coords[offset + 1],
      coords[offset + 2], coords[offset + 3],
      coords[offset + 4], coords[offset + 5],
      coords[offset + 6], coords[offset + 7]);
    }



 class CubicCurve2D : Shape {
 /**
  * The X coordinate of the start point
  * of the cubic curve segment.
         * @since 1.2
         * @serial
  */
 double x1;
 /**
  * The Y coordinate of the start point
  * of the cubic curve segment.
         * @since 1.2
         * @serial
  */
 double y1;
 /**
  * The X coordinate of the first control point
  * of the cubic curve segment.
         * @since 1.2
         * @serial
  */
 double ctrlx1;
 /**
  * The Y coordinate of the first control point
  * of the cubic curve segment.
         * @since 1.2
         * @serial
  */
 double ctrly1;
 /**
  * The X coordinate of the second control point
  * of the cubic curve segment.
         * @since 1.2
         * @serial
  */
 double ctrlx2;
 /**
  * The Y coordinate of the second control point
  * of the cubic curve segment.
         * @since 1.2
         * @serial
  */
 double ctrly2;
 /**
  * The X coordinate of the end point
  * of the cubic curve segment.
         * @since 1.2
         * @serial
  */
 double x2;
 /**
  * The Y coordinate of the end point
  * of the cubic curve segment.
         * @since 1.2
         * @serial
  */
 double y2;
 /**
  * Constructs and initializes a CubicCurve with coordinates
  * (0, 0, 0, 0, 0, 0).
         * @since 1.2
  */
 CubicCurve2D() {
 x1=0; x2=0; y1=0; y2=0; ctrlx1=0; ctrlx2=0; ctrly1=0; ctrly2=0;
 }
 /**
         * Constructs and initializes a {@code CubicCurve2D} from
         * the specified {@code double} coordinates.
         *
         * @param x1 the X coordinate for the start point
         *           of the resulting {@code CubicCurve2D}
         * @param y1 the Y coordinate for the start point
         *           of the resulting {@code CubicCurve2D}
         * @param ctrlx1 the X coordinate for the first control point
         *               of the resulting {@code CubicCurve2D}
         * @param ctrly1 the Y coordinate for the first control point
         *               of the resulting {@code CubicCurve2D}
         * @param ctrlx2 the X coordinate for the second control point
         *               of the resulting {@code CubicCurve2D}
         * @param ctrly2 the Y coordinate for the second control point
         *               of the resulting {@code CubicCurve2D}
         * @param x2 the X coordinate for the end point
         *           of the resulting {@code CubicCurve2D}
         * @param y2 the Y coordinate for the end point
         *           of the resulting {@code CubicCurve2D}
         * @since 1.2
  */
 CubicCurve2D(double x1, double y1,
        double ctrlx1, double ctrly1,
        double ctrlx2, double ctrly2,
                      double x2, double y2)
        {
     setCurve(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
 double getX1() {
     return x1;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
 double getY1() {
     return y1;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   vector getP1() {
     return newVector(x1, y1);
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   double getCtrlX1() {
     return ctrlx1;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   double getCtrlY1() {
     return ctrly1;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   vector getCtrlP1() {
     return newVector(ctrlx1, ctrly1);
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   double getCtrlX2() {
     return ctrlx2;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   double getCtrlY2() {
     return ctrly2;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   vector getCtrlP2() {
     return newVector(ctrlx2, ctrly2);
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   double getX2() {
     return x2;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   double getY2() {
     return y2;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   vector getP2() {
     return newVector(x2, y2);
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   void setCurve(double x1, double y1,
        double ctrlx1, double ctrly1,
        double ctrlx2, double ctrly2,
                             double x2, double y2)
        {
     this.x1     = x1;
     this.y1     = y1;
     this.ctrlx1 = ctrlx1;
     this.ctrly1 = ctrly1;
     this.ctrlx2 = ctrlx2;
     this.ctrly2 = ctrly2;
     this.x2     = x2;
     this.y2     = y2;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   Rectangle@ getBounds2D() {
     double left   = math_min(math_min(x1, x2),
         math_min(ctrlx1, ctrlx2));
     double top    = math_min(math_min(y1, y2),
         math_min(ctrly1, ctrly2));
     double right  = math_max(math_max(x1, x2),
         math_max(ctrlx1, ctrlx2));
     double bottom = math_max(math_max(y1, y2),
         math_max(ctrly1, ctrly2));
     return newRectangle(left, top,
       right - left, bottom - top);
 }
      void setCurve(double[] coords, int offset) {
 setCurve(coords[offset + 0], coords[offset + 1],
   coords[offset + 2], coords[offset + 3],
   coords[offset + 4], coords[offset + 5],
   coords[offset + 6], coords[offset + 7]);
    }
    /**
     * Sets the location of the end points and control points of this curve
     * to the specified <code>vector</code> coordinates.
     * @param p1 the first specified <code>vector</code> used to set the
     *  start point of this curve
     * @param cp1 the second specified <code>vector</code> used to set the
     *  first control point of this curve
     * @param cp2 the third specified <code>vector</code> used to set the
     *  second control point of this curve
     * @param p2 the fourth specified <code>vector</code> used to set the
     *  end point of this curve
     * @since 1.2
     */
      void setCurve(vector p1, vector cp1, vector cp2, vector p2) {
 setCurve(p1.x, p1.y, cp1.x, cp1.y,
   cp2.x, cp2.y, p2.x, p2.y);
    }
    /**
     * Sets the location of the end points and control points of this curve
     * to the coordinates of the <code>vector</code> objects at the specified 
     * offset in the specified array.
     * @param pts an array of <code>vector</code> objects
     * @param offset  the index of <code>pts</code> from which to begin setting
     *          the end points and control points of this curve to the 
     *  points contained in <code>pts</code>
     * @since 1.2
     */
      void setCurve(vector[] pts, int offset) {
 setCurve(pts[offset + 0].x, pts[offset + 0].y,
   pts[offset + 1].x, pts[offset + 1].y,
   pts[offset + 2].x, pts[offset + 2].y,
   pts[offset + 3].x, pts[offset + 3].y);
    }
    /**
     * Sets the location of the end points and control points of this curve
     * to the same as those in the specified <code>CubicCurve2D</code>.
     * @param c the specified <code>CubicCurve2D</code>
     * @since 1.2
     */
      void setCurve(CubicCurve2D@ c) {
 setCurve(c.getX1(), c.getY1(), c.getCtrlX1(), c.getCtrlY1(),
   c.getCtrlX2(), c.getCtrlY2(), c.getX2(), c.getY2());
    }
    /**
     * Returns the square of the flatness of this curve.  The flatness is the 
     * maximum distance of a control point from the line connecting the 
     * end points.
     * @return the square of the flatness of this curve.
     * @since 1.2
     */
      double getFlatnessSq() {
 return CubicCurve2D_getFlatnessSq(getX1(), getY1(), getCtrlX1(), getCtrlY1(),
        getCtrlX2(), getCtrlY2(), getX2(), getY2());
    }
    /**
     * Returns the flatness of this curve.  The flatness is the 
     * maximum distance of a control point from the line connecting the 
     * end points.
     * @return the flatness of this curve.
     * @since 1.2
     */
      double getFlatness() {
 return CubicCurve2D_getFlatness(getX1(), getY1(), getCtrlX1(), getCtrlY1(),
      getCtrlX2(), getCtrlY2(), getX2(), getY2());
    }
    /**
     * Subdivides this cubic curve and stores the resulting two
     * subdivided curves into the left and right curve parameters.
     * Either or both of the left and right objects may be the same
     * as this object or null.
     * @param left the cubic curve object for storing for the left or
     * first half of the subdivided curve
     * @param right the cubic curve object for storing for the right or
     * second half of the subdivided curve
     * @since 1.2
     */
      void subdivide(CubicCurve2D@ left, CubicCurve2D@ right) {
 CubicCurve2D_subdivide(this, left, right);
    }
    /**
     * {@inheritDoc}
     * @since 1.2
     */
      bool contains(double x, double y) {
        if (!(x * 0.0 + y * 0.0 == 0.0)) {
            /* Either x or y was infinite or NaN.
             * A NaN always produces a negative response to any test
             * and Infinity values cannot be "inside" any path so
             * they should return false as well.
             */
            return false;
        }
 // We count the "Y" crossings to determine if the point is
 // inside the curve bounded by its closing line.
 double x1 = getX1();
 double y1 = getY1();
 double x2 = getX2();
 double y2 = getY2();
/* int crossings =
   (Curve_pointCrossingsForLine(x, y, x1, y1, x2, y2) +
   Curve_pointCrossingsForCubic(x, y,
                                          x1, y1,
                                          getCtrlX1(), getCtrlY1(),
                                          getCtrlX2(), getCtrlY2(),
                                          x2, y2, 0));
 return ((crossings & 1) == 1);
*/
  return ((x==x1)||(x==x2))&&((y==y1)||(y==y2));
    }

    /**
     * {@inheritDoc}
     * @since 1.2
     */
      bool contains(vector p) {
 return contains(p.x, p.y);
    }


    /*
     * Fill an array with the coefficients of the parametric equation
     * in t, ready for solving against val with solveCubic.
     * We currently have:
     * <pre>
     *   val = P(t) = C1(1-t)^3 + 3CP1 t(1-t)^2 + 3CP2 t^2(1-t) + C2 t^3
     *              = C1 - 3C1t + 3C1t^2 - C1t^3 +
     *                3CP1t - 6CP1t^2 + 3CP1t^3 +
     *                3CP2t^2 - 3CP2t^3 +
     *                C2t^3
     *            0 = (C1 - val) +
     *                (3CP1 - 3C1) t +
     *                (3C1 - 6CP1 + 3CP2) t^2 +
     *                (C2 - 3CP2 + 3CP1 - C1) t^3
     *            0 = C + Bt + At^2 + Dt^3
     *     C = C1 - val
     *     B = 3*CP1 - 3*C1
     *     A = 3*CP2 - 6*CP1 + 3*C1
     *     D = C2 - 3*CP2 + 3*CP1 - C1
     * </pre>
     */
 void fillEqn(double[]@ eqn, double val,
    double c1, double cp1, double cp2, double c2) {
 eqn[0] = c1 - val;
 eqn[1] = (cp1 - c1) * 3.0;
 eqn[2] = (cp2 - cp1 - cp1 + c1) * 3.0;
 eqn[3] = c2 + (cp1 - cp2) * 3.0 - c1;
 return;
    }
    /*
     * Evaluate the t values in the first num slots of the vals[] array
     * and place the evaluated values back into the same array.  Only
     * evaluate t values that are within the range <0, 1>, including
     * the 0 and 1 ends of the range iff the include0 or include1
     * bools are true.  If an "inflection" equation is handed in,
     * then any points which represent a point of inflection for that
     * cubic equation are also ignored.
     */
 int evalCubic(double[]@ vals, int num,
     bool include0,
     bool include1,
     double[]@ inflect,
     double c1, double cp1,
     double cp2, double c2) {
 int j = 0;
 for (int i = 0; i < num; i++) {
     double t = vals[i];
     if ((include0 ? t >= 0 : t > 0) &&
  (include1 ? t <= 1 : t < 1) &&
  (@inflect == null ||
   inflect[1] + (2*inflect[2] + 3*inflect[3]*t)*t != 0))
     {
  double u = 1 - t;
  vals[j++] = c1*u*u*u + 3*cp1*t*u*u + 3*cp2*t*t*u + c2*t*t*t;
     }
 }
 return j;
    }
//    private static final int BELOW = -2;
//    private static final int LOWEDGE = -1;
//    private static final int INSIDE = 0;
//    private static final int HIGHEDGE = 1;
//    private static final int ABOVE = 2;
    /*
     * Determine where coord lies with respect to the range from
     * low to high.  It is assumed that low <= high.  The return
     * value is one of the 5 values BELOW, LOWEDGE, INSIDE, HIGHEDGE,
     * or ABOVE.
     */
 int getTag(double coord, double low, double high) {
 if (coord <= low) {
     return (coord < low ? BELOW : LOWEDGE);
 }
 if (coord >= high) {
     return (coord > high ? ABOVE : HIGHEDGE);
 }
 return INSIDE;
    }
    /*
     * Determine if the pttag represents a coordinate that is already
     * in its test range, or is on the border with either of the two
     * opttags representing another coordinate that is "towards the
     * inside" of that test range.  In other words, are either of the
     * two "opt" points "drawing the pt inward"?
     */
 bool inwards(int pttag, int opt1tag, int opt2tag) {
 switch (pttag) {
 case BELOW:
 case ABOVE:
{
     return false;
}
 case LOWEDGE: {
     return (opt1tag >= INSIDE || opt2tag >= INSIDE);
}
 case INSIDE:
{
     return true;
}
 case HIGHEDGE:
{     return (opt1tag <= INSIDE || opt2tag <= INSIDE);}
 default : return false;
 }
 return false;
    }

    /**
     * {@inheritDoc}
     * @since 1.2
     */
      bool intersects(double x, double y, double w, double h) {
 // Trivially reject non-existant rectangles
 if (w <= 0 || h <= 0) {
     return false;
 }
 // Trivially accept if either endpoint is inside the rectangle
 // (not on its border since it may end there and not go inside)
 // Record where they lie with respect to the rectangle.
 //     -1 => left, 0 => inside, 1 => right
 double x1 = getX1();
 double y1 = getY1();
 int x1tag = getTag(x1, x, x+w);
 int y1tag = getTag(y1, y, y+h);
 if (x1tag == INSIDE && y1tag == INSIDE) {
     return true;
 }
 double x2 = getX2();
 double y2 = getY2();
 int x2tag = getTag(x2, x, x+w);
 int y2tag = getTag(y2, y, y+h);
 if (x2tag == INSIDE && y2tag == INSIDE) {
     return true;
 }
 double ctrlx1 = getCtrlX1();
 double ctrly1 = getCtrlY1();
 double ctrlx2 = getCtrlX2();
 double ctrly2 = getCtrlY2();
 int ctrlx1tag = getTag(ctrlx1, x, x+w);
 int ctrly1tag = getTag(ctrly1, y, y+h);
 int ctrlx2tag = getTag(ctrlx2, x, x+w);
 int ctrly2tag = getTag(ctrly2, y, y+h);
 // Trivially reject if all points are entirely to one side of
 // the rectangle.
 if (x1tag < INSIDE && x2tag < INSIDE &&
     ctrlx1tag < INSIDE && ctrlx2tag < INSIDE)
 {
     return false; // All points left
 }
 if (y1tag < INSIDE && y2tag < INSIDE &&
     ctrly1tag < INSIDE && ctrly2tag < INSIDE)
 {
     return false; // All points above
 }
 if (x1tag > INSIDE && x2tag > INSIDE &&
     ctrlx1tag > INSIDE && ctrlx2tag > INSIDE)
 {
     return false; // All points right
 }
 if (y1tag > INSIDE && y2tag > INSIDE &&
     ctrly1tag > INSIDE && ctrly2tag > INSIDE)
 {
     return false; // All points below
 }
 // Test for endpoints on the edge where either the segment
 // or the curve is headed "inwards" from them
 // Note: These tests are a superset of the fast endpoint tests
 //       above and thus repeat those tests, but take more time
 //       and cover more cases
 if (inwards(x1tag, x2tag, ctrlx1tag) &&
     inwards(y1tag, y2tag, ctrly1tag))
 {
     // First endpoint on border with either edge moving inside
     return true;
 }
 if (inwards(x2tag, x1tag, ctrlx2tag) &&
     inwards(y2tag, y1tag, ctrly2tag))
 {
     // Second endpoint on border with either edge moving inside
     return true;
 }
 // Trivially accept if endpoints span directly across the rectangle
 bool xoverlap = (x1tag * x2tag <= 0);
 bool yoverlap = (y1tag * y2tag <= 0);
 if (x1tag == INSIDE && x2tag == INSIDE && yoverlap) {
     return true;
 }
 if (y1tag == INSIDE && y2tag == INSIDE && xoverlap) {
     return true;
 }
 // We now know that both endpoints are outside the rectangle
 // but the 4 points are not all on one side of the rectangle.
 // Therefore the curve cannot be contained inside the rectangle,
 // but the rectangle might be contained inside the curve, or
 // the curve might intersect the boundary of the rectangle.
 double[] eqn (4);
 double[] res (4);
 if (!yoverlap) {
     // Both y coordinates for the closing segment are above or
     // below the rectangle which means that we can only intersect
     // if the curve crosses the top (or bottom) of the rectangle
     // in more than one place and if those crossing locations
     // span the horizontal range of the rectangle.
     fillEqn(eqn, (y1tag < INSIDE ? y : y+h), y1, ctrly1, ctrly2, y2);
     int num = solveCubic(eqn, res);
     num = evalCubic(res, num, true, true, null,
       x1, ctrlx1, ctrlx2, x2);
     // odd counts imply the crossing was out of [0,1] bounds
     // otherwise there is no way for that part of the curve to
     // "return" to meet its endpoint
     return (num == 2 &&
      getTag(res[0], x, x+w) * getTag(res[1], x, x+w) <= 0);
 }
 // Y ranges overlap.  Now we examine the X ranges
 if (!xoverlap) {
     // Both x coordinates for the closing segment are left of
     // or right of the rectangle which means that we can only
     // intersect if the curve crosses the left (or right) edge
     // of the rectangle in more than one place and if those
     // crossing locations span the vertical range of the rectangle.
     fillEqn(eqn, (x1tag < INSIDE ? x : x+w), x1, ctrlx1, ctrlx2, x2);
     int num = solveCubic(eqn, res);
     num = evalCubic(res, num, true, true, null,
       y1, ctrly1, ctrly2, y2);
     // odd counts imply the crossing was out of [0,1] bounds
     // otherwise there is no way for that part of the curve to
     // "return" to meet its endpoint
     return (num == 2 &&
      getTag(res[0], y, y+h) * getTag(res[1], y, y+h) <= 0);
 }
 // The X and Y ranges of the endpoints overlap the X and Y
 // ranges of the rectangle, now find out how the endpoint
 // line segment intersects the Y range of the rectangle
 double dx = x2 - x1;
 double dy = y2 - y1;
 double k = y2 * x1 - x2 * y1;
 int c1tag, c2tag;
 if (y1tag == INSIDE) {
     c1tag = x1tag;
 } else {
     c1tag = getTag((k + dx * (y1tag < INSIDE ? y : y+h)) / dy, x, x+w);
 }
 if (y2tag == INSIDE) {
     c2tag = x2tag;
 } else {
     c2tag = getTag((k + dx * (y2tag < INSIDE ? y : y+h)) / dy, x, x+w);
 }
 // If the part of the line segment that intersects the Y range
 // of the rectangle crosses it horizontally - trivially accept
 if (c1tag * c2tag <= 0) {
     return true;
 }
 // Now we know that both the X and Y ranges intersect and that
 // the endpoint line segment does not directly cross the rectangle.
 //
 // We can almost treat this case like one of the cases above
 // where both endpoints are to one side, except that we may
 // get one or three intersections of the curve with the vertical
 // side of the rectangle.  This is because the endpoint segment
 // accounts for the other intersection in an even pairing.  Thus,
 // with the endpoint crossing we end up with 2 or 4 total crossings.
 //
 // (Remember there is overlap in both the X and Y ranges which
 //  means that the segment itself must cross at least one vertical
 //  edge of the rectangle - in particular, the "near vertical side"
 //  - leaving an odd number of intersections for the curve.)
 //
 // Now we calculate the y tags of all the intersections on the
 // "near vertical side" of the rectangle.  We will have one with
 // the endpoint segment, and one or three with the curve.  If
 // any pair of those vertical intersections overlap the Y range
 // of the rectangle, we have an intersection.  Otherwise, we don't.
 // c1tag = vertical intersection class of the endpoint segment
 //
 // Choose the y tag of the endpoint that was not on the same
 // side of the rectangle as the subsegment calculated above.
 // Note that we can "steal" the existing Y tag of that endpoint
 // since it will be provably the same as the vertical intersection.
 c1tag = ((c1tag * x1tag <= 0) ? y1tag : y2tag);
 // Now we have to calculate an array of solutions of the curve
 // with the "near vertical side" of the rectangle.  Then we
 // need to sort the tags and do a pairwise range test to see
 // if either of the pairs of crossings spans the Y range of
 // the rectangle.
 //
 // Note that the c2tag can still tell us which vertical edge
 // to test against.
 fillEqn(eqn, (c2tag < INSIDE ? x : x+w), x1, ctrlx1, ctrlx2, x2);
 int num = solveCubic(eqn, res);
 num = evalCubic(res, num, true, true, null, y1, ctrly1, ctrly2, y2);
 // Now put all of the tags into a bucket and sort them.  There
 // is an intersection iff one of the pairs of tags "spans" the
 // Y range of the rectangle.
 int[] tags(num+1);
 for (int i = 0; i < num; i++) {
     tags[i] = getTag(res[i], y, y+h);
 }
 tags[num] = c1tag;
 Arrays_sort(tags);
 return ((num >= 1 && tags[0] * tags[1] <= 0) ||
  (num >= 3 && tags[2] * tags[3] <= 0));
    }
    /**
     * {@inheritDoc}
     * @since 1.2
     */
      bool intersects(Rectangle@ r) {
 return intersects(r.x, r.y, r.width, r.height);
    }
    /**
     * {@inheritDoc}
     * @since 1.2
     */
      bool contains(double x, double y, double w, double h) {
        if (w <= 0 || h <= 0) {
            return false;
        }
 // Assertion: Cubic curves closed by connecting their
 // endpoints form either one or two convex halves with
 // the closing line segment as an edge of both sides.
 if (!(contains(x, y) &&
       contains(x + w, y) &&
       contains(x + w, y + h) &&
       contains(x, y + h))) {
     return false;
 }
 // Either the rectangle is entirely inside one of the convex
 // halves or it crosses from one to the other, in which case
 // it must intersect the closing line segment.
 Rectangle@ rect = newRectangle(x, y, w, h);
 return !rect.intersectsLine(getX1(), getY1(), getX2(), getY2());
    }
    /**
     * {@inheritDoc}
     * @since 1.2
     */
      bool contains(Rectangle@ r) {
 return contains(r.x, r.y, r.width, r.height);
    }
    /**
     * {@inheritDoc}
     * @since 1.2
     */
      Rectangle@ getBounds() {
 return getBounds2D().getBounds();
    }
    /**
     * Returns an iteration object that defines the boundary of the
     * shape.
     * The iterator for this class is not multi-threaded safe,
     * which means that this <code>CubicCurve2D</code> class does not
     * guarantee that modifications to the geometry of this
     * <code>CubicCurve2D</code> object do not affect any iterations of
     * that geometry that are already in process.
     * @param at an optional <code>AffineTransform</code> to be applied to the
     * coordinates as they are returned in the iteration, or <code>null</code>
     * if untransformed coordinates are desired
     * @return    the <code>PathIterator</code> object that returns the
     *          geometry of the outline of this <code>CubicCurve2D</code>, one
     *          segment at a time.
     * @since 1.2
     */
      PathIterator@ getPathIterator(AffineTransform@ at) {
 return newCubicIterator(this, at);
    }
    /**
     * Return an iteration object that defines the boundary of the
     * flattened shape.
     * The iterator for this class is not multi-threaded safe,
     * which means that this <code>CubicCurve2D</code> class does not
     * guarantee that modifications to the geometry of this
     * <code>CubicCurve2D</code> object do not affect any iterations of
     * that geometry that are already in process.
     * @param at an optional <code>AffineTransform</code> to be applied to the
     * coordinates as they are returned in the iteration, or <code>null</code>
     * if untransformed coordinates are desired
     * @param flatness the maximum amount that the control points
     * for a given curve can vary from colinear before a subdivided
     * curve is replaced by a straight line connecting the end points
     * @return    the <code>PathIterator</code> object that returns the
     * geometry of the outline of this <code>CubicCurve2D</code>,
     * one segment at a time.
     * @since 1.2
     */
      PathIterator@ getPathIterator(AffineTransform@ at, double flatness) {
// return new FlatteningPathIterator(getPathIterator(at), flatness);
 CubicIterator ci(this, at);
 return newFlatteningPathIterator(ci, flatness);
    }
    /**
     * Creates a new object of the same class as this object.
     *
     * @return     a clone of this instance.
     * @exception  OutOfMemoryError            if there is not enough memory.
     * @see        java.lang.Cloneable
     * @since      1.2
     */
 CubicCurve2D@ clone() {
 CubicCurve2D ret(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
 return ret;
    }
 Shape@ translate(double dx, double dy) {
 CubicCurve2D ret(x1+dx, y1+dy, ctrlx1+dx, ctrly1+dy, ctrlx2+dx, ctrly2+dy, x2+dx, y2+dy);
 return ret;

}
 Shape@ rotate(double theta) {
 return rotate((x1+x2)/2, (y1+y2)/2, theta);
}
 Shape@ rotate(double cx, double cy, double theta) {return rotate(newVector(cx, cy), theta);}
 Shape@ rotate(vector v, double theta) {
 vector p1(x1, y1); p1= ::rotate(p1, v, theta);
 vector p2(x2, y2); p2= ::rotate(p2, v, theta);
 vector c1(ctrlx1, ctrly1); c1= ::rotate(c1, v, theta);
 vector c2(ctrlx2, ctrly2); c2= ::rotate(c2, v, theta);
 CubicCurve2D ret(p1.x, p1.y, c1.x, c1.y, c2.x, c2.y, p2.x, p2.y);
 return ret;
}// Meh.
 Shape@ mirrorX() {
 CubicCurve2D ret(-x1, y1, -ctrlx1, ctrly1, -ctrlx2, ctrly2, -x2, y2); return ret;
}
 Shape@ mirrorY() {
 CubicCurve2D ret(x1, -y1, ctrlx1, -ctrly1, ctrlx2, -ctrly2, x2, -y2); return ret;
}
}

CubicCurve2D@ newCubicCurve2D(double x1, double y1, double ctrlx1, double ctrly1, double ctrlx2, double ctrly2, double x2, double y2) {CubicCurve2D ret(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2); return ret;}

//double Line2D_ptSegDistSq(double a, double b, double c, double d, double e, double f) {return a+b+c+d+e+f;}
//double Line2D_ptSegDist(double a, double b, double c, double d, double e, double f) {return a+b+c+d+e+f;}

void Arrays_sort(int[]@ a) {

 }// Array sorting.
    /**
     * Returns the square of the distance from a point to a line.
     * The distance measured is the distance between the specified
     * point and the closest point on the infinitely-extended line
     * defined by the specified coordinates.  If the specified point 
     * intersects the line, this method returns 0.0.
     *
     * @param x1 the X coordinate of the start point of the specified line
     * @param y1 the Y coordinate of the start point of the specified line
     * @param x2 the X coordinate of the end point of the specified line
     * @param y2 the Y coordinate of the end point of the specified line
     * @param px the X coordinate of the specified point being
     *           measured against the specified line
     * @param py the Y coordinate of the specified point being
     *           measured against the specified line
     * @return a double value that is the square of the distance from the
     *   specified point to the specified line.
     * @see #ptSegDistSq(double, double, double, double, double, double)
     * @since 1.2
     */
 double Line2D_ptLineDistSq(double x1, double y1,
          double x2, double y2,
          double px, double py)
    {
 // Adjust vectors relative to x1,y1
 // x2,y2 becomes relative vector from x1,y1 to end of segment
 x2 -= x1;
 y2 -= y1;
 // px,py becomes relative vector from x1,y1 to test point
 px -= x1;
 py -= y1;
 double dotprod = px * x2 + py * y2;
 // dotprod is the length of the px,py vector
 // projected on the x1,y1=>x2,y2 vector times the
 // length of the x1,y1=>x2,y2 vector
 double projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);
 // Distance to line is now the length of the relative point
 // vector minus the length of its projection onto the line
 double lenSq = px * px + py * py - projlenSq;
 if (lenSq < 0) {
     lenSq = 0;
 }
 return lenSq;
    }
    /**
     * Returns the distance from a point to a line.
     * The distance measured is the distance between the specified
     * point and the closest point on the infinitely-extended line
     * defined by the specified coordinates.  If the specified point 
     * intersects the line, this method returns 0.0.
     *
     * @param x1 the X coordinate of the start point of the specified line
     * @param y1 the Y coordinate of the start point of the specified line
     * @param x2 the X coordinate of the end point of the specified line
     * @param y2 the Y coordinate of the end point of the specified line
     * @param px the X coordinate of the specified point being
     *           measured against the specified line
     * @param py the Y coordinate of the specified point being
     *           measured against the specified line
     * @return a double value that is the distance from the specified
     *    point to the specified line.
     * @see #ptSegDist(double, double, double, double, double, double)
     * @since 1.2
     */
 double Line2D_ptLineDist(double x1, double y1,
        double x2, double y2,
        double px, double py)
    {
 return square_root(Line2D_ptLineDistSq(x1, y1, x2, y2, px, py));
    }


    /**
     * Returns the square of the distance from a point to a line segment.
     * The distance measured is the distance between the specified
     * point and the closest point between the specified end points.  
     * If the specified point intersects the line segment in between the
     * end points, this method returns 0.0.     
     *
     * @param x1 the X coordinate of the start point of the
     *           specified line segment
     * @param y1 the Y coordinate of the start point of the
     *           specified line segment
     * @param x2 the X coordinate of the end point of the
     *           specified line segment
     * @param y2 the Y coordinate of the end point of the
     *           specified line segment
     * @param px the X coordinate of the specified point being
     *           measured against the specified line segment
     * @param py the Y coordinate of the specified point being
     *           measured against the specified line segment
     * @return a double value that is the square of the distance from the
     *   specified point to the specified line segment.
     * @see #ptLineDistSq(double, double, double, double, double, double)
     * @since 1.2
     */
 double Line2D_ptSegDistSq(double x1, double y1,
         double x2, double y2,
         double px, double py)
    {
 // Adjust vectors relative to x1,y1
 // x2,y2 becomes relative vector from x1,y1 to end of segment
 x2 -= x1;
 y2 -= y1;
 // px,py becomes relative vector from x1,y1 to test point
 px -= x1;
 py -= y1;
 double dotprod = px * x2 + py * y2;
 double projlenSq;
 if (dotprod <= 0.0) {
     // px,py is on the side of x1,y1 away from x2,y2
     // distance to segment is length of px,py vector
     // "length of its (clipped) projection" is now 0.0
     projlenSq = 0.0;
 } else {
     // switch to backwards vectors relative to x2,y2
     // x2,y2 are already the negative of x1,y1=>x2,y2
     // to get px,py to be the negative of px,py=>x2,y2
     // the dot product of two negated vectors is the same
     // as the dot product of the two normal vectors
     px = x2 - px;
     py = y2 - py;
     dotprod = px * x2 + py * y2;
     if (dotprod <= 0.0) {
  // px,py is on the side of x2,y2 away from x1,y1
  // distance to segment is length of (backwards) px,py vector
  // "length of its (clipped) projection" is now 0.0
  projlenSq = 0.0;
     } else {
  // px,py is between x1,y1 and x2,y2
  // dotprod is the length of the px,py vector
  // projected on the x2,y2=>x1,y1 vector times the
  // length of the x2,y2=>x1,y1 vector
  projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);
     }
 }
 // Distance to line is now the length of the relative point
 // vector minus the length of its projection onto the line
 // (which is zero if the projection falls outside the range
 //  of the line segment).
 double lenSq = px * px + py * py - projlenSq;
 if (lenSq < 0) {
     lenSq = 0;
 }
 return lenSq;
    }
    /**
     * Returns the distance from a point to a line segment.
     * The distance measured is the distance between the specified
     * point and the closest point between the specified end points.  
     * If the specified point intersects the line segment in between the
     * end points, this method returns 0.0.
     *
     * @param x1 the X coordinate of the start point of the
     *           specified line segment
     * @param y1 the Y coordinate of the start point of the
     *           specified line segment
     * @param x2 the X coordinate of the end point of the
     *           specified line segment
     * @param y2 the Y coordinate of the end point of the
     *           specified line segment
     * @param px the X coordinate of the specified point being
     *           measured against the specified line segment
     * @param py the Y coordinate of the specified point being
     *           measured against the specified line segment
     * @return a double value that is the distance from the specified point
     *    to the specified line segment.
     * @see #ptLineDist(double, double, double, double, double, double)
     * @since 1.2
     */
 double Line2D_ptSegDist(double x1, double y1,
       double x2, double y2,
       double px, double py)
    {
 return square_root(Line2D_ptSegDistSq(x1, y1, x2, y2, px, py));
    }


    /**
     * Tests if the line segment from {@code (x1,y1)} to 
     * {@code (x2,y2)} intersects the line segment from {@code (x3,y3)} 
     * to {@code (x4,y4)}.
     *
     * @param x1 the X coordinate of the start point of the first
     *           specified line segment
     * @param y1 the Y coordinate of the start point of the first
     *           specified line segment
     * @param x2 the X coordinate of the end point of the first
     *           specified line segment
     * @param y2 the Y coordinate of the end point of the first
     *           specified line segment
     * @param x3 the X coordinate of the start point of the second
     *           specified line segment
     * @param y3 the Y coordinate of the start point of the second
     *           specified line segment
     * @param x4 the X coordinate of the end point of the second
     *           specified line segment
     * @param y4 the Y coordinate of the end point of the second
     *           specified line segment
     * @return <code>true</code> if the first specified line segment 
     *   and the second specified line segment intersect  
     *   each other; <code>false</code> otherwise.  
     * @since 1.2
     */
 bool linesIntersect(double x1, double y1,
      double x2, double y2,
      double x3, double y3,
      double x4, double y4)
    {
 return ((Line2D_relativeCCW(x1, y1, x2, y2, x3, y3) *
   Line2D_relativeCCW(x1, y1, x2, y2, x4, y4) <= 0)
  && (Line2D_relativeCCW(x3, y3, x4, y4, x1, y1) *
      Line2D_relativeCCW(x3, y3, x4, y4, x2, y2) <= 0));
    }


    /**
     * Returns an indicator of where the specified point      * {@code (px,py)} lies with respect to the line segment from      * {@code (x1,y1)} to {@code (x2,y2)}.
     * The return value can be either 1, -1, or 0 and indicates     * in which direction the specified line must pivot around its     * first end point, {@code (x1,y1)}, in order to point at the     * specified point {@code (px,py)}.
     * <p>A return value of 1 indicates that the line segment must     * turn in the direction that takes the positive X axis towards     * the negative Y axis.  In the default coordinate system used by     * Java 2D, this direction is counterclockwise.  
     * <p>A return value of -1 indicates that the line segment must     * turn in the direction that takes the positive X axis towards     * the positive Y axis.  In the default coordinate system, this      * direction is clockwise.
     * <p>A return value of 0 indicates that the point lies     * exactly on the line segment.  Note that an indicator value      * of 0 is rare and not useful for determining colinearity      * because of floating point rounding issues. 
     * <p>If the point is colinear with the line segment, but      * not between the end points, then the value will be -1 if the point     * lies "beyond {@code (x1,y1)}" or 1 if the point lies      * "beyond {@code (x2,y2)}".
     *
     * @param x1 the X coordinate of the start point of the     *           specified line segment
     * @param y1 the Y coordinate of the start point of the     *           specified line segment
     * @param x2 the X coordinate of the end point of the     *           specified line segment
     * @param y2 the Y coordinate of the end point of the     *           specified line segment
     * @param px the X coordinate of the specified point to be     *           compared with the specified line segment
     * @param py the Y coordinate of the specified point to be     *           compared with the specified line segment
     * @return an integer that indicates the position of the third specified     *   coordinates with respect to the line segment formed     *   by the first two specified coordinates.
     * @since 1.2
     */
 int Line2D_relativeCCW(double x1, double y1,
      double x2, double y2,
      double px, double py)
    {
 x2 -= x1;
 y2 -= y1;
 px -= x1;
 py -= y1;
 double ccw = px * y2 - py * x2;
 if (ccw == 0.0) {
     // The point is colinear, classify based on which side of
     // the segment the point falls on.  We can calculate a
     // relative value using the projection of px,py onto the
     // segment - a negative value indicates the point projects
     // outside of the segment in the direction of the particular
     // endpoint used as the origin for the projection.
     ccw = px * x2 + py * y2;
     if (ccw > 0.0) {
  // Reverse the projection to be relative to the original x2,y2
  // x2 and y2 are simply negated.
  // px and py need to have (x2 - x1) or (y2 - y1) subtracted
  //    from them (based on the original values)
  // Since we really want to get a positive answer when the
  //    point is "beyond (x2,y2)", then we want to calculate
  //    the inverse anyway - thus we leave x2 & y2 negated.
  px -= x2;
  py -= y2;
  ccw = px * x2 + py * y2;
  if (ccw < 0.0) {
      ccw = 0.0;
  }
     }
 }
 return (ccw < 0.0) ? -1 : ((ccw > 0.0) ? 1 : 0);
    }



class Line2D : Shape {

 /**
  * The X coordinate of the start point of the line segment.
         * @since 1.2
         * @serial
  */
 double x1;
 /**
  * The Y coordinate of the start point of the line segment.
         * @since 1.2
         * @serial
  */
   double y1;
 /**
  * The X coordinate of the end point of the line segment.
         * @since 1.2
         * @serial
  */
   double x2;
 /**
  * The Y coordinate of the end point of the line segment.
         * @since 1.2
         * @serial
  */
   double y2;
 /**
  * Constructs and initializes a Line with coordinates (0, 0) -> (0, 0).
         * @since 1.2
  */
 Line2D() {
 x1=0; y1=0; x2=0; y2=0;
 }
 /**
  * Constructs and initializes a <code>Line2D</code> from the
         * specified coordinates.
  * @param x1 the X coordinate of the start point
  * @param y1 the Y coordinate of the start point
  * @param x2 the X coordinate of the end point
  * @param y2 the Y coordinate of the end point
         * @since 1.2
  */
 Line2D(double x1, double y1, double x2, double y2) {
     setLine(x1, y1, x2, y2);
 }
 /**
  * Constructs and initializes a <code>Line2D</code> from the
  * specified <code>vector</code> objects.
  * @param p1 the start <code>vector</code> of this line segment
  * @param p2 the end <code>vector</code> of this line segment
         * @since 1.2
  */
 Line2D(vector p1, vector p2) {
     setLine(p1, p2);
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   double getX1() {
     return x1;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   double getY1() {
     return y1;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   vector getP1() {
     return newVector(x1, y1);
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   double getX2() {
     return x2;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   double getY2() {
     return y2;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   vector getP2() {
     return newVector(x2, y2);
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   void setLine(double x1, double y1, double x2, double y2) {
     this.x1 = x1;
     this.y1 = y1;
     this.x2 = x2;
     this.y2 = y2;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   Rectangle@ getBounds2D() {
     double x, y, w, h;
     if (x1 < x2) {
  x = x1;
  w = x2 - x1;
     } else {
  x = x2;
  w = x1 - x2;
     }
     if (y1 < y2) {
  y = y1;
  h = y2 - y1;
     } else {
  y = y2;
  h = y1 - y2;
     }
     return newRectangle(x, y, w, h);
 }
      void setLine(vector p1, vector p2) {
 setLine(p1.x, p1.y, p2.x, p2.y);
    }
    /**
     * Sets the location of the end points of this <code>Line2D</code> to
     * the same as those end points of the specified <code>Line2D</code>.
     * @param l the specified <code>Line2D</code>
     * @since 1.2
     */
      void setLine(Line2D l) {
 setLine(l.getX1(), l.getY1(), l.getX2(), l.getY2());
    }

    /**
     * Returns an indicator of where the specified point 
     * {@code (px,py)} lies with respect to this line segment.
     * See the method comments of 
     * {@link #relativeCCW(double, double, double, double, double, double)}
     * to interpret the return value.
     * @param px the X coordinate of the specified point
     *           to be compared with this <code>Line2D</code>
     * @param py the Y coordinate of the specified point
     *           to be compared with this <code>Line2D</code>
     * @return an integer that indicates the position of the specified
     *         coordinates with respect to this <code>Line2D</code>
     * @see #relativeCCW(double, double, double, double, double, double)
     * @since 1.2
     */
      int relativeCCW(double px, double py) {
 return Line2D_relativeCCW(getX1(), getY1(), getX2(), getY2(), px, py);
    }
    /**
     * Returns an indicator of where the specified <code>vector</code>
     * lies with respect to this line segment.
     * See the method comments of
     * {@link #relativeCCW(double, double, double, double, double, double)}
     * to interpret the return value.
     * @param p the specified <code>vector</code> to be compared 
     *          with this <code>Line2D</code>
     * @return an integer that indicates the position of the specified
     *         <code>vector</code> with respect to this <code>Line2D</code>
     * @see #relativeCCW(double, double, double, double, double, double)
     * @since 1.2
     */
      int relativeCCW(vector p) {
 return Line2D_relativeCCW(getX1(), getY1(), getX2(), getY2(),
      p.x, p.y);
    }
    /**
     * Tests if the line segment from {@code (x1,y1)} to 
     * {@code (x2,y2)} intersects this line segment.
     *
     * @param x1 the X coordinate of the start point of the
     *           specified line segment
     * @param y1 the Y coordinate of the start point of the
     *           specified line segment
     * @param x2 the X coordinate of the end point of the
     *           specified line segment
     * @param y2 the Y coordinate of the end point of the
     *           specified line segment
     * @return <true> if this line segment and the specified line segment
     *   intersect each other; <code>false</code> otherwise.
     * @since 1.2
     */
      bool intersectsLine(double x1, double y1, double x2, double y2) {
 return linesIntersect(x1, y1, x2, y2,
         getX1(), getY1(), getX2(), getY2());
    }
    /**
     * Tests if the specified line segment intersects this line segment.
     * @param l the specified <code>Line2D</code>
     * @return <code>true</code> if this line segment and the specified line
     *   segment intersect each other; 
     *   <code>false</code> otherwise.
     * @since 1.2
     */
      bool intersectsLine(Line2D l) {
 return linesIntersect(l.getX1(), l.getY1(), l.getX2(), l.getY2(),
         getX1(), getY1(), getX2(), getY2());
    }
    /**
     * Returns the square of the distance from a point to this line segment.
     * The distance measured is the distance between the specified
     * point and the closest point between the current line's end points.  
     * If the specified point intersects the line segment in between the
     * end points, this method returns 0.0.
     *
     * @param px the X coordinate of the specified point being
     *           measured against this line segment
     * @param py the Y coordinate of the specified point being
     *           measured against this line segment
     * @return a double value that is the square of the distance from the
     *   specified point to the current line segment.
     * @see #ptLineDistSq(double, double)
     * @since 1.2
     */
      double ptSegDistSq(double px, double py) {
 return Line2D_ptSegDistSq(getX1(), getY1(), getX2(), getY2(), px, py);
    }
    /**
     * Returns the square of the distance from a <code>vector</code> to 
     * this line segment.
     * The distance measured is the distance between the specified
     * point and the closest point between the current line's end points.  
     * If the specified point intersects the line segment in between the
     * end points, this method returns 0.0.
     * @param pt the specified <code>vector</code> being measured against
     *          this line segment.
     * @return a double value that is the square of the distance from the
     *   specified <code>vector</code> to the current 
     *   line segment.
     * @see #ptLineDistSq(vector)
     * @since 1.2
     */
      double ptSegDistSq(vector pt) {
 return Line2D_ptSegDistSq(getX1(), getY1(), getX2(), getY2(),
      pt.x, pt.y);
    }
    /**
     * Returns the distance from a point to this line segment.
     * The distance measured is the distance between the specified
     * point and the closest point between the current line's end points.  
     * If the specified point intersects the line segment in between the
     * end points, this method returns 0.0.
     *
     * @param px the X coordinate of the specified point being
     *           measured against this line segment
     * @param py the Y coordinate of the specified point being
     *           measured against this line segment
     * @return a double value that is the distance from the specified 
     *   point to the current line segment.
     * @see #ptLineDist(double, double)
     * @since 1.2
     */
      double ptSegDist(double px, double py) {
 return Line2D_ptSegDist(getX1(), getY1(), getX2(), getY2(), px, py);
    }
    /**
     * Returns the distance from a <code>vector</code> to this line
     * segment.
     * The distance measured is the distance between the specified
     * point and the closest point between the current line's end points.  
     * If the specified point intersects the line segment in between the
     * end points, this method returns 0.0.
     * @param pt the specified <code>vector</code> being measured
     *  against this line segment
     * @return a double value that is the distance from the specified
     *    <code>vector</code> to the current line
     *    segment.
     * @see #ptLineDist(vector)
     * @since 1.2
     */
      double ptSegDist(vector pt) {
 return Line2D_ptSegDist(getX1(), getY1(), getX2(), getY2(),
    pt.x, pt.y);
    }

    /**
     * Returns the square of the distance from a point to this line.
     * The distance measured is the distance between the specified     * point and the closest point on the infinitely-extended line     * defined by this <code>Line2D</code>.  If the specified point      * intersects the line, this method returns 0.0.
     *
     * @param px the X coordinate of the specified point being
     *           measured against this line
     * @param py the Y coordinate of the specified point being
     *           measured against this line
     * @return a double value that is the square of the distance from a 
     *   specified point to the current line.
     * @see #ptSegDistSq(double, double)
     * @since 1.2
     */
      double ptLineDistSq(double px, double py) {
 return Line2D_ptLineDistSq(getX1(), getY1(), getX2(), getY2(), px, py);
    }
    /**
     * Returns the square of the distance from a specified 
     * <code>vector</code> to this line.
     * The distance measured is the distance between the specified
     * point and the closest point on the infinitely-extended line
     * defined by this <code>Line2D</code>.  If the specified point 
     * intersects the line, this method returns 0.0.
     * @param pt the specified <code>vector</code> being measured
     *           against this line
     * @return a double value that is the square of the distance from a
     *   specified <code>vector</code> to the current
     *   line.
     * @see #ptSegDistSq(vector)
     * @since 1.2
     */
      double ptLineDistSq(vector pt) {
 return Line2D_ptLineDistSq(getX1(), getY1(), getX2(), getY2(),
       pt.x, pt.y);
    }
    /**
     * Returns the distance from a point to this line.
     * The distance measured is the distance between the specified
     * point and the closest point on the infinitely-extended line
     * defined by this <code>Line2D</code>.  If the specified point 
     * intersects the line, this method returns 0.0.
     *
     * @param px the X coordinate of the specified point being
     *           measured against this line
     * @param py the Y coordinate of the specified point being
     *           measured against this line
     * @return a double value that is the distance from a specified point
     *   to the current line.
     * @see #ptSegDist(double, double)
     * @since 1.2
     */
      double ptLineDist(double px, double py) {
 return Line2D_ptLineDist(getX1(), getY1(), getX2(), getY2(), px, py);
    }
    /**
     * Returns the distance from a <code>vector</code> to this line.
     * The distance measured is the distance between the specified
     * point and the closest point on the infinitely-extended line
     * defined by this <code>Line2D</code>.  If the specified point 
     * intersects the line, this method returns 0.0.
     * @param pt the specified <code>vector</code> being measured
     * @return a double value that is the distance from a specified 
     *   <code>vector</code> to the current line.
     * @see #ptSegDist(vector)
     * @since 1.2
     */
      double ptLineDist(vector pt) {
 return Line2D_ptLineDist(getX1(), getY1(), getX2(), getY2(),
    pt.x, pt.y);
    }
    /**
     * Tests if a specified coordinate is inside the boundary of this
     * <code>Line2D</code>.  This method is required to implement the 
     * {@link Shape} interface, but in the case of <code>Line2D</code> 
     * objects it always returns <code>false</code> since a line contains
     * no area.
     * @param x the X coordinate of the specified point to be tested
     * @param y the Y coordinate of the specified point to be tested
     * @return <code>false</code> because a <code>Line2D</code> contains
     * no area.
     * @since 1.2
     */
      bool contains(double x, double y) {
 return false;
    }
    /**
     * Tests if a given <code>vector</code> is inside the boundary of
     * this <code>Line2D</code>.
     * This method is required to implement the {@link Shape} interface, 
     * but in the case of <code>Line2D</code> objects it always returns 
     * <code>false</code> since a line contains no area.
     * @param p the specified <code>vector</code> to be tested
     * @return <code>false</code> because a <code>Line2D</code> contains
     * no area.
     * @since 1.2
     */
      bool contains(vector p) {
 return false;
    }
    /**
     * {@inheritDoc}
     * @since 1.2
     */
      bool intersects(double x, double y, double w, double h) {
 return intersects(newRectangle(x, y, w, h));
    }
    /**
     * {@inheritDoc}
     * @since 1.2
     */
      bool intersects(Rectangle@ r) {
 return r.intersectsLine(getX1(), getY1(), getX2(), getY2());
    }
    /**
     * Tests if the interior of this <code>Line2D</code> entirely contains
     * the specified set of rectangular coordinates.
     * This method is required to implement the <code>Shape</code> interface, 
     * but in the case of <code>Line2D</code> objects it always returns 
     * false since a line contains no area.
     * @param x the X coordinate of the upper-left corner of the
     *          specified rectangular area
     * @param y the Y coordinate of the upper-left corner of the
     *          specified rectangular area
     * @param w the width of the specified rectangular area
     * @param h the height of the specified rectangular area
     * @return <code>false</code> because a <code>Line2D</code> contains
     * no area.
     * @since 1.2
     */
      bool contains(double x, double y, double w, double h) {
 return false;
    }
    /**
     * Tests if the interior of this <code>Line2D</code> entirely contains
     * the specified <code>Rectangle2D</code>.
     * This method is required to implement the <code>Shape</code> interface, 
     * but in the case of <code>Line2D</code> objects it always returns 
     * <code>false</code> since a line contains no area.
     * @param r the specified <code>Rectangle2D</code> to be tested
     * @return <code>false</code> because a <code>Line2D</code> contains
     * no area.
     * @since 1.2
     */
      bool contains(Rectangle@ r) {
 return false;
    }
    /**
     * {@inheritDoc}
     * @since 1.2
     */
      Rectangle@ getBounds() {
 return getBounds2D().getBounds();
    }
    /**
     * Returns an iteration object that defines the boundary of this
     * <code>Line2D</code>.
     * The iterator for this class is not multi-threaded safe, 
     * which means that this <code>Line2D</code> class does not 
     * guarantee that modifications to the geometry of this
     * <code>Line2D</code> object do not affect any iterations of that
     * geometry that are already in process.
     * @param at the specified {@link AffineTransform}
     * @return a {@link PathIterator} that defines the boundary of this
     *  <code>Line2D</code>.
     * @since 1.2
     */
      PathIterator@ getPathIterator(AffineTransform@ at) {
 return newLineIterator(this, at);
    }
    /**
     * Returns an iteration object that defines the boundary of this
     * flattened <code>Line2D</code>.
     * The iterator for this class is not multi-threaded safe,
     * which means that this <code>Line2D</code> class does not
     * guarantee that modifications to the geometry of this
     * <code>Line2D</code> object do not affect any iterations of that
     * geometry that are already in process. 
     * @param at the specified <code>AffineTransform</code>
     * @param flatness the maximum amount that the control points for a 
     *  given curve can vary from colinear before a subdivided
     *  curve is replaced by a straight line connecting the
     *  end points.  Since a <code>Line2D</code> object is 
     *         always flat, this parameter is ignored.
     * @return a <code>PathIterator</code> that defines the boundary of the
     *   flattened <code>Line2D</code>
     * @since 1.2
     */
      PathIterator@ getPathIterator(AffineTransform@ at, double flatness) {
 return newLineIterator(this, at);
    }
    /**
     * Creates a new object of the same class as this object.
     *
     * @return     a clone of this instance.
     * @exception  OutOfMemoryError            if there is not enough memory.
     * @see        java.lang.Cloneable
     * @since      1.2
     */
 Line2D@ clone() {
 Line2D ret(x1, y1, x2, y2); return ret;
    }
 Shape@ translate(double dx, double dy) {
 Line2D ret(x1+dx, y1+dy, x2+dx, y2+dy); return ret;
}
 Shape@ rotate(double theta) {
 // Center, endpoint, or origin?
 // All so far have been center, so I go with center.
 return rotate((x1+x2)/2, (y1+y2)/2, theta);
}// Rotate.
 Shape@ rotate(double cx, double cy, double theta) {return rotate(newVector(cx, cy), theta);}
 Shape@ rotate(vector v, double theta) {
 vector p1(x1, y1); p1= ::rotate(p1, v, theta);
 vector p2(x2, y2); p2= ::rotate(p2, v, theta);
 Line2D ret(p1.x, p1.y, p2.x, p2.y); return ret;
}
 Shape@ mirrorX() {return newLine2D(-x1, y1, -x2, y2);}
 Shape@ mirrorY() {return newLine2D(x1, -y1, x2, -y2);}
}

 QuadIterator@ newQuadIterator(QuadCurve2D@ q, AffineTransform@ at) {QuadIterator ret(q, at); return ret;}

class QuadIterator : PathIterator {
    QuadCurve2D@ quad;
    AffineTransform@ affine;
    int index;
    QuadIterator(QuadCurve2D@ q, AffineTransform@ at) {
 @(this.quad) = q;
 @(this.affine) = at;
    }
    /**
     * Return the winding rule for determining the insideness of the     * path.
     * @see #WIND_EVEN_ODD
     * @see #WIND_NON_ZERO
     */
 int getWindingRule() {
 return WIND_NON_ZERO;
    }
    /**
     * Tests if there are more points to read.
     * @return true if there are more points to read
     */
 bool isDone() {
 return (index > 1);
    }
    /**
     * Moves the iterator to the next segment of the path forwards     * along the primary direction of traversal as long as there are     * more points in that direction.
     */
 void next() {
 index++;
    }
    /**
     * Returns the coordinates and type of the current path segment in     * the iteration.
     * The return value is the path segment type:
     * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.
     * A float array of length 6 must be passed in and may be used to     * store the coordinates of the point(s).
     * Each point is stored as a pair of float x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point,
     * SEG_QUADTO will return two points,
     * SEG_CUBICTO will return 3 points
     * and SEG_CLOSE will not return any points.
     */
 int currentSegment(float[] &out coords) {
 if (isDone()) {
 return -1;
 }
 int type;
 if (index == 0) {
     coords[0] =   quad.getX1();
     coords[1] =   quad.getY1();
     type = SEG_MOVETO;
 } else {
     coords[0] =   quad.getCtrlX();
     coords[1] =   quad.getCtrlY();
     coords[2] =   quad.getX2();
     coords[3] =   quad.getY2();
     type = SEG_QUADTO;
 }
 if (@affine != null) {
     affine.transform(coords, 0, coords, 0, index == 0 ? 1 : 2);
 }
 return type;
    }
    /**
     * Returns the coordinates and type of the current path segment in     * the iteration.
     * The return value is the path segment type:
     * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.
     * A double array of length 6 must be passed in and may be used to
     * store the coordinates of the point(s).
     * Each point is stored as a pair of double x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point,
     * SEG_QUADTO will return two points,
     * SEG_CUBICTO will return 3 points
     * and SEG_CLOSE will not return any points.
     */
 int currentSegment(double[] &out coords) {
 if (isDone()) {
 return -1;
 }
 int type;
 if (index == 0) {
     coords[0] = quad.getX1();
     coords[1] = quad.getY1();
     type = SEG_MOVETO;
 } else {
     coords[0] = quad.getCtrlX();
     coords[1] = quad.getCtrlY();
     coords[2] = quad.getX2();
     coords[3] = quad.getY2();
     type = SEG_QUADTO;
 }
 if (@affine != null) {
     affine.transform(coords, 0, coords, 0, index == 0 ? 1 : 2);
 }
 return type;
    }
}


class CubicIterator : PathIterator {
    CubicCurve2D@ cubic;
    AffineTransform@ affine;
    int index;
CubicIterator() {@affine=newAffineTransform(); @cubic=null;}
    CubicIterator(CubicCurve2D@ q, AffineTransform@ at) {
 @(this.cubic) = q;
 @(this.affine) = at;
    }
    /**
     * Return the winding rule for determining the insideness of the     * path.
     * @see #WIND_EVEN_ODD
     * @see #WIND_NON_ZERO
     */
 int getWindingRule() {
 return WIND_NON_ZERO;
    }
    /**
     * Tests if there are more points to read.
     * @return true if there are more points to read
     */
      bool isDone() {
 return (index > 1);
    }
    /**
     * Moves the iterator to the next segment of the path forwards     * along the primary direction of traversal as long as there are     * more points in that direction.
     */
      void next() {
 index++;
    }
    /**
     * Returns the coordinates and type of the current path segment in     * the iteration.     * The return value is the path segment type:     * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.
     * A float array of length 6 must be passed in and may be used to     * store the coordinates of the point(s).
     * Each point is stored as a pair of float x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point,
     * SEG_QUADTO will return two points,
     * SEG_CUBICTO will return 3 points
     * and SEG_CLOSE will not return any points.
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     */
      int currentSegment(float[]  &out coords) {
 if (isDone()) {
 return -1;
 }
 int type;
 if (index == 0) {
     coords[0] =   cubic.getX1();
     coords[1] =   cubic.getY1();
     type = SEG_MOVETO;
 } else {
     coords[0] =   cubic.getCtrlX1();
     coords[1] =   cubic.getCtrlY1();
     coords[2] =   cubic.getCtrlX2();
     coords[3] =   cubic.getCtrlY2();
     coords[4] =   cubic.getX2();
     coords[5] =   cubic.getY2();
     type = SEG_CUBICTO;
 }
 if (@affine != null) {
     affine.transform(coords, 0, coords, 0, index == 0 ? 1 : 3);
 }
 return type;
    }
    /**
     * Returns the coordinates and type of the current path segment in     * the iteration.
     * The return value is the path segment type:     * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.
     * A double array of length 6 must be passed in and may be used to     * store the coordinates of the point(s).     * Each point is stored as a pair of double x,y coordinates.     * SEG_MOVETO and SEG_LINETO types will return one point,     * SEG_QUADTO will return two points,     * SEG_CUBICTO will return 3 points     * and SEG_CLOSE will not return any points.
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     */
      int currentSegment(double[] &out coords) {
 if (isDone()) {
 return -1;
 }
 int type;
 if (index == 0) {
     coords[0] = cubic.getX1();
     coords[1] = cubic.getY1();
     type = SEG_MOVETO;
 } else {
     coords[0] = cubic.getCtrlX1();
     coords[1] = cubic.getCtrlY1();
     coords[2] = cubic.getCtrlX2();
     coords[3] = cubic.getCtrlY2();
     coords[4] = cubic.getX2();
     coords[5] = cubic.getY2();
     type = SEG_CUBICTO;
 }
 if (@affine != null) {
     affine.transform(coords, 0, coords, 0, index == 0 ? 1 : 3);
 }
 return type;
    }
}
CubicIterator newCubicIterator(CubicCurve2D@ cu, AffineTransform@ at) {CubicIterator ret(cu, at); return ret;}
 FlatteningPathIterator newFlatteningPathIterator(PathIterator@ src, double flatness) {FlatteningPathIterator ret(src, flatness); return ret;}
class LineIterator : PathIterator {
    Line2D@ line;
    AffineTransform@ affine;
    int index;
    LineIterator(Line2D@ l, AffineTransform@ at) {
 @(this.line) = l;
 @(this.affine) = at;
    }
    /**
     * Return the winding rule for determining the insideness of the     * path.
     * @see #WIND_EVEN_ODD
     * @see #WIND_NON_ZERO
     */
      int getWindingRule() {
 return WIND_NON_ZERO;
    }
    /**
     * Tests if there are more points to read.     * @return true if there are more points to read
     */
      bool isDone() {
 return (index > 1);
    }
    /**
     * Moves the iterator to the next segment of the path forwards     * along the primary direction of traversal as long as there are     * more points in that direction.
     */
      void next() {
 index++;
    }
    /**
     * Returns the coordinates and type of the current path segment in     * the iteration.
     * The return value is the path segment type:     * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.     * A float array of length 6 must be passed in and may be used to     * store the coordinates of the point(s).     * Each point is stored as a pair of float x,y coordinates.     * SEG_MOVETO and SEG_LINETO types will return one point,     * SEG_QUADTO will return two points,     * SEG_CUBICTO will return 3 points
     * and SEG_CLOSE will not return any points.
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     */
      int currentSegment(float[] &out coords) {
 if (isDone()) {
 return -1;
 }
 int type;
 if (index == 0) {
     coords[0] =   line.getX1();
     coords[1] =   line.getY1();
     type = SEG_MOVETO;
 } else {
     coords[0] =   line.getX2();
     coords[1] =   line.getY2();
     type = SEG_LINETO;
 }
 if (@affine != null) {
     affine.transform(coords, 0, coords, 0, 1);
 }
 return type;
    }
    /**
     * Returns the coordinates and type of the current path segment in     * the iteration.     * The return value is the path segment type:     * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.     * A double array of length 6 must be passed in and may be used to     * store the coordinates of the point(s).     * Each point is stored as a pair of double x,y coordinates.     * SEG_MOVETO and SEG_LINETO types will return one point,     * SEG_QUADTO will return two points,     * SEG_CUBICTO will return 3 points     * and SEG_CLOSE will not return any points.
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     */
      int currentSegment(double[] &out coords) {
 if (isDone()) {
 return -1;
 }
 int type;
 if (index == 0) {
     coords[0] = line.getX1();
     coords[1] = line.getY1();
     type = SEG_MOVETO;
 } else {
     coords[0] = line.getX2();
     coords[1] = line.getY2();
     type = SEG_LINETO;
 }
 if (@affine != null) {
     affine.transform(coords, 0, coords, 0, 1);
 }
 return type;
    }
}
LineIterator@ newLineIterator(Line2D@ l, AffineTransform@ at) {LineIterator ret(l, at); return ret;}


    /**
     * The closure type for an open arc with no path segments     * connecting the two ends of the arc segment.
     * @since 1.2
     */


 const int Arc2D_OPEN = 0;
    /**
     * The closure type for an arc closed by drawing a straight     * line segment from the start of the arc segment to the end of the      * arc segment.
     * @since 1.2
     */
 const int Arc2D_CHORD = 1;

    /**
     * The closure type for an arc closed by drawing straight line     * segments from the start of the arc segment to the center     * of the full ellipse and from that point to the end of the arc segment.
     * @since 1.2
     */
 const int Arc2D_PIE = 2;

 class Arc2D : Shape {
        /**
         * The X coordinate of the upper-left corner of the framing         * rectangle of the arc.
         * @since 1.2
         * @serial
         */
 double x;
        /**
         * The Y coordinate of the upper-left corner of the framing         * rectangle of the arc.
         * @since 1.2
         * @serial
         */
 double y;
        /**
         * The overall width of the full ellipse of which this arc is          * a partial section (not considering the angular extents).
         * @since 1.2
         * @serial
         */
 double width;
        /**
         * The overall height of the full ellipse of which this arc is          * a partial section (not considering the angular extents).
         * @since 1.2
         * @serial
         */
 double height;
        /**
         * The starting angle of the arc in degrees.
         * @since 1.2
         * @serial
         */
 double start;
        /**
         * The angular extent of the arc in degrees.
         * @since 1.2
         * @serial
         */
 double extent;
        /**
         * Constructs a new OPEN arc, initialized to location (0, 0),
         * size (0, 0), angular extents (start = 0, extent = 0).
         * @since 1.2
         */
 Arc2D() {
 init(0, 0, 0, 0, 0, 0, Arc2D_OPEN);
}
        /**
         * Constructs a new arc, initialized to location (0, 0),
         * size (0, 0), angular extents (start = 0, extent = 0), and
         * the specified closure type.
         *
         * @param type The closure type for the arc: 
         * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
         * @since 1.2
         */
 Arc2D(int typ) {
 init(0, 0, 0, 0, 0, 0, typ);
 }
        /**
         * Constructs a new arc, initialized to the specified location,
         * size, angular extents, and closure type.
         *
         * @param x The X coordinate of the upper-left corner
         *          of the arc's framing rectangle.
         * @param y The Y coordinate of the upper-left corner
         *          of the arc's framing rectangle.
         * @param w The overall width of the full ellipse of which this  
         *          arc is a partial section.
         * @param h The overall height of the full ellipse of which this 
         *          arc is a partial section.
         * @param start The starting angle of the arc in degrees.
         * @param extent The angular extent of the arc in degrees.
         * @param type The closure type for the arc: 
         * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
         * @since 1.2
         */
 Arc2D(double xx, double yy, double w, double h,
        double s, double ext, int typ) {
 init(xx, yy, w, h, s, ext, typ);
}
 void init(double xx, double yy, double w, double h, double s, double ext, int typ) {
 type=typ;
     this.x = xx;
     this.y = yy;
     this.width = w;
     this.height = h;
     this.start = s;
     this.extent = ext;
 }
        /**
         * Constructs a new arc, initialized to the specified location,
         * size, angular extents, and closure type.
         *
         * @param ellipseBounds The framing rectangle that defines the 
         * outer boundary of the full ellipse of which this arc is a 
         * partial section.
         * @param start The starting angle of the arc in degrees.
         * @param extent The angular extent of the arc in degrees.
         * @param type The closure type for the arc: 
         * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
         * @since 1.2
         */
 Arc2D(Rectangle@ ellipseBounds,
        double s, double ext, int typ) {
 type=typ;
     this.x = ellipseBounds.x;
     this.y = ellipseBounds.y;
     this.width = ellipseBounds.width;
     this.height = ellipseBounds.height;
     this.start = s;
     this.extent = ext;
 }
        /**
         * {@inheritDoc}
         * Note that the arc         * <a href="Arc2D.html#inscribes">partially inscribes</a>         * the framing rectangle of this {@code RectangularShape}.
         *
         * @since 1.2
         */
   double getX() {
     return x;
 }
        /**
         * {@inheritDoc}
         * Note that the arc         * <a href="Arc2D.html#inscribes">partially inscribes</a>         * the framing rectangle of this {@code RectangularShape}.
         *
         * @since 1.2
         */
   double getY() {
     return y;
 }
        /**
         * {@inheritDoc}
         * Note that the arc         * <a href="Arc2D.html#inscribes">partially inscribes</a>
         * the framing rectangle of this {@code RectangularShape}.
         *
         * @since 1.2
         */
   double getWidth() {
     return width;
 }
        /**
         * {@inheritDoc}
         * Note that the arc         * <a href="Arc2D.html#inscribes">partially inscribes</a>
         * the framing rectangle of this {@code RectangularShape}.
         *
         * @since 1.2
         */
   double getHeight() {
     return height;
 }
        /**
         * {@inheritDoc}
         * @since 1.2
         */
   double getAngleStart() {
     return start;
 }
        /**
         * {@inheritDoc}
         * @since 1.2
         */ 
   double getAngleExtent() {
     return extent;
 }
        /**
         * {@inheritDoc}
         * @since 1.2
         */
   bool isEmpty() {
     return (width <= 0.0 || height <= 0.0);
 }
        /**
         * {@inheritDoc}
         * @since 1.2
         */
   void setArc(double xx, double yy, double w, double h,
      double angSt, double angExt, int closure) {
     this.setArcType(closure);
     this.x = xx;
     this.y = yy;
     this.width = w;
     this.height = h;
     this.start = angSt;
     this.extent = angExt;
 }
        /**
         * {@inheritDoc}
         * @since 1.2
         */
   void setAngleStart(double angSt) {
     this.start = angSt;
 }
        /**
         * {@inheritDoc}
         * @since 1.2
         */
   void setAngleExtent(double angExt) {
     this.extent = angExt;
 }
        /**
         * {@inheritDoc}
         * @since 1.2
         */
 Rectangle@ makeBounds(double xx, double yy,
      double w, double h) {
     return newRectangle(xx, yy, w, h);
 }
 int type;
      int getArcType() {
 return type;
    }
    /**
     * Returns the starting point of the arc.  This point is the     * intersection of the ray from the center defined by the     * starting angle and the elliptical boundary of the arc.
     * 
     * @return A <CODE>Point2D</CODE> object representing the 
     * x,y coordinates of the starting point of the arc.
     * @since 1.2
     */
 vector getStartPoint() {
 double angle = getAngleStart(); //= Math.toRadians(-getAngleStart());
 double xx = getX() + (cosine(angle) * 0.5 + 0.5) * getWidth();
 double yy = getY() + (sine(angle) * 0.5 + 0.5) * getHeight();
 return newVector(xx, yy);
    }
    /**
     * Returns the ending point of the arc.  This point is the     * intersection of the ray from the center defined by the     * starting angle plus the angular extent of the arc and the     * elliptical boundary of the arc.
     *
     * @return A <CODE>Point2D</CODE> object representing the 
     * x,y coordinates  of the ending point of the arc.
     * @since 1.2
     */
 vector getEndPoint() {
 double angle = getAngleStart()+getAngleExtent(); // Math.toRadians(-getAngleStart() - getAngleExtent());
 double xx = getX() + (cosine(angle) * 0.5 + 0.5) * getWidth();
 double yy = getY() + (sine(angle) * 0.5 + 0.5) * getHeight();
 return newVector(xx, yy);
    }
      void setArc(vector loc, vector size,
         double angSt, double angExt, int closure) {
 setArc(loc.x, loc.y, size.x, size.y,
        angSt, angExt, closure);
    }
    /**
     * Sets the location, size, angular extents, and closure type of
     * this arc to the specified values.
     *
     * @param rect The framing rectangle that defines the 
     * outer boundary of the full ellipse of which this arc is a 
     * partial section.
     * @param angSt The starting angle of the arc in degrees. 
     * @param angExt The angular extent of the arc in degrees. 
     * @param closure The closure type for the arc:
     * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
     * @since 1.2
     */ 
      void setArc(Rectangle@ rect, double angSt, double angExt,
         int closure) {
 setArc(rect.x, rect.y, rect.width, rect.height,
        angSt, angExt, closure);
    }
    /**
     * Sets this arc to be the same as the specified arc.
     *
     * @param a The <CODE>Arc2D</CODE> to use to set the arc's values.
     * @since 1.2
     */
      void setArc(Arc2D@ a) {
 setArc(a.getX(), a.getY(), a.getWidth(), a.getHeight(),
        a.getAngleStart(), a.getAngleExtent(), a.type);
    }
    /**
     * Sets the position, bounds, angular extents, and closure type of
     * this arc to the specified values. The arc is defined by a center 
     * point and a radius rather than a framing rectangle for the full ellipse.
     *
     * @param x The X coordinate of the center of the arc. 
     * @param y The Y coordinate of the center of the arc. 
     * @param radius The radius of the arc.
     * @param angSt The starting angle of the arc in degrees.
     * @param angExt The angular extent of the arc in degrees. 
     * @param closure The closure type for the arc:
     * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.     
     * @since 1.2
     */
      void setArcByCenter(double xx, double yy, double radius,
          double angSt, double angExt, int closure) {
 setArc(xx - radius, yy - radius, radius * 2.0, radius * 2.0,
        angSt, angExt, closure);
    }
    /**
     * Sets the position, bounds, and angular extents of this arc to the 
     * specified value. The starting angle of the arc is tangent to the 
     * line specified by points (p1, p2), the ending angle is tangent to 
     * the line specified by points (p2, p3), and the arc has the 
     * specified radius.
     *
     * @param p1 The first point that defines the arc. The starting 
     * angle of the arc is tangent to the line specified by points (p1, p2).
     * @param p2 The second point that defines the arc. The starting 
     * angle of the arc is tangent to the line specified by points (p1, p2). 
     * The ending angle of the arc is tangent to the line specified by 
     * points (p2, p3).
     * @param p3 The third point that defines the arc. The ending angle 
     * of the arc is tangent to the line specified by points (p2, p3).
     * @param radius The radius of the arc.
     * @since 1.2
     */
      void setArcByTangent(vector p1, vector p2, vector p3,
    double radius) {
 double ang1 = arc_tangent(p1.y - p2.y,
     p1.x - p2.x);
 double ang2 = arc_tangent(p3.y - p2.y,
     p3.x - p2.x);
 double diff = ang2 - ang1;
 if (diff > PI) {
     ang2 -= PI * 2.0;
 } else if (diff < -PI) {
     ang2 += PI * 2.0;
 }
 double bisect = (ang1 + ang2) / 2.0;
 double theta = absolute(ang2 - bisect);
 double dist = radius / sine(theta);
 double xx = p2.x + dist * cosine(bisect);
 double yy = p2.y + dist * sine(bisect);
 // REMIND: This needs some work...
 if (ang1 < ang2) {
     ang1 -= PI / 2.0;
     ang2 += PI /2.0;
 } else {
     ang1 += PI / 2.0;
     ang2 -= PI / 2.0;
 }
// ang1 = Math.toDegrees(-ang1);
// ang2 = Math.toDegrees(-ang2);
 diff = ang2 - ang1;
 if (diff < 0) {
     diff += 2*PI;
 } else {
     diff -= 2*PI;
 }
 setArcByCenter(xx, yy, radius, ang1, diff, type);
    }
      void setAngleStart(vector p) {
 // Bias the dx and dy by the height and width of the oval.
 double dx = getHeight() * (p.x - getCenterX());
 double dy = getWidth() * (p.y - getCenterY());
 setAngleStart((arc_tangent(dy, dx)));
    }
    /**
     * Sets the starting angle and angular extent of this arc using two 
     * sets of coordinates. The first set of coordinates is used to 
     * determine the angle of the starting point relative to the arc's 
     * center. The second set of coordinates is used to determine the 
     * angle of the end point relative to the arc's center. 
     * The arc will always be non-empty and extend counterclockwise
     * from the first point around to the second point.
     *
     * @param x1 The X coordinate of the arc's starting point.
     * @param y1 The Y coordinate of the arc's starting point.
     * @param x2 The X coordinate of the arc's ending point.
     * @param y2 The Y coordinate of the arc's ending point.
     * @since 1.2
     */
      void setAngles(double x1, double y1, double x2, double y2) {
 double xx = getCenterX();
 double yy = getCenterY();
 double w = getWidth();
 double h = getHeight();
 // Note: reversing the Y equations negates the angle to adjust
 // for the upside down coordinate system.
 // Also we should bias atans by the height and width of the oval.
 double ang1 = arc_tangent(w * (yy - y1), h * (x1 - xx));
 double ang2 = arc_tangent(w * (yy - y2), h * (x2 - xx));
 ang2 -= ang1;
 if (ang2 <= 0.0) {
     ang2 += PI * 2.0;
 }
 setAngleStart((ang1));
 setAngleExtent((ang2));
    }
    /**
     * Sets the starting angle and angular extent of this arc using  
     * two points. The first point is used to determine the angle of 
     * the starting point relative to the arc's center.
     * The second point is used to determine the angle of the end point
     * relative to the arc's center. 
     * The arc will always be non-empty and extend counterclockwise
     * from the first point around to the second point.
     *
     * @param p1 The <CODE>Point2D</CODE> that defines the arc's 
     * starting point. 
     * @param p2 The <CODE>Point2D</CODE> that defines the arc's 
     * ending point.
     * @since 1.2
     */
      void setAngles(vector p1, vector p2) {
 setAngles(p1.x, p1.y, p2.x, p2.y);
    }
    /**
     * Sets the closure type of this arc to the specified value: 
     * <CODE>OPEN</CODE>, <CODE>CHORD</CODE>, or <CODE>PIE</CODE>.
     *
     * @param type The integer constant that represents the closure 
     * type of this arc: {@link #OPEN}, {@link #CHORD}, or 
     * {@link #PIE}.
     *
     * @throws IllegalArgumentException if <code>type</code> is not
     * 0, 1, or 2.+
     * @see #getArcType
     * @since 1.2
     */
      void setArcType(int typ) {
 if ((typ < Arc2D_OPEN) || (typ > Arc2D_PIE)) {
 return;
 }
 this.type = typ;
    }
    /**
     * {@inheritDoc}
     * Note that the arc     * <a href="Arc2D.html#inscribes">partially inscribes</a>     * the framing rectangle of this {@code RectangularShape}.
     *
     * @since 1.2
     */
      void setFrame(double xx, double yy, double w, double h) {
 setArc(xx, yy, w, h, getAngleStart(), getAngleExtent(), type);
    }
    /**
     * Returns the high-precision framing rectangle of the arc.  The framing  
     * rectangle contains only the part of this <code>Arc2D</code> that is 
     * in between the starting and ending angles and contains the pie
     * wedge, if this <code>Arc2D</code> has a <code>PIE</code> closure type.
     * <p>
     * This method differs from the 
     * {@link RectangularShape#getBounds() getBounds} in that the 
     * <code>getBounds</code> method only returns the bounds of the 
     * enclosing ellipse of this <code>Arc2D</code> without considering
     * the starting and ending angles of this <code>Arc2D</code>.
     * 
     * @return the <CODE>Rectangle2D</CODE> that represents the arc's 
     * framing rectangle.
     * @since 1.2
     */
      Rectangle@ getBounds2D() {
 if (isEmpty()) {
     return makeBounds(getX(), getY(), getWidth(), getHeight());
 }
 double x1, y1, x2, y2;
 if (getArcType() == Arc2D_PIE) {
     x1 = y1 = x2 = y2 = 0.0;
 } else {
     x1 = y1 = 1.0;
     x2 = y2 = -1.0;
 }
 double angle = 0.0;
 for (int i = 0; i < 6; i++) {
     if (i < 4) {
  // 0-3 are the four quadrants
  angle += PI/2.0;
  if (!containsAngle(angle)) {
      continue;
  }
     } else if (i == 4) {
  // 4 is start angle
  angle = getAngleStart();
     } else {
  // 5 is end angle
  angle += getAngleExtent();
     }
     double rads = angle; //Math.toRadians(-angle);
     double xe = cosine(rads);
     double ye = sine(rads);
     x1 = Math_min(x1, xe);
     y1 = Math_min(y1, ye);
     x2 = Math_max(x2, xe);
     y2 = Math_max(y2, ye);
 }
 double w = getWidth();
 double h = getHeight();
 x2 = (x2 - x1) * 0.5 * w;
 y2 = (y2 - y1) * 0.5 * h;
 x1 = getX() + (x1 * 0.5 + 0.5) * w;
 y1 = getY() + (y1 * 0.5 + 0.5) * h;
 return makeBounds(x1, y1, x2, y2);
    }

    /*
     * Normalizes the specified angle into the range -180 to 180.
     */
 double normalizeDegrees(double angle) {
 if (angle > PI) {
     if (angle <= (PI + (2.0*PI))) {
  angle = angle - (2.0*PI);
     } else {
 while(angle>PI) angle-=2.0*PI; //  angle = Math.IEEEremainder(angle, 360.0);
  // IEEEremainder can return -180 here for some input values...
  if (angle == -PI) {
      angle = PI;
  }
     }
 } else if (angle <= -PI) {
     if (angle > (-PI - (2*PI))) {
  angle = angle + (2*PI);
     } else {
 while(angle<-PI) angle+=2*PI; //?//  angle = Math.IEEEremainder(angle, 360.0);
  // IEEEremainder can return -180 here for some input values...
  if (angle == -PI) {
      angle = PI;
  }
     }
 }
 return angle;
    }
    /**
     * Determines whether or not the specified angle is within the  
     * angular extents of the arc.
     *
     * @param angle The angle to test.
     *
     * @return <CODE>true</CODE> if the arc contains the angle, 
     * <CODE>false</CODE> if the arc doesn't contain the angle.
     * @since 1.2
     */
      bool containsAngle(double angle) {
 double angExt = getAngleExtent();
 bool backwards = (angExt < 0.0);
 if (backwards) {
     angExt = -angExt;
 }
 if (angExt >= 2*PI) {
     return true;
 }
 angle = normalizeDegrees(angle) - normalizeDegrees(getAngleStart());
 if (backwards) {
     angle = -angle;
 }
 if (angle < 0.0) {
     angle += 2*PI;
 }
      
 return (angle >= 0.0) && (angle < angExt);
    }
    /**
     * Determines whether or not the specified point is inside the boundary 
     * of the arc.
     *
     * @param x The X coordinate of the point to test.
     * @param y The Y coordinate of the point to test.
     *
     * @return <CODE>true</CODE> if the point lies within the bound of 
     * the arc, <CODE>false</CODE> if the point lies outside of the 
     * arc's bounds.
     * @since 1.2
     */
      bool contains(double xx, double yy) {
 // Normalize the coordinates compared to the ellipse
 // having a center at 0,0 and a radius of 0.5.
 double ellw = getWidth();
 if (ellw <= 0.0) {
     return false;
 }
 double normx = (xx - getX()) / ellw - 0.5;
 double ellh = getHeight();
 if (ellh <= 0.0) {
     return false;
 }
 double normy = (yy - getY()) / ellh - 0.5;
 double distSq = (normx * normx + normy * normy);
 if (distSq >= 0.25) {
     return false;
 }
 double angExt = absolute(getAngleExtent());
 if (angExt >= 2*PI) {
     return true;
 }
 bool inarc = containsAngle((arc_tangent(normy,
         normx)));
 if (type == Arc2D_PIE) {
     return inarc;
 }
 // CHORD and OPEN behave the same way
 if (inarc) {
     if (angExt >= PI) {
  return true;
     }
     // point must be outside the "pie triangle"
 } else {
     if (angExt <= PI) {
  return false;
     }
     // point must be inside the "pie triangle"
 }
 // The point is inside the pie triangle iff it is on the same
 // side of the line connecting the ends of the arc as the center.
 double angle = (getAngleStart());
 double x1 = cosine(angle);
 double y1 = sine(angle);
 angle += (getAngleExtent());
 double x2 = cosine(angle);
 double y2 = sine(angle);
 bool inside = (Line2D_relativeCCW(x1, y1, x2, y2, 2*normx, 2*normy) *
     Line2D_relativeCCW(x1, y1, x2, y2, 0, 0) >= 0);
 return inarc ? !inside : inside;
    }
    /**
     * Determines whether or not the interior of the arc intersects      * the interior of the specified rectangle.
     *
     * @param x The X coordinate of the rectangle's upper-left corner. 
     * @param y The Y coordinate of the rectangle's upper-left corner. 
     * @param w The width of the rectangle.
     * @param h The height of the rectangle.
     *
     * @return <CODE>true</CODE> if the arc intersects the rectangle, 
     * <CODE>false</CODE> if the arc doesn't intersect the rectangle.
     * @since 1.2
     */
 bool intersects(Rectangle@ r) {return intersects(r.x, r.y, r.width, r.height);}
      bool intersects(double xx, double yy, double w, double h) {
 double aw = getWidth();
 double ah = getHeight();
 if ( w <= 0 || h <= 0 || aw <= 0 || ah <= 0 ) {
     return false;
 }
 double ext = getAngleExtent();
 if (ext == 0) {
     return false;
 }
 double ax  = getX();
 double ay  = getY();
 double axw = ax + aw;
 double ayh = ay + ah;
 double xw  = xx + w;
 double yh  = yy + h;
 // check bbox
 if ((xx >= axw) || (yy >= ayh) || (xw <= ax) || (yh <= ay)) {
     return false;
 }
 // extract necessary data
 double axc = getCenterX();
 double ayc = getCenterY();
 vector sp = getStartPoint();
 vector ep = getEndPoint();
 double sx = sp.x;
 double sy = sp.y;
 double ex = ep.x;
 double ey = ep.y;
 /*
  * Try to catch rectangles that intersect arc in areas  * outside of rectagle with left top corner coordinates  * (min(center x, start point x, end point x),  *  min(center y, start point y, end point y))  * and rigth bottom corner coordinates  * (max(center x, start point x, end point x),  *  max(center y, start point y, end point y)).  * So we'll check axis segments outside of rectangle above.
  */
 if (ayc >= y && ayc <= yh) { // 0 and 180
     if ((sx < xw && ex < xw && axc < xw &&
          axw > x && containsAngle(0)) ||
         (sx > x && ex > x && axc > x &&
          ax < xw && containsAngle(PI))) {
  return true;
     }
 }
 if (axc >= x && axc <= xw) { // 90 and 270
     if ((sy > y && ey > y && ayc > y &&
          ay < yh && containsAngle(PI/2)) ||
         (sy < yh && ey < yh && ayc < yh &&
          ayh > y && containsAngle(3*PI/2))) {
  return true;
     }
 }
 /*
  * For PIE we should check intersection with pie slices;
  * also we should do the same for arcs with extent is greater
  * than 180, because we should cover case of rectangle, which
  * situated between center of arc and chord, but does not
  * intersect the chord.
  */
 Rectangle@ rect = newRectangle(xx, yy, w, h);
 if ((type == Arc2D_PIE) || (absolute(ext) > PI)) {
     // for PIE: try to find intersections with pie slices
     if (rect.intersectsLine(axc, ayc, sx, sy) ||
  rect.intersectsLine(axc, ayc, ex, ey)) {
  return true;
     }
 } else {
     // for CHORD and OPEN: try to find intersections with chord
     if (rect.intersectsLine(sx, sy, ex, ey)) {
  return true;
     }
 }
 // finally check the rectangle corners inside the arc
 if (contains(xx, yy) || contains(xx + w, yy) ||
     contains(xx, yy + h) || contains(xx + w, yy + h)) {
     return true;
 }
 return false;
    }
    /**
     * Determines whether or not the interior of the arc entirely contains 
     * the specified rectangle.
     *
     * @param x The X coordinate of the rectangle's upper-left corner. 
     * @param y The Y coordinate of the rectangle's upper-left corner. 
     * @param w The width of the rectangle.
     * @param h The height of the rectangle.
     *
     * @return <CODE>true</CODE> if the arc contains the rectangle, 
     * <CODE>false</CODE> if the arc doesn't contain the rectangle.
     * @since 1.2
     */
      bool contains(double xx, double yy, double w, double h) {
 return contains(xx, yy, w, h, null);
    }
    /**
     * Determines whether or not the interior of the arc entirely contains 
     * the specified rectangle.
     *
     * @param r The <CODE>Rectangle2D</CODE> to test.
     *
     * @return <CODE>true</CODE> if the arc contains the rectangle, 
     * <CODE>false</CODE> if the arc doesn't contain the rectangle.
     * @since 1.2
     */  
      bool contains(Rectangle@ r) {
 return contains(r.x, r.y, r.width, r.height, r);
    }
 bool contains(double xx, double yy, double w, double h,
        Rectangle@ origrect) {
 if (!(contains(xx, yy) &&
       contains(xx + w, yy) &&
       contains(xx, yy + h) &&
       contains(xx + w, yy + h))) {
     return false;
 }
 // If the shape is convex then we have done all the testing
 // we need.  Only PIE arcs can be concave and then only if
 // the angular extents are greater than 180 degrees.
 if ((type != Arc2D_PIE) || absolute(getAngleExtent()) <= PI) {
     return true;
 }
 // For a PIE shape we have an additional test for the case where
 // the angular extents are greater than 180 degrees and all four
 // rectangular corners are inside the shape but one of the
 // rectangle edges spans across the "missing wedge" of the arc.
 // We can test for this case by checking if the rectangle intersects
 // either of the pie angle segments.
 if (@origrect == null) {
     @origrect = newRectangle(xx, yy, w, h);
 }
 double halfW = getWidth() / 2.0;
 double halfH = getHeight() / 2.0;
 double xc = getX() + halfW;
 double yc = getY() + halfH;
 double angle = (getAngleStart());
 double xe = xc + halfW * cosine(angle);
 double ye = yc + halfH * sine(angle);
 if (origrect.intersectsLine(xc, yc, xe, ye)) {
     return false;
 }
 angle += (getAngleExtent());
 xe = xc + halfW * cosine(angle);
 ye = yc + halfH * sine(angle);
 return !origrect.intersectsLine(xc, yc, xe, ye);
    }
    /**
     * Returns an iteration object that defines the boundary of the     * arc.
     * This iterator is multithread safe.
     * <code>Arc2D</code> guarantees that     * modifications to the geometry of the arc     * do not affect any iterations of that geometry that     * are already in process.
     *
     * @param at an optional <CODE>AffineTransform</CODE> to be applied 
     * to the coordinates as they are returned in the iteration, or null 
     * if the untransformed coordinates are desired.
     *
     * @return A <CODE>PathIterator</CODE> that defines the arc's boundary.
     * @since 1.2
     */
      PathIterator@ getPathIterator(AffineTransform@ at) {
 return newArcIterator(this, at);
    }
      bool equals(Shape@ obj) {
        if (@obj == @this) {
            return true;
        }
            Arc2D a2d = cast<Arc2D>( obj);
 if(@a2d!=null) {

            return ((getX() == a2d.getX()) &&
                    (getY() == a2d.getY()) &&
                    (getWidth() == a2d.getWidth()) &&
                    (getHeight() == a2d.getHeight()) &&
                    (getAngleStart() == a2d.getAngleStart()) &&
                    (getAngleExtent() == a2d.getAngleExtent()) &&
                    (getArcType() == a2d.getArcType()));
        }
        return false;
    }
 Rectangle@ getBounds() {return getBounds2D();}
 PathIterator@ getPathIterator(AffineTransform@ at, double flatness) {
 PathIterator@ ret=getPathIterator(at);
 return newFlatteningPathIterator(ret, flatness);
}

 bool contains(vector p) {return contains(p.x, p.y);}
 vector getCenter() {
return newVector(x+(0.5*width), y+(0.5*height));
}
 double getCenterX() {return x+(0.5*width);}
 double getCenterY() {
return y+(0.5*height);
}
// I hope those are for the bounding ellipse, not the arc itself.

 Arc2D@ clone() {
 Arc2D ret(x, y, width, height, start, extent, type); return ret;
}
 Shape@ translate(double dx, double dy) {
 Arc2D ret(x+dx, y+dy, width, height, start, extent, type); return ret; 
}// Translate.
 Shape@ rotate(double theta) {
 Arc2D@ ret=clone(); ret.start+=theta; return ret;
}
 Shape@ rotate(double cx, double cy, double theta) {return rotate(newVector(cx, cy), theta);}
 Shape@ rotate(vector v, double theta) {
 vector c= ::rotate(getCenter(), v, theta);
 Arc2D@ ret=clone();
 ret.x=c.x-(width/2);
 ret.y=c.y-(height/2);
 ret.extent+=theta;
 return ret;
}

 Shape@ mirrorX() {
 Arc2D@ ret=clone();
 ret.x=-x-width;
 // There's probably a simpler way to do this, but:
 double s=pi-start;
 double e=pi-(start+extent);
 ret.start=math_min(s, e);
 // Extent remains the same?
 return ret;
}
 Shape@ mirrorY() {
 Arc2D@ ret=clone(); ret.y=-y-width;

 // Flip angle.
 double s=(2*pi)-start;
 double e=(2*pi)-(start+extent);
 ret.start=math_min(s, e);

 return ret;
}// Mirror Y.
}

class ArcIterator : PathIterator {
    double x; double y;
double w;
double h;
 double angStRad;
 double increment;
 double cv;
    AffineTransform@ affine;
    int index;
    int arcSegs;
    int lineSegs;
    ArcIterator(Arc2D@ a, AffineTransform@ at) {
 this.w = a.getWidth() / 2;
 this.h = a.getHeight() / 2;
 this.x = a.getX() + w;
 this.y = a.getY() + h;
 this.angStRad =(a.getAngleStart());
 @(this.affine) = at;
 double ext = a.getAngleExtent();
 if ((ext >= 2*PI) || (ext <= -2*PI)) {
     arcSegs = 4;
     this.increment = PI / 2;
     // btan(Math.PI / 2);
     this.cv = 0.5522847498307933;
     if (ext < 0) {
  increment = -increment;
  cv = -cv;
     }
 } else {
     arcSegs =  ceiling(absolute(ext) / (PI/2));
     this.increment = (ext / arcSegs);
     this.cv = btan(increment);
     if (cv == 0) {
  arcSegs = 0;
     }
 }
 switch (a.getArcType()) {
 case Arc2D_OPEN: {
     lineSegs = 0;}
     break;
 case Arc2D_CHORD: {
     lineSegs = 1;
}     break;
 case Arc2D_PIE: {
     lineSegs = 2;
}     break;
 }
 if (w < 0 || h < 0) {
     arcSegs = lineSegs = -1;
 }
    }
    /**
     * Return the winding rule for determining the insideness of the
     * path.
     * @see #WIND_EVEN_ODD
     * @see #WIND_NON_ZERO
     */
 int getWindingRule() {
 return WIND_NON_ZERO;
    }
    /**
     * Tests if there are more points to read.
     * @return true if there are more points to read
     */
 bool isDone() {
 return index > arcSegs + lineSegs;
    }
    /**
     * Moves the iterator to the next segment of the path forwards
     * along the primary direction of traversal as long as there are
     * more points in that direction.
     */
 void next() {
 index++;
    }
    /*
     * btan computes the length (k) of the control segments at
     * the beginning and end of a cubic bezier that approximates
     * a segment of an arc with extent less than or equal to
     * 90 degrees.  This length (k) will be used to generate the
     * 2 bezier control points for such a segment.
     *
     *   Assumptions:
     *     a) arc is centered on 0,0 with radius of 1.0
     *     b) arc extent is less than 90 degrees
     *     c) control points should preserve tangent
     *     d) control segments should have equal length
     *
     *   Initial data:
     *     start angle: ang1
     *     end angle:   ang2 = ang1 + extent
     *     start point: P1 = (x1, y1) = (cos(ang1), sin(ang1))
     *     end point:   P4 = (x4, y4) = (cos(ang2), sin(ang2))
     *
     *   Control points:
     *     P2 = (x2, y2)
     *     | x2 = x1 - k * sin(ang1) = cos(ang1) - k * sin(ang1)
     *     | y2 = y1 + k * cos(ang1) = sin(ang1) + k * cos(ang1)
     *
     *     P3 = (x3, y3)
     *     | x3 = x4 + k * sin(ang2) = cos(ang2) + k * sin(ang2)
     *     | y3 = y4 - k * cos(ang2) = sin(ang2) - k * cos(ang2)
     *
     * The formula for this length (k) can be found using the
     * following derivations:
     *
     *   Midpoints:
     *     a) bezier (t = 1/2)
     *        bPm = P1 * (1-t)^3 +
     *              3 * P2 * t * (1-t)^2 + 
     *              3 * P3 * t^2 * (1-t) +
     *              P4 * t^3 =
     *            = (P1 + 3P2 + 3P3 + P4)/8
     *
     *     b) arc
     *        aPm = (cos((ang1 + ang2)/2), sin((ang1 + ang2)/2))
     *
     *   Let angb = (ang2 - ang1)/2; angb is half of the angle
     *   between ang1 and ang2.
     *
     *   Solve the equation bPm == aPm
     *
     *     a) For xm coord:
     *        x1 + 3*x2 + 3*x3 + x4 = 8*cos((ang1 + ang2)/2)
     *
     *        cos(ang1) + 3*cos(ang1) - 3*k*sin(ang1) +
     *        3*cos(ang2) + 3*k*sin(ang2) + cos(ang2) =
     *        = 8*cos((ang1 + ang2)/2)
     *
     *        4*cos(ang1) + 4*cos(ang2) + 3*k*(sin(ang2) - sin(ang1)) =
     *        = 8*cos((ang1 + ang2)/2)
     *
     *        8*cos((ang1 + ang2)/2)*cos((ang2 - ang1)/2) +
     *        6*k*sin((ang2 - ang1)/2)*cos((ang1 + ang2)/2) =
     *        = 8*cos((ang1 + ang2)/2)
     *
     *        4*cos(angb) + 3*k*sin(angb) = 4
     *
     *        k = 4 / 3 * (1 - cos(angb)) / sin(angb)
     *
     *     b) For ym coord we derive the same formula.
     *
     * Since this formula can generate "NaN" values for small
     * angles, we will derive a safer form that does not involve
     * dividing by very small values:
     *     (1 - cos(angb)) / sin(angb) =
     *     = (1 - cos(angb))*(1 + cos(angb)) / sin(angb)*(1 + cos(angb)) =
     *     = (1 - cos(angb)^2) / sin(angb)*(1 + cos(angb)) =
     *     = sin(angb)^2 / sin(angb)*(1 + cos(angb)) =
     *     = sin(angb) / (1 + cos(angb))
     *
     */
 double btan(double increment) {
 increment /= 2.0;
 return 4.0 / 3.0 * sine(increment) / (1.0 + cosine(increment));
    }
    /**
     * Returns the coordinates and type of the current path segment in
     * the iteration.
     * The return value is the path segment type:
     * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.
     * A float array of length 6 must be passed in and may be used to
     * store the coordinates of the point(s).
     * Each point is stored as a pair of float x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point,
     * SEG_QUADTO will return two points,
     * SEG_CUBICTO will return 3 points
     * and SEG_CLOSE will not return any points.
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     */
 int currentSegment(float[] &out coords) {
 if (isDone()) {
 return -1;
 }
 double angle = angStRad;
 if (index == 0) {
     coords[0] =  (x + cosine(angle) * w);
     coords[1] =   (y + sine(angle) * h);
     if (@affine != null) {
  affine.transform(coords, 0, coords, 0, 1);
     }
     return SEG_MOVETO;
 }
 if (index > arcSegs) {
     if (index == arcSegs + lineSegs) {
  return SEG_CLOSE;
     }
     coords[0] =   x;
     coords[1] =   y;
     if (@affine != null) {
  affine.transform(coords, 0, coords, 0, 1);
     }
     return SEG_LINETO;
 }
 angle += increment * (index - 1);
 double relx = cosine(angle);
 double rely = sine(angle);
 coords[0] =   (x + (relx - cv * rely) * w);
 coords[1] =   (y + (rely + cv * relx) * h);
 angle += increment;
 relx = cosine(angle);
 rely = sine(angle);
 coords[2] =   (x + (relx + cv * rely) * w);
 coords[3] =   (y + (rely - cv * relx) * h);
 coords[4] =   (x + relx * w);
 coords[5] =   (y + rely * h);
 if (@affine != null) {
     affine.transform(coords, 0, coords, 0, 3);
 }
 return SEG_CUBICTO;
    }
    /**
     * Returns the coordinates and type of the current path segment in
     * the iteration.
     * The return value is the path segment type:
     * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.
     * A double array of length 6 must be passed in and may be used to
     * store the coordinates of the point(s).
     * Each point is stored as a pair of double x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point,
     * SEG_QUADTO will return two points,
     * SEG_CUBICTO will return 3 points
     * and SEG_CLOSE will not return any points.
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     */
 int currentSegment(double[] &out coords) {
 if (isDone()) {
 return -1;
 }
 double angle = angStRad;
 if (index == 0) {
     coords[0] = x + cosine(angle) * w;
     coords[1] = y + sine(angle) * h;
     if (@affine != null) {
  affine.transform(coords, 0, coords, 0, 1);
     }
     return SEG_MOVETO;
 }
 if (index > arcSegs) {
     if (index == arcSegs + lineSegs) {
  return SEG_CLOSE;
     }
     coords[0] = x;
     coords[1] = y;
     if (@affine != null) {
  affine.transform(coords, 0, coords, 0, 1);
     }
     return SEG_LINETO;
 }
 angle += increment * (index - 1);
 double relx = cosine(angle);
 double rely = sine(angle);
 coords[0] = x + (relx - cv * rely) * w;
 coords[1] = y + (rely + cv * relx) * h;
 angle += increment;
 relx = cosine(angle);
 rely = sine(angle);
 coords[2] = x + (relx + cv * rely) * w;
 coords[3] = y + (rely - cv * relx) * h;
 coords[4] = x + relx * w;
 coords[5] = y + rely * h;
 if (@affine != null) {
     affine.transform(coords, 0, coords, 0, 3);
 }
 return SEG_CUBICTO;
    }
}

ArcIterator@ newArcIterator(Arc2D@ a, AffineTransform@ at) {ArcIterator ret(a, at); return ret;}


 class Ellipse2D : Shape {
 /**         * The X coordinate of the upper-left corner of the         * framing rectangle of this {@code Ellipse2D}.         * @since 1.2         * @serial
  */
   double x;
 /**
         * The Y coordinate of the upper-left corner of the         * framing rectangle of this {@code Ellipse2D}.
         * @since 1.2
         * @serial
  */
   double y;
 /**
  * The overall width of this <code>Ellipse2D</code>.
         * @since 1.2
         * @serial
  */
   double width;
 /**
  * The overall height of the <code>Ellipse2D</code>.
         * @since 1.2
         * @serial
  */
   double height;
 /**
  * Constructs a new <code>Ellipse2D</code>, initialized to
         * location (0,&nbsp;0) and size (0,&nbsp;0).
         * @since 1.2
  */
 Ellipse2D() { x=0; y=0; width=0; height=0;
 }
 /**
  * Constructs and initializes an <code>Ellipse2D</code> from the
         * specified coordinates.
         *
         * @param x the X coordinate of the upper-left corner
         *        of the framing rectangle
         * @param y the Y coordinate of the upper-left corner
         *        of the framing rectangle
         * @param w the width of the framing rectangle
         * @param h the height of the framing rectangle
         * @since 1.2
  */
 Ellipse2D(double xx, double yy, double w, double h) {
     setFrame(xx, yy, w, h);
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   double getX() {
     return x;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   double getY() {
     return y;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   double getWidth() {
     return width;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   double getHeight() {
     return height;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   bool isEmpty() {
     return (width <= 0.0 || height <= 0.0);
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   void setFrame(double xx, double yy, double w, double h) {
     this.x = xx;
     this.y = yy;
     this.width = w;
     this.height = h;
 }
 /**
         * {@inheritDoc}
         * @since 1.2
  */
   Rectangle@ getBounds2D() {
     return newRectangle(x, y, width, height);
 }
 Rectangle@ getBounds() {return getBounds2D();}
      bool contains(double xx, double yy) {
 // Normalize the coordinates compared to the ellipse
 // having a center at 0,0 and a radius of 0.5.
 double ellw = getWidth();
 if (ellw <= 0.0) {
     return false;
 }
 double normx = (xx - getX()) / ellw - 0.5;
 double ellh = getHeight();
 if (ellh <= 0.0) {
     return false;
 }
 double normy = (yy - getY()) / ellh - 0.5;
 return (normx * normx + normy * normy) < 0.25;
    }
    /**
     * {@inheritDoc}
     * @since 1.2
     */
      bool intersects(double xx, double yy, double w, double h) {
 if (w <= 0.0 || h <= 0.0) {
     return false;
 }
 // Normalize the rectangular coordinates compared to the ellipse
 // having a center at 0,0 and a radius of 0.5.
 double ellw = getWidth();
 if (ellw <= 0.0) {
     return false;
 }
 double normx0 = (xx - getX()) / ellw - 0.5;
 double normx1 = normx0 + w / ellw;
 double ellh = getHeight();
 if (ellh <= 0.0) {
     return false;
 }
 double normy0 = (yy - getY()) / ellh - 0.5;
 double normy1 = normy0 + h / ellh;
 // find nearest x (left edge, right edge, 0.0)
 // find nearest y (top edge, bottom edge, 0.0)
 // if nearest x,y is inside circle of radius 0.5, then intersects
 double nearx, neary;
 if (normx0 > 0.0) {
     // center to left of X extents
     nearx = normx0;
 } else if (normx1 < 0.0) {
     // center to right of X extents
     nearx = normx1;
 } else {
     nearx = 0.0;
 }
 if (normy0 > 0.0) {
     // center above Y extents
     neary = normy0;
 } else if (normy1 < 0.0) {
     // center below Y extents
     neary = normy1;
 } else {
     neary = 0.0;
 }
 return (nearx * nearx + neary * neary) < 0.25;
    }
    /**
     * {@inheritDoc}
     * @since 1.2
     */
      bool contains(double xx, double yy, double w, double h) {
 return (contains(xx, yy) &&
  contains(xx + w, yy) &&
  contains(xx, yy + h) &&
  contains(xx + w, yy + h));
    }
    /**
     * Returns an iteration object that defines the boundary of this
     * <code>Ellipse2D</code>.
     * The iterator for this class is multi-threaded safe, which means
     * that this <code>Ellipse2D</code> class guarantees that
     * modifications to the geometry of this <code>Ellipse2D</code> 
     * object do not affect any iterations of that geometry that
     * are already in process.
     * @param at an optional <code>AffineTransform</code> to be applied to
     * the coordinates as they are returned in the iteration, or
     * <code>null</code> if untransformed coordinates are desired
     * @return    the <code>PathIterator</code> object that returns the
     *          geometry of the outline of this <code>Ellipse2D</code>,
     *  one segment at a time.
     * @since 1.2
     */
      PathIterator@ getPathIterator(AffineTransform@ at) {
 return newEllipseIterator(this, at);
    }
 PathIterator@ getPathIterator(AffineTransform@ at, double flatness) {
 PathIterator@ ret=getPathIterator(at);
 return newFlatteningPathIterator(ret, flatness);
}
    /**
     * Determines whether or not the specified <code>Object</code> is
     * equal to this <code>Ellipse2D</code>.  The specified
     * <code>Object</code> is equal to this <code>Ellipse2D</code>
     * if it is an instance of <code>Ellipse2D</code> and if its
     * location and size are the same as this <code>Ellipse2D</code>.
     * @param obj  an <code>Object</code> to be compared with this
     *             <code>Ellipse2D</code>.
     * @return  <code>true</code> if <code>obj</code> is an instance
     *          of <code>Ellipse2D</code> and has the same values;
     *          <code>false</code> otherwise.
     * @since 1.6
     */
      bool equals(Shape@ obj) {
        if (@obj == @this) {
            return true;
        }

 Ellipse2D@ e2d=cast<Ellipse2D>(obj);
    if(@e2d!=null) {

            return ((getX() == e2d.getX()) &&
                    (getY() == e2d.getY()) &&
                    (getWidth() == e2d.getWidth()) &&
                    (getHeight() == e2d.getHeight()));
        }
        return false;
    }

 bool contains(vector v) {return contains(v.x, v.y);}
 bool contains(Rectangle@ r) {return contains(r.x, r.y, r.width, r.height);}
 bool intersects(Rectangle@ r) {return intersects(r.x, r.y, r.width, r.height);}

 Ellipse2D@ clone() {
 Ellipse2D ret(x, y, width, height); return ret;
}
 Shape@ translate(double dx, double dy) {
 Ellipse2D ret(x+dx, y+dy, width, height); return ret;
}
 Shape@ rotate(double theta) {
 return rotate(x+(width/2), y+(height/2), theta);
}
 Shape@ rotate(double cx, double cy, double theta) {
 return rotate(newVector(cx, cy), theta);}
 Shape@ rotate(vector v, double theta) {

 // A Path2D would be good here, but I kinda nerfed it
/* Shape@ s=getBounds();
 @s=s.rotate(v, theta);
 Polygon p=cast<Polygon>(s);
 if(@p!=null) {
*/
 // We would in theory find the midpoint of each segment, and quad around, like so:
/*
 Path2D ret;

 for(uint i=0; i<p.npoints, i++) {
 vector p1(p.xpoints[i], p.ypoints[i]);

 if(i==p.npoints-1) {ret.closePath(); continue;}
 vector p2(p.xpoints[i+1], p.ypoints[i+1]);
 
}// Loop.

*/
/*
 // But since we don't have that, we need something else. Let's go at angles of... Meh.
}
*/

 Polygon ret;
 // iterate the edge of the ellipse.
 double t=0;
 vector c(x+(0.5*width), y+(0.5*height));
 vector p(x+width, c.y);

 double a=0.5*width; double b=0.5*height;
 while(t<2*PI) {

 p.x=c.x+(a*cosine(t));
 p.y=c.y+(b*sine(t));

 p= ::rotate(p, v, theta);
 ret.addPoint(p.x, p.y);
 

 t+=0.1*PI;
}
 ret.addPoint(ret.xpoints[0], ret.ypoints[0]);

 return ret;
}// Rotate.

 Shape@ mirrorX() {return newEllipse2D(-x-width, y, width, height);}
 Shape@ mirrorY() {return newEllipse2D(x, -y-height, width, height);}
}

 Ellipse2D newEllipse2D(double x, double y, double w, double h) {Ellipse2D ret(x, y, w, h); return ret;}

 EllipseIterator@ newEllipseIterator(Ellipse2D@ e, AffineTransform@ at) {EllipseIterator ret(e, at); return ret;}


const double CtrlVal = 0.5522847498307933;
    /*
     * ctrlpts contains the control points for a set of 4 cubic
     * bezier curves that approximate a circle of radius 0.5
     * centered at 0.5, 0.5
     */
 const double pcv = 0.5 + CtrlVal * 0.5;
 const double ncv = 0.5 - CtrlVal * 0.5;
 const double[][] ctrlpts = {
 {  1.0,  pcv,  pcv,  1.0,  0.5,  1.0 },
 {  ncv,  1.0,  0.0,  pcv,  0.0,  0.5 },
 {  0.0,  ncv,  ncv,  0.0,  0.5,  0.0 },
 {  pcv,  0.0,  1.0,  ncv,  1.0,  0.5 }
    };



class EllipseIterator : PathIterator {
    double x;
 double y; double w; double h;
    AffineTransform@ affine;
    int index;
    EllipseIterator(Ellipse2D@ e, AffineTransform@ at) {
 this.x = e.getX();
 this.y = e.getY();
 this.w = e.getWidth();
 this.h = e.getHeight();
 @(this.affine) = at;
 if (w < 0 || h < 0) {
     index = 6;
 }
    }
    /**
     * Return the winding rule for determining the insideness of the
     * path.
     * @see #WIND_EVEN_ODD
     * @see #WIND_NON_ZERO
     */
      int getWindingRule() {
 return WIND_NON_ZERO;
    }
    /**
     * Tests if there are more points to read.
     * @return true if there are more points to read
     */
      bool isDone() {
 return index > 5;
    }
    /**
     * Moves the iterator to the next segment of the path forwards
     * along the primary direction of traversal as long as there are
     * more points in that direction.
     */
      void next() {
 index++;
    }
    // ArcIterator.btan(Math.PI/2)
    /**
     * Returns the coordinates and type of the current path segment in
     * the iteration.
     * The return value is the path segment type:
     * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.
     * A float array of length 6 must be passed in and may be used to
     * store the coordinates of the point(s).
     * Each point is stored as a pair of float x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point,
     * SEG_QUADTO will return two points,
     * SEG_CUBICTO will return 3 points
     * and SEG_CLOSE will not return any points.
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     */
      int currentSegment(float[] &out coords) {
 if (isDone()) {
 return -1;
 }
 if (index == 5) {
     return SEG_CLOSE;
 }
 if (index == 0) {
     double[] ctrls = ctrlpts[3];
     coords[0] =   (x + ctrls[4] * w);
     coords[1] =   (y + ctrls[5] * h);
     if (@affine != null) {
  affine.transform(coords, 0, coords, 0, 1);
     }
     return SEG_MOVETO;
 }
 double[] ctrls = ctrlpts[index - 1];
 coords[0] =   (x + ctrls[0] * w);
 coords[1] =   (y + ctrls[1] * h);
 coords[2] =   (x + ctrls[2] * w);
 coords[3] =   (y + ctrls[3] * h);
 coords[4] =   (x + ctrls[4] * w);
 coords[5] =   (y + ctrls[5] * h);
 if (@affine != null) {
     affine.transform(coords, 0, coords, 0, 3);
 }
 return SEG_CUBICTO;
    }
    /**
     * Returns the coordinates and type of the current path segment in
     * the iteration.
     * The return value is the path segment type:
     * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.
     * A double array of length 6 must be passed in and may be used to
     * store the coordinates of the point(s).
     * Each point is stored as a pair of double x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point,
     * SEG_QUADTO will return two points,
     * SEG_CUBICTO will return 3 points
     * and SEG_CLOSE will not return any points.
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     */
      int currentSegment(double[] &out coords) {
 if (isDone()) {
 return -1;
 }
 if (index == 5) {
     return SEG_CLOSE;
 }
 if (index == 0) {
     double[] ctrls = ctrlpts[3];
     coords[0] = x + ctrls[4] * w;
     coords[1] = y + ctrls[5] * h;
     if (@affine != null) {
  affine.transform(coords, 0, coords, 0, 1);
     }
     return SEG_MOVETO;
 }
 double[] ctrls = ctrlpts[index - 1];
 coords[0] = x + ctrls[0] * w;
 coords[1] = y + ctrls[1] * h;
 coords[2] = x + ctrls[2] * w;
 coords[3] = y + ctrls[3] * h;
 coords[4] = x + ctrls[4] * w;
 coords[5] = y + ctrls[5] * h;
 if (@affine != null) {
     affine.transform(coords, 0, coords, 0, 3);
 }
 return SEG_CUBICTO;
    }
}

int[] Arrays_copyOf(int[] src, int l) {
 int[] ret(l);
 for(uint i=0; ((i<l)&&(i<src.length())); i++) {ret[i]=src[i];}
 return ret;
}

double[] Arrays_copyOf(double[] src, int l) {
 double[] ret(l);
 for(uint i=0; ((i<l)&&(i<src.length())); i++) {ret[i]=src[i];}
 return ret;
}

 const int MIN_LENGTH = 4;
 class Polygon : Shape {
    /**
     * The total number of points.  The value of <code>npoints</code>
     * represents the number of valid points in this <code>Polygon</code>
     * and might be less than the number of elements in 
     * {@link #xpoints xpoints} or {@link #ypoints ypoints}.
     * This value can be NULL.
     *
     * @serial
     * @see #addPoint(int, int)
     * @since 1.0
     */
 int npoints;
    /**
     * The array of X coordinates.  The number of elements in 
     * this array might be more than the number of X coordinates
     * in this <code>Polygon</code>.  The extra elements allow new points
     * to be added to this <code>Polygon</code> without re-creating this
     * array.  The value of {@link #npoints npoints} is equal to the
     * number of valid points in this <code>Polygon</code>.
     *
     * @serial
     * @see #addPoint(int, int)
     * @since 1.0
     */
 double[] xpoints;
    /**
     * The array of Y coordinates.  The number of elements in
     * this array might be more than the number of Y coordinates
     * in this <code>Polygon</code>.  The extra elements allow new points    
     * to be added to this <code>Polygon</code> without re-creating this
     * array.  The value of <code>npoints</code> is equal to the
     * number of valid points in this <code>Polygon</code>. 
     *
     * @serial
     * @see #addPoint(int, int)
     * @since 1.0
     */
 double[] ypoints;
    
    /**
     * The bounds of this {@code Polygon}.
     * This value can be null.
     * 
     * @serial
     * @see #getBoundingBox()
     * @see #getBounds()
     * @since 1.0
     */
 Rectangle@ bounds;

    
    /*
     * Default length for xpoints and ypoints.
     */

    /**
     * Creates an empty polygon.
     * @since 1.0
     */
 Polygon() {
xpoints.resize(MIN_LENGTH);
 ypoints.resize(MIN_LENGTH);
    }
    /**
     * Constructs and initializes a <code>Polygon</code> from the specified 
     * parameters. 
     * @param xpoints an array of X coordinates
     * @param ypoints an array of Y coordinates
     * @param npoints the total number of points in the    
     *    <code>Polygon</code>
     * @exception  NegativeArraySizeException if the value of
     *                       <code>npoints</code> is negative.
     * @exception  IndexOutOfBoundsException if <code>npoints</code> is
     *             greater than the length of <code>xpoints</code>
     *             or the length of <code>ypoints</code>.
     * @exception  NullPointerException if <code>xpoints</code> or
     *             <code>ypoints</code> is <code>null</code>.
     * @since 1.0
     */
      Polygon(double[] xpointsa, double[] ypointsa, int npointsa) {
     // Fix 4489009: should throw IndexOutofBoundsException instead
     // of OutofMemoryException if npoints is huge and > {x,y}points.length
     if (npointsa > xpointsa.length() || npointsa > ypointsa.length()) {
 alert("Index Out of Bounds in Polygon", "npoints " + npointsa + ", xpoints length " + xpointsa.length() + ", ypoints length " + ypointsa.length() + ". ");
 return;
     }
 // Fix 6191114: should throw NegativeArraySizeException with 
 // negative npoints 
 if (npointsa < 0) {
 npointsa=absolute(npointsa);
 }
        // Fix 6343431: Applet compatibility problems if arrays are not
        // exactly npoints in length
 this.npoints = npointsa;
 this.xpoints = Arrays_copyOf(xpointsa, npoints);
 this.ypoints = Arrays_copyOf(ypointsa, npoints);
    }
    /**
     * Resets this <code>Polygon</code> object to an empty polygon.
     * The coordinate arrays and the data in them are left untouched
     * but the number of points is reset to zero to mark the old
     * vertex data as invalid and to start accumulating new vertex
     * data at the beginning.
     * All internally-cached data relating to the old vertices
     * are discarded.
     * Note that since the coordinate arrays from before the reset
     * are reused, creating a new empty <code>Polygon</code> might
     * be more memory efficient than resetting the current one if
     * the number of vertices in the new polygon data is significantly
     * smaller than the number of vertices in the data from before the
     * reset.
     * @see         java.awt.Polygon#invalidate
     * @since 1.4
     */
       void reset() {
 npoints = 0;
 @bounds = null;
    }
    /**
     * Invalidates or flushes any internally-cached data that depends
     * on the vertex coordinates of this <code>Polygon</code>.
     * This method should be called after any direct manipulation
     * of the coordinates in the <code>xpoints</code> or
     * <code>ypoints</code> arrays to avoid inconsistent results
     * from methods such as <code>getBounds</code> or <code>contains</code>
     * that might cache data from earlier computations relating to
     * the vertex coordinates.
     * @see         java.awt.Polygon#getBounds
     * @since 1.4
     */
      void invalidate() {
 @bounds = null;
    }
    /**
     * Translates the vertices of the <code>Polygon</code> by 
     * <code>deltaX</code> along the x axis and by 
     * <code>deltaY</code> along the y axis.
     * @param deltaX the amount to translate along the X axis
     * @param deltaY the amount to translate along the Y axis
     * @since 1.1
     */
      Shape@ translate(double deltaX, double deltaY) {
 for (int i = 0; i < npoints; i++) {
     xpoints[i] += deltaX;
     ypoints[i] += deltaY;
 }
 if (@bounds != null) {
     bounds.moveBy(deltaX, deltaY);
 }
    // invalidate();
    return this;
    }
    /*
     * Calculates the bounding box of the points passed to the constructor.
     * Sets <code>bounds</code> to the result.
     * @param xpoints[] array of <i>x</i> coordinates
     * @param ypoints[] array of <i>y</i> coordinates
     * @param npoints the total number of points
     */
    void calculateBounds(double[] xpoints, double[] ypoints, int npoints) {
 double boundsMinX = MAX_VALUE;
 double boundsMinY = MAX_VALUE;
 double boundsMaxX = MIN_VALUE;
 double boundsMaxY = MIN_VALUE;
 
 for (int i = 0; i < npoints; i++) {
     int x = xpoints[i];
     boundsMinX = Math_min(boundsMinX, x);
     boundsMaxX = Math_max(boundsMaxX, x);
     int y = ypoints[i];
     boundsMinY = Math_min(boundsMinY, y);
     boundsMaxY = Math_max(boundsMaxY, y);
 }
 @bounds = newRectangle(boundsMinX, boundsMinY,
          boundsMaxX - boundsMinX,
          boundsMaxY - boundsMinY);
    }
    /*
     * Resizes the bounding box to accomodate the specified coordinates.
     * @param x,&nbsp;y the specified coordinates
     */
    void updateBounds(int x, int y) {
 if (x < bounds.x) {
     bounds.width = bounds.width + (bounds.x - x);
     bounds.x = x;
 }
 else {
     bounds.width = Math_max(bounds.width, x - bounds.x);
     // bounds.x = bounds.x;
 }
 if (y < bounds.y) {
     bounds.height = bounds.height + (bounds.y - y);
     bounds.y = y;
 }
 else {
     bounds.height = Math_max(bounds.height, y - bounds.y);
     // bounds.y = bounds.y;
 }
    } 
    /**
     * Appends the specified coordinates to this <code>Polygon</code>. 
     * <p>
     * If an operation that calculates the bounding box of this     
     * <code>Polygon</code> has already been performed, such as  
     * <code>getBounds</code> or <code>contains</code>, then this 
     * method updates the bounding box. 
     * @param       x the specified X coordinate
     * @param       y the specified Y coordinate
     * @see         java.awt.Polygon#getBounds
     * @see         java.awt.Polygon#contains
     * @since 1.0
     */
      void addPoint(double x, double y) {
 if (npoints >= xpoints.length || npoints >= ypoints.length) {
     int newLength = npoints * 2;
     // Make sure that newLength will be greater than MIN_LENGTH and 
     // aligned to the power of 2
     if (newLength < MIN_LENGTH) {
  newLength = MIN_LENGTH;
     } else if ((newLength & (newLength - 1)) != 0) {
 ;
     }
            xpoints = Arrays_copyOf(xpoints, newLength);
            ypoints = Arrays_copyOf(ypoints, newLength);
 }
 xpoints[npoints] = x;
 ypoints[npoints] = y;
 npoints++;
 if (@bounds != null) {
     updateBounds(x, y);
 }
    }
    /**
     * Gets the bounding box of this <code>Polygon</code>. 
     * The bounding box is the smallest {@link Rectangle} whose
     * sides are parallel to the x and y axes of the 
     * coordinate space, and can completely contain the <code>Polygon</code>.
     * @return a <code>Rectangle</code> that defines the bounds of this 
     * <code>Polygon</code>.
     * @since 1.1
     */
      Rectangle@ getBounds() {
 return getBoundingBox();
    }
    /**
     * Returns the bounds of this <code>Polygon</code>.
     * @return the bounds of this <code>Polygon</code>.
     * @deprecated As of JDK version 1.1,
     * replaced by <code>getBounds()</code>.
     * @since 1.0
     */
//    @Deprecated
      Rectangle@ getBoundingBox() {
 if (npoints == 0) {
     return newRectangle(0, 0, 0, 0);
 }
 if (@bounds == null) {
     calculateBounds(xpoints, ypoints, npoints);
 }
 return bounds.getBounds();
    }
    /**
     * Determines whether the specified {@link Point} is inside this 
     * <code>Polygon</code>.
     * @param p the specified <code>Point</code> to be tested
     * @return <code>true</code> if the <code>Polygon</code> contains the
     *    <code>Point</code>; <code>false</code> otherwise.
     * @see #contains(double, double)
     * @since 1.0
     */
      bool contains(vector p) {
 return contains(p.x, p.y);
    }
    /**
     * Determines whether the specified coordinates are inside this 
     * <code>Polygon</code>.   
     * <p>
     * @param x the specified X coordinate to be tested
     * @param y the specified Y coordinate to be tested
     * @return {@code true} if this {@code Polygon} contains
     *         the specified coordinates {@code (x,y)};
     *         {@code false} otherwise.
     * @see #contains(double, double)
     * @since 1.1
     */
//      bool contains(int x, int y) {
// return contains((double) x, (double) y);
//    }
    /**
     * Determines whether the specified coordinates are contained in this 
     * <code>Polygon</code>.
     * @param x the specified X coordinate to be tested
     * @param y the specified Y coordinate to be tested
     * @return {@code true} if this {@code Polygon} contains
     *         the specified coordinates {@code (x,y)};
     *         {@code false} otherwise.
     * @see #contains(double, double)
     * @deprecated As of JDK version 1.1,
     * replaced by <code>contains(int, int)</code>.
     * @since 1.0
     */
//    @Deprecated
      bool inside(int x, int y) {
 return contains( x,  y);
    }
    /**
     * {@inheritDoc}
     * @since 1.2
     */
      Rectangle@ getBounds2D() {
 return getBounds();
    }
    /**
     * {@inheritDoc}
     * @since 1.2
     */
      bool contains(double x, double y) {
 Rectangle@ box=getBoundingBox();
        if ((npoints <= 2) || (!box.contains(x, y))) {
     return false;
 }
 int hits = 0;
 int lastx = xpoints[npoints - 1];
 int lasty = ypoints[npoints - 1];
 int curx, cury;
 // Walk the edges of the polygon
 for (int i = 0; i < npoints; i++) {
     curx = xpoints[i];
     cury = ypoints[i];
     if (cury == lasty) {
  continue;
     }
     int leftx;
     if (curx < lastx) {
  if (x >= lastx) {
      continue;
  }
  leftx = curx;
     } else {
  if (x >= curx) {
      continue;
  }
  leftx = lastx;
     }
     double test1, test2;
     if (cury < lasty) {
  if (y < cury || y >= lasty) {
      continue;
  }
  if (x < leftx) {
      hits++;
      continue;
  }
  test1 = x - curx;
  test2 = y - cury;
     } else {
  if (y < lasty || y >= cury) {
      continue;
  }
  if (x < leftx) {
      hits++;
      continue;
  }
  test1 = x - lastx;
  test2 = y - lasty;
     }
     if (test1 < (test2 / (lasty - cury) * (lastx - curx))) {
  hits++;
     }
lastx = curx; lasty = cury; 
 }
 return ((hits & 1) != 0);
    }
/*    private Crossings getCrossings(double xlo, double ylo,
       double xhi, double yhi)
    {
 Crossings cross = new Crossings.EvenOdd(xlo, ylo, xhi, yhi);
 int lastx = xpoints[npoints - 1];
 int lasty = ypoints[npoints - 1];
 int curx, cury;
 // Walk the edges of the polygon
 for (int i = 0; i < npoints; i++) {
     curx = xpoints[i];
     cury = ypoints[i];
     if (cross.accumulateLine(lastx, lasty, curx, cury)) {
  return null;
     }
     lastx = curx;
     lasty = cury;
 }
 return cross;
    }
*/
    /**
     * {@inheritDoc}
     * @since 1.2
     */
//      bool contains(vector p) {
// return contains(p.x, p.y);
//    }
    /**
     * {@inheritDoc}
     * @since 1.2
     */
      bool intersects(double x, double y, double w, double h) {
 Rectangle@ box=getBoundingBox();
 if (npoints <= 0 || !box.intersects(x, y, w, h)) {
     return false;
 }
// Crossings cross = getCrossings(x, y, x+w, y+h);
// return (@cross == null || !cross.isEmpty());

// Annoyed by java's crossings crap.


 vector p1(x, y);
 vector p2(x+w, y);
 vector p3(x, y+h);
 vector p4(x+w, y+h);
 if((contains(p1))||(contains(p2))||(contains(p3))||(contains(p4))) return true;
 for(int i=0; i<npoints; i++) {
 if((xpoints[i]>=x)&&(xpoints[i]<=x+w)&&(ypoints[i]>=y)&&(ypoints[i]<=y+h)) return true;
 vector mp1(xpoints[i], ypoints[i]);
 vector mp2;
 if(i==npoints-1) mp2=newPoint(xpoints[0], ypoints[0]);
 else mp2=newPoint(xpoints[i+1], ypoints[i+1]);
 
 if(
(!isNull(lineIntersects(p1, p2, mp1, mp2)))||
(!isNull(lineIntersects(p2, p4, mp1, mp2)))||
(!isNull(lineIntersects(p1, p3, mp1, mp2)))||
(!isNull(lineIntersects(p3, p4, mp1, mp2)))
) return true;
}// Check each line.
 return false;


    }
    /**
     * {@inheritDoc}
     * @since 1.2
     */
      bool intersects(Rectangle@ r) {
 return intersects(r.x, r.y, r.width, r.height);
    }
    /**
     * {@inheritDoc}
     * @since 1.2
     */
      bool contains(double x, double y, double w, double h) {
// if (npoints <= 0 || !getBoundingBox().intersects(x, y, w, h)) {
//     return false;
// }
// Crossings cross = getCrossings(x, y, x+w, y+h);
// return (cross != null && cross.covers(y, y+h));
 double width=w; double height=h;
 return ((contains(x, y))&&(contains(x+width, y))&&(contains(x, y+height))&&(contains(x+width, y+height)));
    }
    /**
     * {@inheritDoc}
     * @since 1.2
     */
      bool contains(Rectangle@ r) {
 return contains(r.x, r.y, r.width, r.height);
    }
    /**
     * Returns an iterator object that iterates along the boundary of this 
     * <code>Polygon</code> and provides access to the geometry
     * of the outline of this <code>Polygon</code>.  An optional
     * {@link AffineTransform} can be specified so that the coordinates 
     * returned in the iteration are transformed accordingly.
     * @param at an optional <code>AffineTransform</code> to be applied to the
     *   coordinates as they are returned in the iteration, or 
     *  <code>null</code> if untransformed coordinates are desired
     * @return a {@link PathIterator} object that provides access to the
     *  geometry of this <code>Polygon</code>.      
     * @since 1.2
     */
      PathIterator@ getPathIterator(AffineTransform@ at) {
PolygonPathIterator ret(this, at); return ret;
    }
    /**
     * Returns an iterator object that iterates along the boundary of
     * the <code>Shape</code> and provides access to the geometry of the 
     * outline of the <code>Shape</code>.  Only SEG_MOVETO, SEG_LINETO, and 
     * SEG_CLOSE point types are returned by the iterator.
     * Since polygons are already flat, the <code>flatness</code> parameter
     * is ignored.  An optional <code>AffineTransform</code> can be specified 
     * in which case the coordinates returned in the iteration are transformed
     * accordingly.
     * @param at an optional <code>AffineTransform</code> to be applied to the
     *   coordinates as they are returned in the iteration, or 
     *  <code>null</code> if untransformed coordinates are desired
     * @param flatness the maximum amount that the control points
     *   for a given curve can vary from colinear before a subdivided
     *  curve is replaced by a straight line connecting the 
     *   endpoints.  Since polygons are already flat the
     *   <code>flatness</code> parameter is ignored.
     * @return a <code>PathIterator</code> object that provides access to the
     *   <code>Shape</code> object's geometry.
     * @since 1.2
     */
      PathIterator@ getPathIterator(AffineTransform@ at, double flatness) {
 return getPathIterator(at);
    }

 Polygon@ clone() {
 Polygon ret(xpoints, ypoints, npoints); return ret;
}
// Shape@ translate(double dx, double dy) {
// Polygon@ ret=clone();
// for(uint i=0; i<npoints; i++) {ret.xpoints[i]+=dx; ret.ypoints[i]+=dy;}
// return ret;
//}// Translate.
  Shape@ rotate(double theta) {
 Rectangle r=getBounds();
 return rotate(r.x+(r.width/2), r.y+(r.height/2), theta);
}// Rotate.
 Shape@ rotate(double cx, double cy, double theta) {return rotate(newVector(cx, cy), theta);}
  Shape@ rotate(vector v, double theta) {
 Polygon@ ret=clone();
 for(uint i=0; i<npoints; i++) {
 vector p(ret.xpoints[i], ret.ypoints[i]);
 p= ::rotate(p, v, theta);
 ret.xpoints[i]=p.x; ret.ypoints[i]=p.y;
}// Loop.
 return ret;
}// Rotate.

 // A quadrant flip reverses the order, counter clockwise / clockwise and such.
 // To maintain direction, we should reverse the order of the points.
 Shape@ mirrorX() {

 double[] x(npoints); double[] y(npoints);
 for(uint i=0; i<npoints; i++) {
 x[npoints-i-1]=-xpoints[i];
 y[npoints-i-1]=ypoints[i];
}
 Polygon ret(x, y, npoints);
 return ret;
}// Mirror X.
 Shape@ mirrorY() {

 double[] x(npoints); double[] y(npoints);
 for(uint i=0; i<npoints; i++) {
 x[npoints-i-1]=xpoints[i];
 y[npoints-i-1]=-ypoints[i];
}
 Polygon ret(x, y, npoints);
 return ret;
}// Mirror Y.

}

    class PolygonPathIterator : PathIterator {
 Polygon@ poly;
 AffineTransform@ transform;
 int index;
   PolygonPathIterator(Polygon@ pg, AffineTransform@ at) {
     @poly = pg;
     @transform = at;
     if (pg.npoints == 0) {
  // Prevent a spurious SEG_CLOSE segment
  index = 1;
     }
 }
 /**
  * Returns the winding rule for determining the interior of the
  * path.
         * @return an integer representing the current winding rule.
  * @see PathIterator#WIND_NON_ZERO
  */
   int getWindingRule() {
     return WIND_EVEN_ODD;
 }
 /**
  * Tests if there are more points to read.
  * @return <code>true</code> if there are more points to read;
         *          <code>false</code> otherwise.
  */
   bool isDone() {
     return index > poly.npoints;
 }
 /**
  * Moves the iterator forwards, along the primary direction of 
         * traversal, to the next segment of the path when there are
  * more points in that direction.
  */
   void next() {
     index++;
 }
 /**
  * Returns the coordinates and type of the current path segment in
  * the iteration.
  * The return value is the path segment type:
  * SEG_MOVETO, SEG_LINETO, or SEG_CLOSE.
  * A <code>float</code> array of length 2 must be passed in and
         * can be used to store the coordinates of the point(s).
  * Each point is stored as a pair of <code>float</code> x,&nbsp;y
         * coordinates.  SEG_MOVETO and SEG_LINETO types return one
         * point, and SEG_CLOSE does not return any points.
         * @param coords a <code>float</code> array that specifies the
         * coordinates of the point(s)
         * @return an integer representing the type and coordinates of the 
         *   current path segment.
  * @see PathIterator#SEG_MOVETO
  * @see PathIterator#SEG_LINETO
  * @see PathIterator#SEG_CLOSE
  */
   int currentSegment(float[] &out coords) {
     if (index >= poly.npoints) {
  return SEG_CLOSE;
     }
     coords[0] = poly.xpoints[index];
     coords[1] = poly.ypoints[index];
     if (@transform != null) {
  transform.transform(coords, 0, coords, 0, 1);
     }
     return (index == 0 ? SEG_MOVETO : SEG_LINETO);
 }
 /**
  * Returns the coordinates and type of the current path segment in
  * the iteration.
  * The return value is the path segment type:
  * SEG_MOVETO, SEG_LINETO, or SEG_CLOSE.
  * A <code>double</code> array of length 2 must be passed in and
         * can be used to store the coordinates of the point(s).
  * Each point is stored as a pair of <code>double</code> x,&nbsp;y
         * coordinates.
  * SEG_MOVETO and SEG_LINETO types return one point,
  * and SEG_CLOSE does not return any points.
         * @param coords a <code>double</code> array that specifies the
         * coordinates of the point(s)
         * @return an integer representing the type and coordinates of the 
         *   current path segment.
  * @see PathIterator#SEG_MOVETO
  * @see PathIterator#SEG_LINETO
  * @see PathIterator#SEG_CLOSE
  */
   int currentSegment(double[] &out coords) {
     if (index >= poly.npoints) {
  return SEG_CLOSE;
     }
     coords[0] = poly.xpoints[index];
     coords[1] = poly.ypoints[index];
     if (@transform != null) {
  transform.transform(coords, 0, coords, 0, 1);
     }
     return (index == 0 ? SEG_MOVETO : SEG_LINETO);
 }
    }

Polygon@ newPolygon() {Polygon ret; return ret;}
Polygon@ newPolygon(double[] xpoints, double[] ypoints, int npoints) {Polygon ret(xpoints, ypoints, npoints); return ret;}

bool isNull(vector v) {
 return (v.x==nullpoint.x)&&(v.y==nullpoint.y);
}

Line2D@ newLine2D(double x1, double y1, double x2, double y2) {Line2D ret(x1, y1, x2, y2); return ret;}
 Line2D@ newLine2D(vector p1, vector p2) {return newLine2D(p1.x, p1.y, p2.x, p2.y);}
