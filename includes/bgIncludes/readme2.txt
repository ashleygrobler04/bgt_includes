
stdlib.bgt:

In addition to several utility functions, this script also includes the following:
	clock.bgt
	custom_voice2.bgt
	KeyC.bgt
	quickdict.bgt


Functions:

void playsong(string filename, bool looping=true)
Parameters:
filename - the path to the file to play (8.wav or *.ogg)
looping - if true, the sound will loop until stopped.

Remarks:
If all you want to do is play a single layer of background music, this function does most of the work.
To change the default volume at which a track starts playing, change the value of BGMVolume in the default dictionary.

Example:

#include "stdlib.bgt"

void main() {
	a.set("BGMVolume", -10.0);
	playsong("c:\\windows\\media\\ding.wav");
	show_game_window("Ding-a-ling-ding...");
	while(true) {
		if(key_pressed(KEY_F4)) exit();
	}
}


sound@ getBGM(string filename)
Parameter:
filename - the path to the desired sound file
Return Value:
A handle to the sound object with the file loaded, or an inactive sound handle on error.

Remarks:
This function stores sound objects in a dictionary, so they can be referenced later.


void updatebgm(bool fademe=true)
Parameters:
fademe - an optional flag to specify whether or not any fading operations should be performed.

Remarks:
If you want to use the built-in fade features, you must call this function continuously.
Fading works as follows:

* if the value of the global variable nextTrack is not equal to the name of the last file played with the playsong function, the currently playing bgm--if any--will fade to silence, after which point nextTrack plays.
* if nextbgm refers to a playing sound, nextbgm will fade in while the current bgm fades out, resulting in a cross fade effect.
* the value of the global variable fade is added to the volume of the currently playing bgm each time this function is called, until the volume reaches the current bgm volume (if fade is positive), or -50 (if fade is negative). This allows for an arbitrary decay rate.

Example:

#include "stdlib.bgt"

// Play a song, then have it fade out.
void main() {
	a.set("BGMVolume", -5);
	playsong("mysong.ogg");
	timer time;
	while(bgm.volume>-50) {
		if(time.elapsed>10000) fade=-1;
		updatebgm();
		wait(20);
	}
}


void crossfade(string filename, int f, bool loop=true)
Parameters:
filename - the path to the file to crossfade
f - how quickly the fade should occur. Both sounds will change volume by this value each frame until the crossfade is complete.
loop - if set to true, the crossfaded sound will loop until stopped.

Remarks:
This function begins the crossfade process, but updatebgm must be called continuously for it to complete.

Example:

#include "stdlib.bgt"

// Crossfade between tracks when the user presses the spacebar.

void main() {
	playsong("song1.ogg");
	show_game_window("Crossfade test");
	while(key_pressed(KEY_F4)==false) {
		updatebgm();
		wait(20);
		if(key_pressed(KEY_SPACE)) {
			if(curbgm=="song1.ogg") crossfade("song2.ogg", 1);
			else crossfade("song1.ogg", 1);
		}
	}
}



int hex_to_digits(string hex)
Parameters:
hex - the string to parse
Return Value:
An integer variable containing the value represented by the given string.
Remarks:
This function is wrapped by hex_to_number(string hex), because I kept forgetting which it was.


sound@ noise(uint length, int drag=0)
Parameters:
length - the length of the generated noise, in milliseconds
drag - the amount of interpolation between noise samples. A positive value for drag will multiply the length by that value (see remarks).
Return Value:
A handle to a sound object containing the generated noise.

Remarks:
This function generates white noise of an arbitrary duration.
The drag parameter simulates an effect found on older hardware, where noise could be generated by rapidly changing the pitch of a square wave.
The total duration of the generated noise is equivalent to length*drag, unless drag is less than 1.
If drag is unspecified, or less than 1, no drag will be applied.



string randstring(string[] ar)
Parameters:
arr - an array of strings
Return Value:
A randomly selected string from the given array, or an empty string if the array is empty.


string[] newString(string s0, string s1="", ... string s15=0)
Parameters:
1 to 15 strings
Return Value:
An array containing the given strings.

Remarks:
BGT does not seem to like changing arrays in the same manner in which they are created.
This function gets around this by allowing you to do the following:

string[] myStrings={"Apple", "Banana", "Canteloupe"};
myStrings = newString("Donuts", "eggs", "fries");

Please Note: The returned array will not contain any empty strings.

string number_to_hex_string64(uint64 i)
Parameters:
i - the int64 to convert
Return Value:
A string representing the given int64 in hexadecimal.


uint64 hex_to_digits64(string hex)
Parameters:
hex - the string to parse
Return Value:
A 64-bit integer variable based on the given string.

Remarks:
Signed and unsigned values get weird when converting between 32-bit and 64-bit ints.
I've tried to account for this, but I might have missed a case where this corrupts the upper 32 its.
If this happens, please report it.



string vecstr(vector v)
Parameters:
v - the vector to describe
Return Value:
A string representation of the given vector, in integer precision.


int[] newInt(int i0, int i1=0x7bcdefff, ... int i15=0x7bcdefff)
Parameters:
1 to 15 integer variables
Return Value:
An array containing the given ints.

Remarks:
See newString.

double[] newDouble(double d0, double d1=0x7bcdefff, ... double d15=0x7bcdefff)
Parameters:
1 to 15 doubles
Return Value:
 An array containing the given doubles.

Remarks:
See newInt.


string[] string_add(string[] o, string[] n)
int[] int_add(int[] o, int[] n)
double[] double_add(double[] o, double[] n)
Parameters:
o - the original array
n - the array to be appended
Return Value:
An array containing all the values in o, followed by all the values in n (see remarks).

Remarks:
These functions *DO* modify the original array.



clock.bgt:

Contains the clock object.
The clock object is used to keep the game updating at a constant framerate.
In addition, an instance of the clock object keeps track of how many frames have passed since its creation. This is useful if, for example, you want to run enemy AI only once every 10 frames.
clock.bgt is included by stdlib.bgt.

Example:

#include "stdlib.bgt"

void main() {
	// Create a clock that runs at 50 frames per second.
	clock fps(50.0);
	// Run the clock for 10 seconds, or 500 frames.
	while(fps.frame<500) {
		fps.tick();
	}
	alert("Done", "500 frames have passed.");
}



custom_voice2.bgt

Contains the custom_voice class.
This file is almost identical to custom_voice.bgt.
The difference is that word_speaker has been removed, so that it can be used without requiring the custom_pool.
Also, the option of outputting to the clipboard has been added. This might be useful for translating game output from one language to another, as an example.



dynamic_menu.bgt
enhanced_menu.bgt

These are equivalent to their counterparts as created by philip_bennefall and JasonSW, except that they use the custom_voice object instead of tts_voice.



game.bgt

Includes the game class, a superclass which handles basic functions and events.
There is no need to create an instance of game directly. Instead, create subclasses which override the desired methods, such as key_pressed, key_released, pad_step, and tick.


Properties:
clock@ game_clock - the clock which keeps the game running at a constant framerate. The default framerate is 50 frames per second.
bool allow_alt_f4 - If set to true, the game will exit when the user presses alt+f4. Set to true by default.

Constructors:
game()
game(double frames_per_second)
Parameters:
frames_per_second - the desired framerate.

Methods:
reset(double frames_per_second)
- Resets the game clock

void start(string title)
- Begins running the game. Please note that this both opens the game window, and begins the loop, meaning that any further actions will be suspended until the game is ended.

void key_pressed(int k)
Parameters:
k - the key which was pressed
void key_released(int k)
Parameters:
k - the key which was released
void tick()

Remarks:
These methods do nothing, and are meant to be overwridden.
The key_pressed method is called whenever a key is pressed. Use it to handle user input.
The key_released method is called whenever a key is released. If you are using remappable controls (for example, a KeyC object), you will probably need this method.
The tick method is called every frame, and is where events which do not require user input should occur. If you are using the bgm functions in stdlib.bgt, this is where you should call updatebgm().



JMenu.bgt

Contains the Menu and MenuItem classes.

The Menu class is meant to be used for menus which do not block the game entirely, or for menus which need a persistent state when not in use.
The Menu class is not bound to any input method or command. This means that you can allow more buttons than the traditional up/down/enter/escape.

Properties:
MenuItem@[] items: An array of the items in the menu.
int selected: the index of hte currently selected item.
string toplay: The filename corresponding to the last action to be performed. This value can be modified from the script, so should be relied upon only immediately after a menu method has been called.
string title: An optional text description of this menu.
string bgm: An optional value to contain the filename of the music to be played when this menu is active.
Menu@ previous: In the case of submenus, the menu above this one.
string move: the filename of the sound to be played when the player selects a different menu item.
string toggle: the filename of the sound to be played when the player changes the value of the current menu item.
string activate: the filename of the sound to be played when the player activates a menu item.

Methods:
void selectNext() : selects the next item in the menu.
void selectPrevious() : selects the previous item in the menu.
void changeBy(int dx) : If the selected menu item is of type MENU_VALUE_SELECT, changes the value by the specified amount.
int follow() : Sets toplay to activate, and returns the value of the selec ted menu item.
void add(string item_name, int type):
- Creates a new MenuItem and adds it to the end of hte menu.
- Possible values for tpe are as follows:
		MENU_ENTER: An item of this type can be activated, but not modified. For example, a "start game" or "exit" option.
		MENU_VALUE_SELECT: An item of this type has a value which can be modified. For example, difficulty, background music volume, pan_step, etc.

MenuItem@ getCurrent() : returns the currently selected MenuItem.
MenuItem@ get(int index) : returns the MenuItem at the specified index.
string toString() : Returns a string representation of this Menu.


Properties of MenuItem:
string label: The name of the item, for example "New Game" or "Difficulty".
int type: Either MENU_ENTER or MENU_VALUE_SELECT (see Menu::add).
int value: A numeric value associated with this menu item. FOr items of type MENU_VALUE_SELECT, this value can be changed by Menu::changeBy.
int max, int min: The maximum and minimum possible values for this MenuItem.
bool loop
string values: A string description of the possible values of this menu item, delineated by \n. For example, a difficulty option might have the values "Easy\nNormal\nHard".
string select: an optional sound to be played when this item is selected.
string change: an optional sound to be played when the value of this menu item is changed.
string getValueLabel: returns the name of the current value of this item. If values is empty, the numeric value is returned.
string toString: Returns a text representation of this item.


Example:

#include "JMenu.bgt"

void main() {
	Menu@ menu=newMenu("Game Menu");
	menu.add("Exit", MENU_ENTER);
	MenuItem@ mi=menu.get(0);
	mi.value=-1;
	menu.add("Difficulty", MENU_VALUE_SELECT);
	@mi=menu.get(1);
	mi.values="Easy\nNormal\nHard\nInsane";
	mi.value=1;
	mi.max=3;
	mi.min=0;
	menu.move="menu_select.wav";
	menu.toggle="menu_change.wav";
	
	show_game_window("Menu Test") {
		wait(10);
		if(key_pressed(KEY_RETURN)) {
			int value=menu.follow();
			if(value<0) exit();
		}// Activate.
		else if(key_pressed(KEY_UP)) menu.selectPrevious();
		else if(key_pressed(KEY_DOWN)) menu.selectNext();
		else if(key_pressed(KEY_LEFT)) menu.changeBy(-1);
		else if(key_pressed(KEY_RIGHT)) menu.changeBy(1);
		
		if(menu.toplay!="") {
			menu.toplay="";
			show_game_window(menu.getCurrent().toString());
		}
	}
}



KeyC.bgt:

A class to bridge event-based and poll-based input, allowing custom key configurations.

Constants:
A, B, C, X, Y, Z: built-in buttons.
L, R, U, D: Constants for directional controls left, right, up, and down, respectively.
START: Constant for the start button.
KeyC_none: A constant to indicate that no valid button has been pressed.

Functions:
double math_random(): I have no idea why this is in this file. Returns a random value between 0 and 1.


KeyC class:

properties:
int a, b, c, x, y, z,
l, r, u, d,
start : the key codes mapped to the corresponding commands.
int lastPressed: the value of the last key pressed.

methods:
int getKey(int k) : returns the constant corresponding to the igven key, or KeyC_none if hte key is not mapped.
bool isKeyPressed(int k) : Returns true if the key corresponding to the given button constant is pressed, false otherwise or if an invalid value is given.
int press(int k): Returns the constant mapped to the given key, and sets it as pressed.
int release(int k) : returns the constant mapped to the given key, and sets it as unpressed.

Functions:
string KeyC_save(KeyC@ k) : Returns a string representation of the given KeyC, which is compatible with KeyC_load.
KeyC@ KeyC_load(string txt, KeyC@ kc=null) : Returns a KeyC object set to match the given configuration. If the optional kc value is not null, the given KeyC object is the one to be set.




looping_sound.bgt:

<This space is under construction>



quickdict.bgt:


Contains functions for quickly retrieving primitives from a dictionary.
Provides a default dictionary, called a. The functions refer to a by default.

Functions:
int geti(string key)
double getd(string key)
float getf(string key)
string gets(string key)
- Returns the dictionary entry corresponding to the given key. If the key is not found, -1 or the empty string is returned instead.

